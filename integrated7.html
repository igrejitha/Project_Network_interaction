<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Interactive Project Task Map</title>
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <!-- Google Charts -->
    <script src="https://www.gstatic.com/charts/loader.js" type="text/javascript"></script>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <title>Gantt Chart</title>
    <script src="https://www.gstatic.com/charts/loader.js" type="text/javascript"></script>
    <script src="https://kryogenix.org/code/browser/sorttable/sorttable.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <!-- Scripts for Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://unpkg.com/vis-network@7.6.2/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
    <script src="https://unpkg.com/vis-network@7.6.2/dist/vis-network.min.js" type="text/javascript"></script>
    <link href="css/style.css" rel="stylesheet" />
    <link href="css/site.css" rel="stylesheet" />
    <link href="img/Blue_Logo.png" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" type="text/css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">

    <!-- Include Flatpickr CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">

    <!-- Include Flatpickr JS -->
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script>
    const centerTextPlugin = {
        afterDraw: (chart) => {
            let width = chart.chart.width,
                height = chart.chart.height,
                ctx = chart.chart.ctx;

            ctx.restore();
            let fontSize = (height / 114).toFixed(2);
            ctx.font = fontSize + "em Orbitron";
            ctx.textBaseline = "middle";

            let sum = chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
            let text = `Total: ${sum} days`,
                textX = Math.round((width - ctx.measureText(text).width) / 2),
                textY = height / 2;

            ctx.fillText(text, textX, textY);
            ctx.save();
        }
    };
    Chart.plugins.register(centerTextPlugin);

    </script>
    <style>
        /* Links */
        .links line {
            stroke: linear-gradient(to right, #8ce6ff, #3292cd);
            stroke-width: 3px;
        }

        .link {
            stroke: #cdfaff;
            stroke-opacity: 0.85;
            stroke-width: 1.5px;
        }

        /* Refining links */
        .links line {
            stroke: #8ce6ff;
            stroke-width: 2px;
        }

        /* Nodes */
        .node text {
            fill: #b4f5ff;
            font-size: 12px;
        }

        .node circle {
            stroke: #41afeb;
            stroke-width: 2px;
            fill: #0d2137;
            transition: fill 0.3s;
            filter: url(#drop-shadow);
        }


        /* Futuristic Node Label */
        .node-label {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.6);
            border: 1px solid #58a6ff;
            color: #58a6ff;
            padding: 5px 10px;
            border-radius: 5px;
            transform: scale(0);
            transition: transform 0.3s ease-out;
            pointer-events: none;
            text-shadow: 0 0 5px #58a6ff;
        }

        /* Enhanced Futuristic Connection Label */
        .connection-label {
            position: absolute;
            background-color: rgba(10, 10, 50, 0.85);
            border: 2px solid #58a6ff;
            color: #58a6ff;
            padding: 8px 15px;
            border-radius: 8px;
            transform: scale(0);
            transition: transform 0.3s ease-out, opacity 0.3s ease-out;
            pointer-events: none;
            font-size: 0.9em;
            opacity: 0;
            text-shadow: 0 0 10px #58a6ff, 0 0 20px #58a6ff, 0 0 30px #58a6ff;
        }

        /* Animation effect */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .input {
            width: 50% !important;
            margin: 0px auto;
        }

        div.vis-configuration.vis-config-label {
            color: black !important;
        }

        .vis-configuration-wrapper {
            width: 100% !important;
        }

        .tooltip {
            position: absolute;
            padding: 5px; /* Increased padding for more space */
            background-color: rgba(16, 45, 80, 0.9);
            color: #00ff00;
            border-radius: 5px;
            pointer-events: none;
            max-width: 230px;
            font-family: 'Roboto', sans-serif;
            z-index: 1000; /* Ensure tooltip is above everything else */
            /* Using a darker gradient border */
            border: 3px solid transparent;
            background-image: linear-gradient(rgba(16, 45, 80, 0.9), rgba(16, 45, 80, 0.9)), linear-gradient(90deg, #8ce6ff, #3292cd);
            background-origin: padding-box, border-box;
            background-clip: content-box, border-box;
        }

        .charts-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 20px;
            box-sizing: border-box;
        }

        #riskTable {
            width: 80%; /* Increase table width */
            margin: 0 auto; /* Center the table within its container */
        }

        .charts-row {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            width: 100%;
            margin-bottom: 30px; /* Spacing between the rows */
        }

        /* Dashboard Card */
        .dashboard-card {
            background-color: #113464;
            padding: 10px;
            color: #b4f5ff;
            border-radius: 10px;
            margin-bottom: 30px;
            box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);
            position: relative;
            z-index: 1;
            overflow: hidden;
        }

        .dashboard-card2 {
            padding: 10px; /* Adjust this to set your desired padding */
            border: 1px solid #ccc;
            border-radius: 4px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            background-color: #0e2446;
            margin: 20px; /* Optional: Adds some margin around the card */
            overflow: hidden; /* Optional: In case the content spills out */
            font-size: 0.85em; /* This makes the font size smaller for all elements inside the card */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
        }

            /* If you want specific elements to have even smaller fonts, you can target them like this */
            .dashboard-card2 h3 {
                font-size: 1em; /* Adjusted font-size for h3 elements inside the dashboard card */
            }

            .dashboard-card2 p, .dashboard-card2 li {
                font-size: 0.8em; /* Adjusted font-size for p and li elements inside the dashboard card */
            }

            .dashboard-card2 button {
                /* width: 23%;  */
                height: 30px; /* Compact height */
                background: linear-gradient(45deg, #5ac8fa, #287dc8); /* Gradient background */
                color: #ffffff; /* Font color */
                border: none; /* Removing the default border */
                border-radius: 5px; /* Slightly rounded corners */
                cursor: pointer;
                font-weight: bold; /* Bold font for clarity */
                text-transform: uppercase; /* Uppercase letters for a modern look */
                letter-spacing: 1px; /* Spacing between letters for clarity */
                box-shadow: 0 0 10px rgba(90, 200, 250, 0.5); /* A soft glow effect */
                transition: all 0.3s; /* Transition for hover effects */
            }

                .dashboard-card2 button:hover {
                    transform: translateY(-3px); /* Button moves up slightly on hover */
                    box-shadow: 0 0 15px rgba(90, 200, 250, 0.7); /* Increased glow on hover */
                }

                .dashboard-card2 button:active {
                    transform: translateY(0); /* Button returns to original position when clicked */
                }

        .dashboard-card2 {
            flex: 1;
            /* max-width: calc(33.33% - 20px); Three cards per row with spacing */
        }

        .dashboard-card-full {
            width: 98%; /* Occupying most of the width for emphasis */
            /* box-shadow: 0 6px 12px rgba(0,0,0,0.15);  Enhanced shadow for emphasis
            border: 1px solid #29395f;  Slight border for definition against the background */
        }

        div#pathMetrics {
            width: 98%;
        }

        .risk-content {
            display: flex;
            flex-direction: column; /* Stack the children vertically */
            gap: 16px; /* Provide a small gap between the chart and table */
            align-items: center; /* Center-align the children horizontally */
        }

        .chart-container, .table-container {
            width: 100%; /* Use full available width */
        }

        .chart-container {
            flex: 1.2; /* Allow the chart container to be slightly wider */
        }

        .table-container {
            flex: 1; /* Allow the table container to grow and shrink */
        }

        #riskTable {
            width: 100%; /* Increase table width */
            margin: 0 auto; /* Center the table within its container */
        }

        div.vis-configuration.vis-config-item.vis-config-s3 {
            background-color: #0f2d51 !important;
        }

        div.vis-configuration.vis-config-item.vis-config-s2 {
            background-color: #0f2d51 !important;
        }

        div.vis-configuration.vis-config-item.vis-config-s4 {
            background-color: #0f2d51 !important;
        }

        div.vis-configuration.vis-config-label {
            color: white !important;
        }

        #configuration-container .vis-configuration .vis-config-item {
            margin: 1.5rem !important;
            padding: 2rem !important;
        }

        .futuristic-card {
            background-image: url('https://www.transparenttextures.com/patterns/space.png');
            background-color: rgba(0, 0, 0, 0.6);
            padding: 40px;
        }

            .futuristic-card:hover {
                box-shadow: 0px 0px 20px #58a6ff;
            }

        .futuristic-header {
            background: rgba(0, 0, 0, 0.2);
            border-top-left-radius: 15px;
            border-top-right-radius: 15px;
            padding: 10px 20px;
            box-shadow: 0 0 10px #5ac8fa;
        }

        .futuristic-introduction {
            color: #cdfaff;
            font-size: 18px;
            margin-top: 20px;
            line-height: 1.6;
            text-align: center;
            padding: 0 10%;
            margin-bottom: 30px;
        }

        .label-container {
            display: flex;
            justify-content: space-between; /* Adjusts spacing between label and span */
            align-items: center; /* Centers items vertically */
        }

        #outDegreeFilterValue, #filterValue, #degreeFilterValue {
            font-size: 1.5em; /* Adjusts the size of the span text */
        }

        #graph-container {
            background-color: #0d2137;
            overflow: auto;
            position: relative;
            height: 1000px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
            flex-grow: 1; /* Allow graph container to grow and occupy available space */
            width: 96%;
            margin: 0 auto;
        }

            #graph-container svg {
                width: 100%;
                height: 100%;
            }

        /* Control Panel */
        .control-panel {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: space-between;
            align-items: center;
            background: #0e2446;
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        input#searchInput {
            width: 95%;
            padding: 0.6rem;
        }

        .control-label {
            font-weight: bold;
            color: #b4f5ff;
            margin-bottom: 10px;
            display: block;
        }

        .control-panel button {
            width: 50px; /* Compact width */
            height: 30px; /* Compact height */
            background: linear-gradient(45deg, #5ac8fa, #287dc8); /* Gradient background */
            color: #ffffff; /* Font color */
            border: none; /* Removing the default border */
            border-radius: 5px; /* Slightly rounded corners */
            cursor: pointer;
            font-weight: bold; /* Bold font for clarity */
            text-transform: uppercase; /* Uppercase letters for a modern look */
            letter-spacing: 1px; /* Spacing between letters for clarity */
            box-shadow: 0 0 10px rgba(90, 200, 250, 0.5); /* A soft glow effect */
            transition: all 0.3s; /* Transition for hover effects */
        }

            .control-panel button:hover {
                transform: translateY(-3px); /* Button moves up slightly on hover */
                box-shadow: 0 0 15px rgba(90, 200, 250, 0.7); /* Increased glow on hover */
            }

            .control-panel button:active {
                transform: translateY(0); /* Button returns to original position when clicked */
            }

        transform: scale(1.1);
        }

        .joystick {
            display: grid;
            grid-template-rows: repeat(3, 30px);
            grid-template-columns: repeat(3, 30px);
            gap: 5px;
        }

            .joystick .arrow,
            .joystick .center {
                width: 30px; /* Consistent width */
                height: 30px; /* Consistent height */
                display: flex;
                align-items: center;
                justify-content: center;
                background: linear-gradient(45deg, #5ac8fa, #287dc8); /* Gradient background */
                color: #ffffff; /* Font color */
                border: none; /* Removing the default border */
                cursor: pointer;
                font-weight: bold; /* Bold font for arrows */
                text-transform: uppercase; /* Uppercase letters */
                box-shadow: 0 0 10px rgba(90, 200, 250, 0.5); /* A soft glow effect */
                transition: all 0.3s; /* Transition for hover effects */
            }

                .joystick .arrow:hover,
                .joystick .center:hover {
                    transform: translateY(-3px); /* Slight move up on hover */
                    box-shadow: 0 0 15px rgba(90, 200, 250, 0.7); /* Increased glow on hover */
                }

                .joystick .arrow:active,
                .joystick .center:active {
                    transform: translateY(0); /* Button returns to original position when clicked */
                }

            .joystick .center {
                border-radius: 50%; /* Circular shape for the center button */
            }


        .slider {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none; /* Remove default appearance for Webkit browsers */
            appearance: none;
            height: 5px; /* Height of the slider */
            background: #b4f5ff; /* Lighter background color for the track */
            border-radius: 5px; /* Rounded edges */
            outline: none; /* Remove default outline */
            box-shadow: 0 0 10px rgba(205, 250, 255, 0.3); /* Soft shadow with a lighter color */
        }

            .slider::-webkit-slider-thumb {
                -webkit-appearance: none; /* Remove default appearance for Webkit browsers */
                appearance: none;
                width: 15px; /* Width of the thumb */
                height: 15px; /* Height of the thumb */
                background: linear-gradient(45deg, #cdfaff, #8ce6ff); /* Lighter gradient background */
                border-radius: 50%; /* Circular shape for the thumb */
                cursor: pointer; /* Cursor changes to pointer */
                box-shadow: 0 0 5px rgba(205, 250, 255, 0.5); /* Soft shadow with a lighter color */
                transition: transform 0.3s; /* Transition for hover effect */
            }

                .slider::-webkit-slider-thumb:hover {
                    transform: scale(1.1); /* Slightly enlarge the thumb on hover */
                }

            /* For Firefox browsers */
            .slider::-moz-range-track {
                background: #b4f5ff;
                border-radius: 5px;
                box-shadow: 0 0 10px rgba(205, 250, 255, 0.3);
            }

            .slider::-moz-range-thumb {
                width: 15px;
                height: 15px;
                background: linear-gradient(45deg, #cdfaff, #8ce6ff);
                border-radius: 50%;
                cursor: pointer;
                box-shadow: 0 0 5px rgba(205, 250, 255, 0.5);
                transition: transform 0.3s;
            }

                .slider::-moz-range-thumb:hover {
                    transform: scale(1.1);
                }

        .zoom-controls, .rotate-controls {
            flex-basis: 30%;
        }

        .pan-controls {
            flex-basis: 35%;
        }

        .control-panel button {
            width: 100%;
        }

        #legend {
            font-family: 'Arial', sans-serif;
            font-size: 14px;
            margin-top: 10px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

        .color-box {
            width: 20px;
            height: 20px;
            border: 1px solid #000;
            margin-right: 10px;
        }

        .accordion-button {
            cursor: pointer;
            padding: 10px;
            width: 100%;
            text-align: left;
            background: #007bff;
            color: #fff;
            border: none;
            outline: none;
            transition: background-color 0.3s;
        }

            .accordion-button:hover {
                background-color: #0056b3;
            }

        button, input[type="submit"], input[type="button"] {
            background-color: #195a8c;
            border: 1px solid #5ac8fa;
            color: #b4f5ff;
            padding: 8px 16px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 3px;
            transition: background-color 0.3s, transform 0.3s, box-shadow 0.2s, color 0.3s;
        }

            button:hover, input[type="submit"]:hover, input[type="button"]:hover {
                background-color: #287dc8;
                color: #cdfaff;
                transform: scale(1.02);
                box-shadow: 0 0 8px #41afeb;
            }

        body {
            font-family: 'Arial', sans-serif;
            background-color: #113464; /* Dark blue background for a space-like aesthetic */
        }

        .panel {
            padding: 0 10px;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }

        .bar {
            fill: #3292cd; /* Updated from the color palette */
        }

            .bar:hover {
                fill: #5ac8fa; /* Updated from the color palette */
            }

        .axis-label {
            font-size: 14px;
            fill: #b4f5ff; /* Updated from the color palette */
        }

        .axis path,
        .axis line {
            fill: none;
            stroke: #b4f5ff; /* Updated from the color palette */
            shape-rendering: crispEdges;
        }

        .chart-container {
            padding: 20px;
            border: 1px solid #3292cd; /* Updated from the color palette */
            margin: 20px 0;
            background: linear-gradient(145deg, #113464, #0e2446);
            box-shadow: 4px 4px 10px #102d50, -4px -4px 10px #0e2446;
        }

        .chart-title {
            text-align: center;
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #b4f5ff; /* Updated from the color palette */
        }

        .chart-legend {
            display: flex;
            justify-content: center;
            margin-top: 20px;
            color: #b4f5ff; /* Updated from the color palette */
        }

        .chart-legend-item {
            margin: 0 10px;
        }

        #scurve_chart, #histogramChart, #pie_chart {
            width: 100%;
            max-width: 600px;
            height: 400px;
            margin: 0 auto;
        }

        /* Added hover effects for the interactive feel */
        .chart-container:hover {
            background: linear-gradient(145deg, #0e2446, #113464);
            box-shadow: 6px 6px 14px #102d50, -6px -6px 14px #0e2446;
        }

        /* Style for the new chart containers */
        #taskDurationHistogram, #taskDegreePieChart {
            width: 100%;
            max-width: 600px;
            height: 400px;
            margin: 20px auto;
            padding: 20px;
            border: 1px solid #3292cd;
            background: linear-gradient(145deg, #113464, #0e2446);
            box-shadow: 4px 4px 10px #102d50, -4px -4px 10px #0e2446;
        }

        .tooltip {
            position: absolute;
            background-color: white;
            border: 1px solid black;
            padding: 5px;
            border-radius: 5px;
            pointer-events: none;
            opacity: 0;
        }

        .activity-list {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(255, 255, 255, 0.7);
            padding: 10px;
            border-radius: 5px;
            max-height: 500px; /* Adjust as needed */
            overflow-y: auto;
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: #f3f3f3;
            border-radius: 5px;
            box-shadow: inset 0 0 5px rgba(0,0,0,0.2);
        }

        .progress-bar {
            height: 100%;
            background-color: #ddd; /* This represents the duration */
        }

        .progress-bar-fill {
            height: 100%;
            background-color: #4CAF50; /* This represents the completion */
            width: 0%; /* Default to 0% completion */
            border-radius: 5px 0 0 5px;
            animation: progressBarFillAnimation 1s ease-in-out;
        }

        @keyframes progressBarFillAnimation {
            0% {
                width: 0%;
            }

            100% {
                width: /* This will be set dynamically */;
            }
        }

        .dashboard-table td:nth-child(7) { /* assuming 'Progress Bar' is the 9th column */
            width: 400px; /* adjust to a larger value as needed */
            max-width: 400px; /* add this line to ensure it doesn't shrink beyond this width */
        }


        .vis-configuration-wrapper {
            background-color: #0f2d51;
            /* Adjust as needed font-family: 'Arial', sans-serif;
            // Adjust as needed */
        }

            .vis-configuration-wrapper button {
                background-color: #007bff;
                color: white;
                border: none;
                padding: 5px 15px;
                border-radius: 5px;
            }

                .vis-configuration-wrapper button:hover {
                    background-color: #0056b3;
                }

        /* Adjusting the layout for better spacing and alignment */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        table, th, td {
            border: 1px solid #3292cd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #195a8c;
            color: #cdfaff;
        }

        td {
            background-color: #0d2137;
            color: #b4f5ff;
        }

        tr:hover {
            background-color: #195a8c;
        }

        button, input[type="submit"], input[type="button"] {
            background-color: #41afeb;
            border: none;
            color: white;
            padding: 10px 20px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s, transform 0.3s;
        }

            button:hover, input[type="submit"]:hover, input[type="button"]:hover {
                background-color: #00d4ff;
                transform: scale(1.05);
            }

        .project-dropdown, .location-dropdown {
            transition: all 0.3s ease;
            border: none;
            border-bottom: 2px solid #46b9fa;
            background: transparent;
            color: white;
            font-size: 16px;
            margin-bottom: 15px;
        }

            .project-dropdown:focus, .location-dropdown:focus {
                outline: none;
                border-bottom: 2px solid #ffffff;
            }

            .project-dropdown:hover, .location-dropdown:hover {
                background: linear-gradient(145deg, #5ac8fa, #1e69aa);
            }

        .upload-section {
            background: linear-gradient(145deg, #0e2446, #287dc8);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 10px 10px 30px #0b2c55, -10px -10px 30px #66dbff;
            transition: transform 0.3s ease;
        }

        .upload-btn-wrapper .btn {
            border-radius: 30px;
            letter-spacing: 1.5px;
            font-weight: bold;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px #46b9fa, inset 0 0 10px #5ac8fa;
        }

            .upload-btn-wrapper .btn:hover {
                background: linear-gradient(145deg, #287dc8, #0e2446);
                box-shadow: 0 0 30px #46b9fa, inset 0 0 20px #5ac8fa;
                transform: translateY(-2px) scale(1.05);
            }

        .upload-description {
            font-size: 18px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 10px #0e2446;
            font-weight: bold;
        }

        .upload-btn-wrapper .btn {
            background: transparent;
            border: 2px solid #5ac8fa;
        }

            .upload-btn-wrapper .btn:hover {
                background: #5ac8fa;
                color: #0e2446;
            }

        .project-dropdown, .location-dropdown {
            width: 100%;
            padding: 10px;
            border: 2px solid #5ac8fa;
            border-radius: 30px;
            background: transparent;
            font-size: 18px;
            color: #5ac8fa;
            margin-bottom: 20px;
            transition: background 0.3s ease, color 0.3s ease;
        }

            .project-dropdown:focus, .location-dropdown:focus {
                background: #5ac8fa;
                color: #0e2446;
                outline: none;
            }

            .project-dropdown option, .location-dropdown option {
                color: #0e2446;
                background: #5ac8fa;
            }

        #networkCanvasEnhanced {
            width: 100%;
            height: 100%;
        }

        .upload-section h1 {
            font-size: 30px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 10px #0e2446;
        }

        .upload-btn-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }

            .upload-btn-wrapper .btn {
                background-color: #287dc8;
                color: #fff;
                padding: 10px 30px;
                font-size: 16px;
                transition: background 0.3s ease;
                cursor: pointer;
                border: none;
                border-radius: 30px;
                box-shadow: 0 0 20px rgba(40, 125, 200, 0.5);
                position: relative;
                z-index: 1;
            }

                .upload-btn-wrapper .btn::before {
                    content: "";
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(255, 255, 255, 0.1);
                    z-index: -1;
                    border-radius: 30px;
                    transition: all 0.3s ease;
                }

                .upload-btn-wrapper .btn:hover::before {
                    background: rgba(255, 255, 255, 0.3);
                    transform: scale(1.1);
                }

            .upload-btn-wrapper input[type=file] {
                font-size: 100px;
                position: absolute;
                left: 0;
                top: 0;
                opacity: 0;
            }

        #cybereum-intro:hover {
            color: #FFEB3B; /* Bright yellow color on hover */
            transition: color 0.3s ease-in-out;
        }

        #drop-shadow {
            height: 130%;
        }

            #drop-shadow feGaussianBlur {
                stdDeviation: 2;
                result: "blur";
            }

            #drop-shadow feOffset {
                dx: 2;
                dy: 2;
                result: "offsetBlur";
            }

            #drop-shadow feMerge {
                feMergeNode: "";
                .upload-btn-wrapper

        {
            position: relative;
            overflow: hidden;
            display: inline-block;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }

        .upload-btn-wrapper:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px 3px #cdfaff;
        }

        .upload-btn-wrapper input[type=file] {
            font-size: 100px;
            position: absolute;
            left: 0;
            top: 0;
            opacity: 0;
            cursor: pointer;
        }

        .btn {
            border: 2px solid #cdfaff;
            color: #cdfaff;
            background-color: transparent;
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease-in-out;
        }

            .btn:hover {
                background-color: rgba(205, 250, 255, 0.2);
            }


        a {
            color: #58a6ff;
            text-decoration: none;
        }

            a:hover {
                text-decoration: underline;
            }

        .custom-cursor {
            width: 20px;
            height: 20px;
            border: 2px solid #58a6ff;
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10000;
            mix-blend-mode: difference;
            transition: all 0.3s ease-out;
        }

        /* Parallax effect */
        .parallax-element {
            transition: transform 0.5s;
        }

        /* For the dropdown */
        #projectSectorDropdown {
            border: 2px solid #cdfaff;
            color: #cdfaff;
            background-color: transparent;
            padding: 8px 20px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s ease-in-out;
            width: 250px;
            margin-left: 10px;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            background: url('https://cdn.icon-icons.com/icons2/2699/PNG/512/white_down_icon_17046.png') no-repeat;
            background-position: 90% center;
            background-size: 20px;
        }

            #projectSectorDropdown:hover {
                background-color: rgba(205, 250, 255, 0.2);
            }
        .bar-chart-tooltip {
            position: absolute;
            padding: 8px;
            background-color: white;
            border: 1px solid #ccc;
            border-radius: 4px;
            pointer-events: none;
        }

        .sci-fi-card {
            background: linear-gradient(145deg, #0d2137, #1a3458); /* Gradient background */
            margin-bottom: 20px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4), 0 0 20px #5ac8fa; /* Glowing border effect */
            border: 1px solid #5ac8fa;
            border-radius: 10px;
            position: relative;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Sleek font */
        }

            .sci-fi-card .alarm-indicators {
                display: flex;
                justify-content: flex-end;
            }

            .sci-fi-card .card-icons {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-top: 10px;
            }

            .sci-fi-card .outlier-indicators {
                display: flex;
                align-items: center;
                justify-content: space-between;
                margin-top: 10px;
                font-size: 0.9em; /* A bit smaller than the main content */
            }

            /* Progress bar with a sci-fi look */
            .sci-fi-card .progress-bar {
                height: 10px;
                width: 100%;
                border: 1px solid #5ac8fa;
                border-radius: 5px;
                margin-top: 10px;
                background: linear-gradient(145deg, #0d2137, #5ac8fa);
                position: relative;
            }

                .sci-fi-card .progress-bar::before {
                    content: "";
                    height: 100%;
                    border-radius: 4px;
                    position: absolute;
                    top: 0;
                    left: 0;
                    background: #5ac8fa;
                    box-shadow: 0 0 10px #5ac8fa;
                    transition: width 0.3s;
                }

            .sci-fi-card.futuristic-list {
                list-style-type: none;
                padding-left: 0;
            }

                .sci-fi-card.futuristic-list li {
                    position: relative;
                    margin-bottom: 10px;
                    padding-left: 20px;
                }

                    .sci-fi-card.futuristic-list li:before {
                        content: '•';
                        position: absolute;
                        left: 0;
                        top: 0;
                        color: #5ac8fa; /* Glowing bullet points */
                        text-shadow: 0 0 5px #5ac8fa;
                    }

                    .sci-fi-card.futuristic-list li:hover {
                        color: #5ac8fa; /* Hover effect */
                        text-shadow: 0 0 5px #5ac8fa;
                    }


    </style>
    <script type="text/javascript">
        google.charts.load('current', { 'packages': ['gantt'] });
        google.charts.setOnLoadCallback(initFileInput);

        function initFileInput() {
            var fileInput = document.getElementById('xmlFileInput');
            fileInput.addEventListener('change', handleFileSelect, false);
        }

        function clearPreviousData() {
            // Clear the data table
            document.getElementById('data_div').innerHTML = '';

            // Clear Graphs and Charts
            document.getElementById('graph-container').innerHTML = '<div id="tooltip" style="position: absolute; visibility: hidden; background: #8ce6ff; padding: 8px; border: 2px solid #3292cd; border-radius: 3px; "></div><svg><defs><marker id="arrow" viewBox="0 -6 10 12" refX="9" refY="0" markerWidth="6" markerHeight="10" orient="auto"><path d="M0,-5 L10,0 L0,5" fill="#cdfaff" /></marker><marker id="arrow2" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#0f0" /></marker></defs><g class="container"></g></svg>';
            document.getElementById('chart_div').innerHTML = '';
            document.getElementById('scurve_chart').innerHTML = '';
            document.getElementById('histogramChart').getContext('2d').clearRect(0, 0, 300, 280);  // Clearing canvas for histogram
            document.getElementById('pie_chart').innerHTML = '';
            document.getElementById('path_distribution_chart').innerHTML = '';
            document.getElementById('dependency_chart').innerHTML = '';

            // Clear Error Messages
            document.getElementById('error_div').innerText = '';

            // Clearing Control Values
            document.getElementById('searchInput').value = '';
            document.getElementById('highlightAllConnected').checked = false;
            document.getElementById('highlightCriticalPath').checked = false;
            document.getElementById('highlightOutliers').checked = false;

            // Reset sliders
            document.getElementById('zoomSlider').value = 50;
            document.getElementById('filterSlider').value = 0;
            document.getElementById('outDegreeFilterSlider').value = 0;
            document.getElementById('degreeFilterSlider').value = 0;

            // Clear Path Details
            document.getElementById('criticalPathDetails').innerText = 'Critical path details go here...';
            document.getElementById('outlierPathsDetails').innerText = 'Outlier paths details go here...';
            document.getElementById('allPathsDetails').innerText = 'All paths details go here...';
        }

        var nodes = [];
        var links = [];
        function clearGraphData() {
            nodes.length = 0;  // Clear the array without losing reference
            links.length = 0;
        }

        function handleFileSelect(event) {
            clearPreviousData();  // Clearing the DOM
            clearGraphData();     // Clearing the data structures
            var file = event.target.files[0];
            console.log("Selected file: ", file);
            if (file) {
                var reader = new FileReader();
                reader.onload = function (e) {
                    var contents = e.target.result;
                    var parser = new DOMParser();
                    var xmlDoc = parser.parseFromString(contents, "text/xml");
                    console.log("Parsed XML: ", xmlDoc);
                    drawChart(xmlDoc);
                };
                reader.readAsText(file);
            } else {
                console.error("Failed to load file");
            }
        }
        /**
         * Draws the data table.
         * @param {Object} data - The Google visualization DataTable.
         */
        function drawDataTable(data) {
            // Create the table and set its class.
            var table = document.createElement('table');
            table.className = 'dashboard-table';

            // Create the table header and body elements.
            var thead = document.createElement('thead');
            var tbody = document.createElement('tbody');

            // Add column names to the table header.
            var headerRow = document.createElement('tr');
            for (var i = 0; i < data.getNumberOfColumns(); i++) {
                var th = document.createElement('th');
                th.innerText = data.getColumnLabel(i);
                headerRow.appendChild(th);
            }
            thead.appendChild(headerRow);
            table.appendChild(thead);
            table.appendChild(tbody);

            // Clear previous contents of the data_div and append the new table.
            var dataDiv = document.getElementById('data_div');
            dataDiv.innerHTML = '';
            dataDiv.appendChild(table);

            // Use event delegation to handle cell editing.
            table.addEventListener('input', function (e) {
                if (e.target.tagName.toLowerCase() === 'td') {
                    var cell = e.target;
                    var newValue = cell.innerText;
                    var row = cell.parentNode.rowIndex - 1;
                    var col = cell.cellIndex;

                    // Validate the newValue based on its column
                    if (!validateCellValue(col, newValue)) {
                        // If invalid, revert the cell's value and show an error
                        cell.innerText = data.getFormattedValue(row, col);
                        displayError("Invalid input. Please try again.");
                        return;
                    }

                    // If valid, update the data model and redraw the charts
                    data.setCell(row, col, newValue);
                    var graphData = parseXML(xmlDocGlobal, data);
                    drawGanttChart(data);
                    drawGraph(graphData.nodes, graphData.links);
                }
            });

            function validateCellValue(col, value) {
                switch (col) {
                    case 0: // Task ID
                        return /^\d+$/.test(value);
                    case 3: // Start Date
                    case 4: // End Date
                        return !isNaN(new Date(value).getTime());
                    case 5: // Duration
                        return !isNaN(value) && parseFloat(value) >= 0;
                    case 6: // Percent Complete
                        var percent = parseFloat(value);
                        return !isNaN(percent) && percent >= 0 && percent <= 100;
                    case 7: // Dependencies
                        // Check if all dependencies are positive integers
                        return value.split(',').every(dep => /^\d+$/.test(dep.trim()));
                    default:
                        return true;
                }
            }

            function displayError(message) {
                // Assuming there's a <div> with id 'error-message' to display errors
                var errorDiv = document.getElementById('error_div');
                errorDiv.innerText = message;
                errorDiv.style.display = 'block';
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000); // Hide the error message after 5 seconds
            }

            var maxTaskDuration = 0;
            for (var i = 0; i < data.getNumberOfRows(); i++) {
                var taskDuration = data.getValue(i, data.getColumnIndex('Duration'));
                maxTaskDuration = Math.max(maxTaskDuration, taskDuration);
            }

            // Populate the table body with data from the Google DataTable.
            for (var i = 0; i < data.getNumberOfRows(); i++) {
                var dataRow = document.createElement('tr');
                for (var j = 0; j < data.getNumberOfColumns(); j++) {
                    var td = document.createElement('td');
                    if (j === data.getColumnIndex('Progress Bar')) {
                        var taskDuration = data.getValue(i, data.getColumnIndex('Duration'));
                        var barLengthPercentage = (taskDuration / maxTaskDuration) * 100;
                        td.innerHTML = `
                                                        <div class="progress-bar-container" style="width: 100%;">
                                                            <div class="progress-bar" style="width: ${barLengthPercentage}%;">
                                                                <div class="progress-bar-fill" style="width: 0%;"></div>
                                                            </div>
                                                        </div>`;
                    } else {
                        td.innerText = data.getFormattedValue(i, j);
                        td.contentEditable = 'true';
                    }
                    dataRow.appendChild(td);
                }
                tbody.appendChild(dataRow);
            }

            // Make the table sortable.
            sorttable.makeSortable(table);
        }

        function drawChart(xmlDoc) {
            console.log("Drawing chart with data: ", xmlDoc);
            var data = new google.visualization.DataTable();
            data.addColumn('string', 'Task ID');
            data.addColumn('string', 'Task Name');
            data.addColumn('string', 'Resource');
            data.addColumn('date', 'Start Date');
            data.addColumn('date', 'End Date');
            data.addColumn('number', 'Duration');
            data.addColumn('number', 'Percent Complete');
            data.addColumn('string', 'Dependencies');
            data.addColumn('number', 'Progress Bar');

            try {
                parseXML(xmlDoc, data);
                var dataJSON = data.toJSON();
                //document.getElementById('data_div').innerText = "DataTable in JSON format: \n" + dataJSON;
                drawDataTable(data);
                drawGanttChart(data);
                console.log('Nodes2')
                console.log("About to call drawGraph")

                var graphData = parseXML(xmlDoc, data);

                console.log('Nodes to the Charts', graphData.nodes)
                console.log('Links to the Charts', graphData.links)
                //drawCharts(graphData.nodes, graphData.links);
                console.log('Links to the Graph', graphData.links)
                drawGraph(graphData.nodes, graphData.links);
                // Now, call the chart functions with the parsed nodes and links

            } catch (err) {
                console.error("Error while parsing the XML data: ", err);
                document.getElementById('error_div').innerText = "Error: " + err.message;
            }
        }

        function insertStartMilestone(data, nodes, taskIDs, date) {
            if (!taskIDs['0']) {
                date.setHours(0, 0, 0, 0);
                data.addRow(['0', 'Start Milestone', '', date, date, 0, 100, null, null]);
                taskIDs['0'] = true;
                nodes.push({ ID: '0', Name: 'Start Milestone', Duration: '0', Start: date.toISOString(), Finish: date.toISOString() }); // Add the Start Node to the nodes array
            }
        }

        function insertEndMilestone(endMilestoneID, data, nodes, taskIDs, date, tasksWithoutSuccessors) {
            var milestoneID = endMilestoneID.toString();
            console.log('endMilestoneID: ', endMilestoneID)
            if (!taskIDs[milestoneID]) {
                date.setHours(23, 59, 59, 999);  // Set the time to the end of the day
                // Convert tasksWithoutSuccessors array to a comma-separated string to use as dependencies
                var dependencies = tasksWithoutSuccessors.join(", ");
                //data.addRow([milestoneID, 'End Milestone', '', date, date, 0, 0, null]);
                data.addRow([milestoneID, 'End Milestone', '', date, date, 0, 0, dependencies, null]);
                taskIDs[milestoneID] = true;
                //nodes.push({ ID: milestoneID, Name: 'End Milestone', Duration: '0'; Start: date.toISOString(), Finish: date.toISOString() }); // Add the End Node to the nodes array
            }
        }

        /**
         * Parses the XML to extract task data and dependencies.
         * @param {Object} xmlDoc - The XML document.
         * @param {Object} data - The Google visualization DataTable.
         */
        function parseXML(xmlDoc, data) {
            console.log("parseXML called");
            // Store the XML data for future use
            xmlDocGlobal = xmlDoc;
            var root = xmlDoc.documentElement;
            console.log("Root element: ", root.nodeName);

            var minStartDate = new Date(2100, 0, 1); // a future date
            var maxEndDate = new Date(1900, 0, 1);   // a past date

            var tasks = xmlDoc.getElementsByTagName("Task");
            console.log("Number of tasks: ", tasks.length);

            var taskIDs = {}; // To keep track of task IDs
            var taskUIDtoID = {}; // To map UIDs to IDs
            var idIncrementRequired = false; //if there is a Task IDs with '0' it coincides theh our start node and all IDs must be incremented
            var selfReferencingTasks = [];

            // Initialize nodes and links arrays for the graph
            console.log("Initialize nodes and links arrays for the graph")
            var nodes = [];
            var links = [];

            // Initialize dependencyGraph and checkedTasks
            var dependencyGraph = {};
            var checkedTasks = {};

            var minDate = null;  // To keep track of the minimum start date

            var parsedTasks = [];

            // First pass to extract task IDs and UIDs
            var tasksData = [];
            for (var i = 0; i < tasks.length; i++) {
                // Initialize tasksData array to store task details
                //var parsedTask = parseTask(tasks[i], data, taskUIDtoID, idIncrementRequired, selfReferencingTasks);

                //tasksData.push(parsedTask);
                var uidElement = tasks[i].getElementsByTagName("UID")[0];
                var idElement = tasks[i].getElementsByTagName("ID")[0];

                if (uidElement && idElement) {
                    var uid = uidElement.childNodes[0].nodeValue.trim();
                    var id = idElement.childNodes[0].nodeValue.trim();
                    taskUIDtoID[uid] = id;
                    if (id === '0') {
                        idIncrementRequired = true;
                    }
                }
            }
            console.log('Log the taskUIDtoID', taskUIDtoID); // Log the taskUIDtoID
            console.log('Log the taskUIDtoID'); // Log the taskUIDtoID

            if (idIncrementRequired) {
                for (var uid in taskUIDtoID) {
                    taskUIDtoID[uid] = (parseInt(taskUIDtoID[uid], 10) + 1).toString();
                }
            }

            // Find minimum date
            for (var i = 0; i < tasks.length; i++) {
                var startDateNode = tasks[i].getElementsByTagName("Start")[0];
                if (startDateNode) {
                    var startDateText = startDateNode.childNodes[0].nodeValue.trim();
                    var startDate = new Date(startDateText);  // Parse the date string
                    if (!minDate || startDate < minDate) {
                        minDate = startDate;
                    }
                }
            }

            insertStartMilestone(data, nodes, taskIDs, minDate); // Insert Start Milestone after finding the minimum date.

            //Determine the Maximum ID:
            var maxID = -1;
            for (var i = 0; i < tasks.length; i++) {
                var taskIDElement = tasks[i].getElementsByTagName("ID")[0];
                if (taskIDElement && taskIDElement.childNodes[0]) {
                    var taskID = parseInt(taskIDElement.childNodes[0].nodeValue.trim(), 10);
                    if (idIncrementRequired) {
                        taskID += 1;
                    }
                    maxID = Math.max(maxID, taskID);
                }
            }

            //Create the End Milestone:
            var endMilestoneID = maxID + 1;
            //nodes.push({ ID: endMilestoneID, Name: 'End Milestone', Start: 'someStartDate', Finish: 'someEndDate' });
            nodes.push({ ID: endMilestoneID, Name: 'End Milestone', Duration: '0', Start: maxEndDate, Finish: maxEndDate });
            //data.addRow([endMilestoneID, 'End Milestone', '', 'someStartDate', 'someEndDate', null, 100, null]);


            // Second pass to parse the tasks
            var successorCounts = {};
            for (var i = 0; i < tasks.length; i++) {
                var task = tasks[i];
                var parsedTask = parseTask(tasks[i], data, taskUIDtoID, idIncrementRequired, selfReferencingTasks, minDate, maxEndDate);
                parsedTasks.push(parsedTask);

                var taskID = parsedTask.taskID;
                var taskName = task.getElementsByTagName("Name")[0].childNodes[0].nodeValue.trim();
                var startDate = task.getElementsByTagName("Start")[0].childNodes[0].nodeValue.trim();
                var endDate = task.getElementsByTagName("Finish")[0].childNodes[0].nodeValue.trim();
                var duration = parsedTask.duration;

                // Update minStartDate and maxEndDate
                var parsedStartDate = new Date(startDate);
                var parsedEndDate = new Date(endDate);
                if (parsedStartDate < minStartDate) {
                    minStartDate = parsedStartDate;
                }
                if (parsedEndDate > maxEndDate) {
                    maxEndDate = parsedEndDate;
                }

                // Extracting "Percentage Complete" and "Time Units"
                var percentCompleteNode = task.getElementsByTagName("PercentComplete")[0];
                var percentComplete = percentCompleteNode ? percentCompleteNode.childNodes[0].nodeValue.trim() : "0";

                var timeUnitsNode = task.getElementsByTagName("TimeUnits")[0]; // Assuming the XML tag is "TimeUnits"
                var timeUnits = timeUnitsNode ? timeUnitsNode.childNodes[0].nodeValue.trim() : "Hours"; // Defaulting to "Hours" if not found

                // Add the task to the nodes array
                //nodes.push({ UID: taskID, Name: taskName, Start: startDate, Finish: endDate });
                nodes.push({
                    ID: taskID,
                    Name: taskName,
                    Duration: duration,
                    Start: startDate,
                    Finish: endDate,
                    PercentComplete: percentComplete,
                    TimeUnits: timeUnits
                });

                console.log('Nodes', nodes)

                taskIDs[taskID] = true;
                var dependenciesNodeList = tasks[i].getElementsByTagName("PredecessorLink");
                for (var j = 0; j < dependenciesNodeList.length; j++) {
                    var predecessorUIDNode = dependenciesNodeList[j].getElementsByTagName("PredecessorUID")[0];
                    if (predecessorUIDNode) {
                        var dependencyUID = predecessorUIDNode.childNodes[0].nodeValue.trim();
                        var dependency = taskUIDtoID[dependencyUID];
                        var dependencyID = taskUIDtoID[dependencyUID];
                        // Log the values being used
                        console.log("Dependency UID:", dependencyUID);
                        console.log("Mapped Dependency ID (source):", dependencyID);
                        console.log("Task ID (target):", taskID);
                        console.log("Task duration:", duration);
                        links.push({ source: dependencyID, target: taskID, duration: duration });
                        if (!(taskID in dependencyGraph)) {
                            dependencyGraph[taskID] = [];
                        }
                        dependencyGraph[taskID].push(dependency);
                    }
                }
                // Check if the task has no predecessors
                if (dependenciesNodeList.length === 0) {
                    // Link the task with no predecessors to the Start Milestone (ID 0)
                    links.push({ source: '0', target: taskID, duration: duration.toString() });
                }

                // Initialize successor counts
                successorCounts[taskID] = 0;

            }

            // Increment successor counts
            for (var i = 0; i < tasks.length; i++) {
                //var task = tasks[i];
                //var parsedTask = parseTask(tasks[i], data, taskUIDtoID, idIncrementRequired, selfReferencingTasks);
                var taskID = parsedTask.taskID;
                var dependenciesNodeList = tasks[i].getElementsByTagName("PredecessorLink");
                for (var j = 0; j < dependenciesNodeList.length; j++) {
                    var predecessorUIDNode = dependenciesNodeList[j].getElementsByTagName("PredecessorUID")[0];
                    if (predecessorUIDNode) {
                        var dependencyUID = predecessorUIDNode.childNodes[0].nodeValue.trim();
                        var dependencyID = taskUIDtoID[dependencyUID];
                        // Increment successor count for each predecessor
                        successorCounts[dependencyID]++;
                    }
                }
            }

            // Connect Tasks Without Successors
            var tasksWithoutSuccessors = [];
            for (var taskID in successorCounts) {
                if (successorCounts[taskID] === 0) {
                    links.push({ source: taskID, target: endMilestoneID, duration: duration });
                    tasksWithoutSuccessors.push(taskID);
                }
            }

            console.log('Links', links);
            // Insert Start and End Milestones
            //insertStartMilestone(data, nodes, taskIDs, minStartDate);
            insertEndMilestone(endMilestoneID, data, nodes, taskIDs, maxEndDate, tasksWithoutSuccessors);

            // Third pass to check for invalid dependencies
            for (var i = 0; i < tasks.length; i++) {
                checkDependencies(tasks[i], taskIDs, taskUIDtoID, dependencyGraph);
            }

            // After constructing the entire dependency graph
            try {
                checkCycles(dependencyGraph);
            } catch (error) {
                console.error(error);
            }


            if (selfReferencingTasks.length > 0) {
                var warningMessage = "Self-referencing tasks found with IDs: " + selfReferencingTasks.join(", ");
                console.warn(warningMessage);
                document.getElementById('self-referencing-tasks-warning').innerText = warningMessage;
            }

            return { nodes: nodes, links: links, selfReferencingTasks: selfReferencingTasks, tasksData: tasksData };

        }


        function checkDependencies(task, taskIDs, taskUIDtoID, dependencyGraph) {
            var taskIDElement = task.getElementsByTagName("ID")[0];
            var taskID = taskIDElement.childNodes[0].nodeValue.trim();
            var dependencies = dependencyGraph[taskID] || [];
            for (var i = 0; i < dependencies.length; i++) {
                var dependency = dependencies[i];
                if (!taskIDs[dependency]) {
                    throw new Error("Invalid task dependency ID: " + dependency + " in task with ID: " + taskID);

                }
            }
        }

        function detectCycle(graph, startNode, visited, recursionStack) {
            visited[startNode] = true;
            recursionStack[startNode] = true;

            var neighbors = graph[startNode];
            if (neighbors) {
                for (var i = 0; i < neighbors.length; i++) {
                    var neighbor = neighbors[i];

                    if (!visited[neighbor]) {
                        if (detectCycle(graph, neighbor, visited, recursionStack)) {
                            return true;
                        }
                    } else if (recursionStack[neighbor]) {
                        // if the neighbor node is visited and it's in the recursion stack, then it's a cycle
                        return true;
                    }
                }
            }

            recursionStack[startNode] = false; // remove the node from the recursion stack before returning
            return false;
        }

        function checkCycles(graph) {
            var visited = {};
            var recursionStack = {};

            function detectCycle(graph, startNode) {
                visited[startNode] = true;
                recursionStack[startNode] = true;

                var neighbors = graph[startNode];
                if (neighbors) {
                    for (var i = 0; i < neighbors.length; i++) {
                        var neighbor = neighbors[i];

                        if (!visited[neighbor]) {
                            if (detectCycle(graph, neighbor)) {
                                return true;
                            }
                        } else if (recursionStack[neighbor]) {
                            // if the neighbor node is visited and it's in the recursion stack, then it's a cycle
                            console.error("Cycle detected involving tasks with IDs: " + startNode + " and " + neighbor);
                            // Removing the cycle-causing dependency:
                            var index = graph[startNode].indexOf(neighbor);
                            if (index > -1) {
                                graph[startNode].splice(index, 1);
                            }
                            return false; // Remove the cycle but continue checking
                        }
                    }
                }

                recursionStack[startNode] = false; // remove the node from the recursion stack before returning
                return false;
            }

            for (var node in graph) {
                if (!visited[node]) {
                    detectCycle(graph, node);
                }
            }
        }

        function parseTask(task, data, taskUIDtoID, idIncrementRequired, selfReferencingTasks, minDate, maxEndDate) {
            console.log("parseTask called");

            // Extract the data from the XML task element, with checks for missing elements

            var taskIDElement = task.getElementsByTagName("ID")[0];
            var taskNameElement = task.getElementsByTagName("Name")[0];
            var startDateElement = task.getElementsByTagName("Start")[0];
            var endDateElement = task.getElementsByTagName("Finish")[0];
            var durationElement = task.getElementsByTagName("Duration")[0];

            if (!taskIDElement || !taskNameElement || !startDateElement || !endDateElement || !durationElement) {
                throw new Error("Task element missing one or more expected child elements");
            }

            var taskID = taskIDElement.childNodes[0].nodeValue.trim();
            if (idIncrementRequired) {
                taskID = String(Number(taskID) + 1);
            }
            console.log("Task ID: ", taskID);


            var taskName = taskNameElement.childNodes[0].nodeValue.trim();
            console.log("Task Name: ", taskName);

            var startDateString = startDateElement.childNodes[0].nodeValue.trim();
            console.log("Start Date: ", startDateString);

            var endDateString = endDateElement.childNodes[0].nodeValue.trim();
            console.log("End Date: ", endDateString);

            var durationString = durationElement.childNodes[0].nodeValue.trim();
            console.log("Duration: ", durationString);

            // If PercentComplete element is missing, set it to "0"
            var percentCompleteElement = task.getElementsByTagName("PercentComplete")[0];
            var percentCompleteString = percentCompleteElement ? percentCompleteElement.childNodes[0].nodeValue.trim() : "0";
            console.log("Percent Complete: ", percentCompleteString);

            // When parsing dependencies, convert PredecessorUID into the corresponding ID
            var dependenciesNodeList = task.getElementsByTagName("PredecessorLink");
            var dependencies = [];

            for (var i = 0; i < dependenciesNodeList.length; i++) {
                var predecessorUIDNode = dependenciesNodeList[i].getElementsByTagName("PredecessorUID")[0];

                if (predecessorUIDNode) {
                    var uid = predecessorUIDNode.childNodes[0].nodeValue.trim();
                    if (taskUIDtoID[uid]) {
                        dependencies.push(taskUIDtoID[uid]);
                    }
                }
            }

            var dependenciesString = dependencies.length > 0 ? dependencies.join(",") : "None";
            console.log("Dependencies: ", dependenciesString);


            // Instead of throwing an error for invalid task ID, just log it and return
            if (isNaN(parseFloat(taskID))) {
                console.error("Invalid task ID value.");
                return;
            }

            // Validate date strings match expected format (yyyy-mm-dd or yyyy-mm-ddThh:mm:ss)
            var dateRegexShort = /^\d{4}-\d{2}-\d{2}$/;
            var dateRegexLong = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/;
            if (startDateString.length === 10 && !dateRegexShort.test(startDateString) ||
                startDateString.length === 19 && !dateRegexLong.test(startDateString) ||
                endDateString.length === 10 && !dateRegexShort.test(endDateString) ||
                endDateString.length === 19 && !dateRegexLong.test(endDateString)) {
                throw new Error("Invalid date format in task with ID: " + taskID);

            }

            // Create dates from strings, and add error checking.
            var startDate = new Date(startDateString);
            var endDate = new Date(endDateString);

            // Check if dates are valid
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                console.error("Invalid task date format for taskID: " + taskID);
                return;
            }

            // Remove time portion of date if exists
            if (startDateString.length === 19) {
                startDate.setHours(0, 0, 0, 0);
            }
            if (endDateString.length === 19) {
                endDate.setHours(0, 0, 0, 0);
            }

            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                throw new Error("Invalid task date format.");
            }

            // Handle invalid duration values
            var duration;
            if (durationString.startsWith('PT')) {
                // Parse ISO 8601 duration format (PTxxHxxMxxS)
                var match = durationString.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
                var hours = match[1] ? parseInt(match[1].slice(0, -1)) : 0;
                var minutes = match[2] ? parseInt(match[2].slice(0, -1)) : 0;
                var seconds = match[3] ? parseInt(match[3].slice(0, -1)) : 0;
                duration = hours + minutes / 60 + seconds / 3600;
            } else {
                duration = parseFloat(durationString);
            }
            if (isNaN(duration) || duration < 0) {
                console.error("Invalid task duration value for task with ID: " + taskID);
                return;
            }

            // Validate percent complete value, and handle invalid values.
            var percentComplete = parseFloat(percentCompleteString);
            if (isNaN(percentComplete) || percentComplete < 0 || percentComplete > 100) {
                console.error("Invalid task percent complete value for task with ID: " + taskID);
                return;
            }

            // Check the validity of dependency IDs and handle invalid values
            for (var i = 0; i < dependencies.length; i++) {
                if (isNaN(parseFloat(dependencies[i]))) {
                    throw new Error("Invalid task dependencies format.");
                }
            }

            // Handle empty/missing dependency values
            if (dependencies.length === 0) {
                dependenciesString = "0";  // Here the startMilestoneID should be "0";
            } else {
                // Adjust dependencies array based on the incremented task IDs
                dependencies = dependencies.map(dependency => {
                    if (dependency === "0") {
                        return "1";
                    } else {
                        //return String(parseInt(dependency) + 1);
                        return String(parseInt(dependency) + 0);
                    }
                });

                // Convert dependencies array to a string with comma separated values
                dependenciesString = dependencies.join(",");
            }

            // Handle empty/missing dependency values and self-referencing tasks
            var hasOtherDependencies = false;
            for (var i = 0; i < dependencies.length; i++) {
                if (dependencies[i] === taskID) {
                    console.warn("Task with ID: " + taskID + " has itself as a dependency. Removing the self-referencing dependency.");
                    selfReferencingTasks.push(taskID);
                } else {
                    hasOtherDependencies = true;
                }
            }
            if (dependencies.length === 0 || (!hasOtherDependencies && dependencies.includes(taskID))) {
                dependenciesString = "0";  // Default to the startMilestoneID if no valid dependencies
            } else {
                dependenciesString = dependencies.join(",");
            }

            // Add parsed task data to the DataTable.
            //console.log("Row: ", taskID, taskName, '', startDate, endDate, duration, percentComplete, dependenciesString);
            var maxEndDateObj = new Date(maxEndDate);
            var minDateObj = new Date(minDate);
            var endDateObj = new Date(endDate);
            var startDateObj = new Date(startDate);

            var totalDuration = (maxEndDateObj - minDateObj) / (1000 * 60 * 60 * 24);
            var taskDuration = (endDateObj - startDateObj) / (1000 * 60 * 60 * 24);

            var barWidthPercentage = totalDuration !== 0 ? (taskDuration / totalDuration) * 100 : 0;

            var progressBar = '<div class="progress-bar-container"><div class="progress-bar" style="width: ' + barWidthPercentage + '%;"></div></div>';

            //data.addRow([taskID, taskName, resource, taskStartDate, taskEndDate, taskDuration, percentComplete, dependencies, progressBar]);
            try {
                data.addRow([taskID, taskName, '', startDate, endDate, duration, percentComplete, dependenciesString, barWidthPercentage]);

            } catch (err) {
                console.error("Error adding row to DataTable for taskID: " + taskID);
                console.error(err.message);
                return;
            }

            return {
                taskID: taskID,
                duration: duration,
                taskName: taskName,
                startDate: startDate,
                endDate: endDate
            };
            // Return the task ID

        }
        function drawGanttChart(data) {
            console.log("drawGanttChart called");
            try {
                var numRows = data.getNumberOfRows();
                var height = numRows * 30 + 80;
                var options = {
                    height: height,
                    backgroundColor: '#cdfaff',
                    gantt: {
                        trackHeight: 30,
                        barCornerRadius: 5,
                        criticalPathEnabled: true,
                        criticalPathStyle: {
                            stroke: '#1e69aa',
                            strokeWidth: 2
                        },
                        labelStyle: {
                            fontName: 'Orbitron',  // Futuristic font
                            fontSize: 14,
                            color: '#113464' // Dark blue text
                        },
                        barHeight: 25,
                        percentEnabled: false,
                        shadowEnabled: true,
                        arrow: {
                            angle: 90,  // Make links less curvy
                            width: 2,
                            color: '#195a8c',
                            length: 10
                        },
                        defaultStartDate: null,
                        palette: [
                            {
                                color: {
                                    linearGradient: { x0: 0, y0: 0, x1: 0, y1: 1 },
                                    colorStops: [{ offset: 0, color: '#3292cd' }, { offset: 1, color: '#287dc8' }]
                                },
                                dark: '#113464',
                                stroke: '#195a8c',
                                strokeWidth: 2
                            }
                        ],
                        gridlines: {
                            color: '#3292cd'
                        },
                        minorGridlines: {
                            color: '#287dc8',
                            count: 15
                        },
                        labelMaxWidth: 300, // Increase if labels are long
                        labelTextStyle: {
                            fontName: 'Orbitron',
                            fontSize: 14,
                            color: '#113464'
                        },
                        tooltip: {
                            isHtml: true
                        }
                    },
                    chartArea: {
                        backgroundColor: '#cdfaff'
                    },
                    hAxis: {
                        textStyle: {
                            fontName: 'Orbitron',
                            color: '#1e69aa'
                        },
                        gridlines: {
                            color: '#287dc8'
                        }
                    },
                    vAxis: {
                        textStyle: {
                            fontName: 'Orbitron',
                            color: '#1e69aa'
                        }
                    }
                };
                var chart = new google.visualization.Gantt(document.getElementById('chart_div'));
                chart.draw(data, options);
            } catch (err) {
                console.error(err);
            }
        }
    // Completion of all computations and renderings
    updateProgressBar(100);
    document.querySelector(".sci-fi-loading-text").innerText = "";
    </script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
        google.charts.load('current', { 'packages': ['corechart'] });
        google.charts.setOnLoadCallback(initializeDataAndDrawCharts);
        var currentRotation = 0;


        function drawGraph(nodes, links) {
            console.log("drawGraph has been called");
            console.log("drawGraph called: Nodes", nodes);
            console.log("drawGraph called: Links", links);

            // Find start and end nodes
            var startNode = nodes.find(node => node.ID === "0"); // Assuming ID is a string
            var endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);
            console.log("End Node: ", endNode);

            // Find all paths from startNode to endNode
            console.log("Links array:", links);
            console.log("Links from start node:", links.filter(link => link.source === startNode || link.target === startNode));
            var paths = findAllPaths(startNode, endNode, links, nodes);
            console.log("All paths:", paths);


            // Create the SVG container
            var svg = d3.select("svg"),
                container = d3.select(".container"),
                dashboardCard = document.querySelector(".dashboard-card"),
                width = dashboardCard.clientWidth,
                height = dashboardCard.clientHeight;
            svg.attr("width", width).attr("height", height);


            console.log("SVG container: ", svg);
            console.log("Container: ", container);

            // Responsive Design
            window.addEventListener("resize", function () {
                var dashboardCard = document.querySelector(".dashboard-card");
                width = dashboardCard.clientWidth;
                height = dashboardCard.clientHeight;
                svg.attr("width", width).attr("height", height);
            });

            // Initialize in-degree to 0 for each node
            nodes.forEach(function (node) {
                node.inDegree = 0;
                node.outDegree = 0;  // New initialization for out-degree
            });


            // Calculate the in-degree for each node
            links.forEach(function (link) {
                var targetNode = nodes.find(function (node) { return node.ID === link.target; });
                targetNode.inDegree++;
            });

            // Calculate the out-degree for each node
            links.forEach(function (link) {
                var sourceNode = nodes.find(function (node) { return node.ID === link.source; });
                sourceNode.outDegree++;
            });

            // Calculate the degree for each node
            nodes.forEach(function (node) {
                node.degree = node.inDegree + node.outDegree;
            });

            // Filtering
            function updateNodeVisibility() {
                var inDegreeThreshold = parseInt(document.getElementById("filterSlider").value);
                var outDegreeThreshold = parseInt(document.getElementById("outDegreeFilterSlider").value);
                var degreeThreshold = parseInt(document.getElementById("degreeFilterSlider").value);

                node.style("visibility", function (d) {
                    return (d.inDegree >= inDegreeThreshold && d.outDegree >= outDegreeThreshold && d.degree >= degreeThreshold) ? "visible" : "hidden";
                });
            }

            var filterSlider = document.getElementById("filterSlider");
            var filterValue = document.getElementById("filterValue");

            filterSlider.addEventListener("input", function () {
                var threshold = parseInt(this.value);
                filterValue.innerHTML = "> " + threshold;
                updateNodeVisibility(); // Use the unified function here
            });
            var outDegreeFilterSlider = document.getElementById("outDegreeFilterSlider");
            var outDegreeFilterValue = document.getElementById("outDegreeFilterValue");

            // Out-degree filter
            outDegreeFilterSlider.addEventListener("input", function () {
                var threshold = parseInt(this.value);
                outDegreeFilterValue.innerHTML = "> " + threshold;
                updateNodeVisibility(); // And here
            });

            var degreeFilterSlider = document.getElementById("degreeFilterSlider");
            var degreeFilterValue = document.getElementById("degreeFilterValue");

            // Degree filter (corrected)
            degreeFilterSlider.addEventListener("input", function () {
                var threshold = parseInt(this.value);
                degreeFilterValue.innerHTML = "> " + threshold;
                updateNodeVisibility(); // And here
            });


            // Search Functionality
            document.getElementById("searchInput").addEventListener("input", function () {
                var query = this.value.toLowerCase();
                node.attr("stroke", function (d) {
                    return (d.Name.toLowerCase().includes(query) || d.ID === query) ? "red" : "none";
                });
            });

            window.rotate = function (angle) {
                currentRotation += angle;
                container.attr("transform", "rotate(" + currentRotation + "," + (width / 2) + "," + (height / 2) + ")");
            };


            // Zoom and pan behavior
            var zoom = d3.zoom().scaleExtent([0.1, 4])
                .translateExtent([[-width, -height], [2 * width, 3 * height]])
                .on("zoom", function () { container.attr("transform", d3.event.transform); });
            svg.call(zoom); // Change container to svg

            // Define zoom functions inside drawGraph
            window.zoomIn = function () {
                zoom.scaleBy(svg.transition().duration(750), 1.2);
            }

            window.zoomOut = function () {
                zoom.scaleBy(svg.transition().duration(750), 0.8);
            }

            window.pan = function (dx, dy) {
                var currentTransform = d3.zoomTransform(svg.node());
                var newX = currentTransform.x + dx;
                var newY = currentTransform.y + dy;

                zoom.transform(svg.transition().duration(750), d3.zoomIdentity.translate(newX, newY));
            };

            window.center = function () {
                let x = width / 2;
                let y = height / 2;
                zoom.translateTo(svg.transition().duration(750), x, y);
            }


            // Create the tooltip element
            var tooltip = d3.select("#graph-container").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            // Simulation setup
            var simulation = d3.forceSimulation(nodes)
                //.force("link", d3.forceLink(links).id(function (d) { return d.UID; })) //UID instead of ID
                //.force("link", d3.forceLink(links).id(function (d) { return d.ID; })) //ID instead of UID
                .force("link", d3.forceLink(links)
                    .id(function (d) { return d.ID; }) //ID instead of UID
                    .distance(function (d) { return d.duration; })) // Using 'duration' property for distance
                .force("charge", d3.forceManyBody().strength(-400))
                .force("center", d3.forceCenter(width / 2, height / 2));

            // Draw links (edges) with arrows
            var link = container.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("class", "link")
                .attr("stroke-width", 2)
                .attr("marker-end", "url(#arrow)");


            console.log("Link: ", link);

            link.on("mouseover", function (d) {
                // Highlight the link
                d3.select(this)
                    .style("stroke", "white")
                    .attr("stroke-width", 5);

                // Highlight the target node
                node.filter(n => n.ID === d.target.ID)
                    .select("circle")
                    .style("fill", "#113464");

                // Show tooltip with duration
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html("Duration: " + d.duration)
                    .style("left", (d3.event.pageX + 10) + "px")
                    .style("top", (d3.event.pageY - 28) + "px");
            })
                .on("mouseout", function (d) {
                    // Restore the link color
                    d3.select(this)
                        .style("stroke", "#cdfaff")
                        .attr("stroke-width", 2);

                    // Restore the target node color
                    node.filter(n => n.ID === d.target.ID)
                        .select("circle")
                        .style("fill", function (d) {
                            switch (true) {
                                case d.inDegree > 4: return "#41afeb";
                                case d.inDegree > 3: return "#46b9fa";
                                case d.inDegree > 2: return "#5ac8fa";
                                case d.inDegree > 1: return "#8ce6ff";
                                default: return "#b4f5ff";
                            }
                        });

                    // Hide tooltip
                    tooltip.transition().duration(500).style("opacity", 0);
                });

            // Draw nodes
            var node = container.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .enter().append("g");

            // Append circles
            node.append("circle")
                .attr("class", "node")
                .style("stroke", "#1e69aa ")
                .attr("r", function (d) {
                    return 20 + d.inDegree * 0.5; // Base radius is 10, and each additional link increases the radius by 5
                })
                .attr("fill", function (d) {
                    switch (true) {
                        case d.inDegree > 4: return "#41afeb";
                        case d.inDegree > 3: return "#46b9fa";
                        case d.inDegree > 2: return "#5ac8fa";
                        case d.inDegree > 1: return "#8ce6ff";
                        default: return "#b4f5ff";
                    }
                })
                .on("mouseover", function (d) {
                    // Check if user wants to highlight all connected nodes
                    var highlightAllConnected = document.getElementById("highlightAllConnected").checked;
                    var highlightCriticalPath = document.getElementById("highlightCriticalPath").checked;
                    var highlightOutliers = document.getElementById("highlightOutliers").checked;

                    d3.select(this)
                        .interrupt()  // <-- interrupt any ongoing transitions
                        .transition()
                        .duration(200)
                        .attr("r", 50)
                        .style("stroke", "red")
                        .style("stroke-width", "2px")
                        .style("fill", "#0f0");

                    // Find the corresponding text element and modify its style
                    d3.select(this.parentNode) // go up to the group element (assuming your nodes and texts are wrapped inside a <g> element)
                        .select("text") // select the text element
                        .interrupt()  // <-- interrupt any ongoing transitions
                        .transition()
                        .duration(10)
                        .style("font-size", "2em") // increase font size
                        .style("fill", "red"); // change color to red

                    var paths = [];
                    if (highlightAllConnected) {
                        var pathsFromStart = findAllPaths(startNode, d, links, nodes);
                        var pathsToEnd = findAllPaths(d, endNode, links, nodes);
                        var paths = [];

                        pathsFromStart.forEach(pathFromStart => {
                            pathsToEnd.forEach(pathToEnd => {
                                paths.push(pathFromStart.concat(pathToEnd.slice(1))); // slice to avoid adding hovered node twice
                            });
                        });
                    }
                    console.log("d Node: ", d);
                    console.log("End Node: ", endNode);
                    console.log("All Paths: ", paths);

                    link.style("stroke", function (l) {
                        if (highlightAllConnected) {
                            return paths.some(path => {
                                // Convert path array of nodes to array of IDs for easier comparison
                                const pathIDs = path.map(node => node.ID); // <-- 'path' should be the parameter of this function
                                return pathIDs.includes(l.source.ID) && pathIDs.includes(l.target.ID);
                            }) ? "yellow" : null;
                        } else {
                            return (l.source === d || l.target === d) ? "yellow" : null;
                        }
                    }).attr("stroke-width", function (l) {
                        if (highlightAllConnected) {
                            return paths.some(path => {
                                // Convert path array of nodes to array of IDs for easier comparison
                                const pathIDs = path.map(node => node.ID); // <-- 'path' should be the parameter of this function
                                return pathIDs.includes(l.source.ID) && pathIDs.includes(l.target.ID);
                            }) ? 4 : 2;
                        } else {
                            return (l.source === d || l.target === d) ? 4 : 2;
                        }
                    });


                    node.select("circle")
                        .style("fill", function (n) {
                            var selectedMetric = document.querySelector('input[name="colorMetric"]:checked').value;
                            var metricValue;

                            switch (selectedMetric) {
                                case "inDegree":
                                    metricValue = n.inDegree;
                                    break;
                                case "outDegree":
                                    metricValue = n.outDegree;
                                    break;
                                case "degree":
                                    metricValue = n.degree;
                                    break;
                                default:
                                    metricValue = n.inDegree; // default to in-degree if something goes wrong
                            }

                            var baseColor;
                            switch (true) {
                                case metricValue > 4: baseColor = "#41afeb"; break;
                                case metricValue > 3: baseColor = "#46b9fa"; break;
                                case metricValue > 2: baseColor = "#5ac8fa"; break;
                                case metricValue > 1: baseColor = "#8ce6ff"; break;
                                default: baseColor = "#b4f5ff";
                            }

                            if (highlightAllConnected) {
                                return paths.some(path => path.includes(n)) ? "yellow" : baseColor;
                            } else {
                                return (n === d || links.some(l => (l.source === d && l.target === n) || (l.target === d && l.source === n))) ? "yellow" : baseColor;
                            }
                        })
                        .attr("r", function (n) {
                            if (highlightAllConnected) {
                                return paths.some(path => path.includes(n)) ? 30 : d3.select(this).attr("r");
                            } else {
                                return (n === d || links.some(l => (l.source === d && l.target === n) || (l.target === d && l.source === n))) ? 30 : d3.select(this).attr("r");
                            }
                        });


                    if (highlightCriticalPath) {
                        const criticalPath = findCriticalPath(paths, links);
                        highlightPath(criticalPath.path, 'red', link, node); // Highlight the critical path in red
                    }

                    if (highlightOutliers) {
                        const outlierPaths = findOutlierPaths(paths);
                        outlierPaths.forEach(outlierPath => {
                            highlightPath(outlierPath, 'orange', link, node); // Highlight outlier paths in orange
                        });
                        highlightPath(criticalPath, 'red', link, node); // Highlight the critical path in red
                    }

                    var tooltipEndX = d3.select("#graph-container").node().getBoundingClientRect().right - 10; // 10px offset from right
                    var tooltipEndY = d3.select("#graph-container").node().getBoundingClientRect().top + 10;  // 10px offset from top

                    tooltip.style("right", "10px")
                        .style("top", "10px");

                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html("<strong>ID:</strong> " + d.ID + "<br/>" +
                        "<strong>Name:</strong> " + d.Name + "<br/>" +
                        "<strong>Start:</strong> " + d.Start + "<br/>" +
                        "<strong>Finish:</strong> " + d.Finish)
                        .style("right", "10px")
                        .style("top", "10px");
                    //document.getElementById("infoPanel").innerHTML = "<strong>Name:</strong> " + d.Name + "<br/><strong>ID:</strong> " + d.ID + "<br/><strong>Start:</strong> " + d.Start + "<br/><strong>Finish:</strong> " + d.Finish + "<br/><strong>Duration:</strong> " + d.duration;

                    // Draw arrow from node to tooltip
                    //drawArrow(d, { x: tooltipEndX, y: tooltipEndY }, container);
                    /* container.append("circle")
                        .attr("cx", tooltipEndX)
                        .attr("cy", tooltipEndY)
                        .attr("r", 5)
                        .style("fill", "red");
                        */
                })
                .on("mouseout", function (d) {
                    d3.select(this)
                        .transition()
                        .duration(500)
                        .attr("r", 20 + d.inDegree * 0.5)
                        .style("fill", function () {
                            switch (true) {
                                case d.inDegree > 4: return "#41afeb";
                                case d.inDegree > 3: return "#46b9fa";
                                case d.inDegree > 2: return "#5ac8fa";
                                case d.inDegree > 1: return "#8ce6ff";
                                default: return "#b4f5ff";
                            }
                        })
                        .style("stroke", null) // Remove the stroke (border) added during mouseover
                        .style("stroke-width", "1px");;

                    // Restore text element's style
                    d3.select(this.parentNode)
                        .select("text")
                        .transition()
                        .duration(300)
                        .style("font-size", "12px")
                        .style("fill", "#113464");

                    // Restore link colors and width
                    link.style("stroke", null)
                        .attr("stroke-width", 2);

                    // Restore other nodes
                    node.select("circle")
                        .style("stroke", "#1e69aa ")
                        .style("fill", function (n) {
                            switch (true) {
                                case n.inDegree > 4: return "#41afeb";
                                case n.inDegree > 3: return "#46b9fa";
                                case n.inDegree > 2: return "#5ac8fa";
                                case n.inDegree > 1: return "#8ce6ff";
                                default: return "#b4f5ff";
                            }
                        })
                        .attr("r", function (n) {
                            return 20 + n.inDegree * 0.5;
                        });
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                    // Remove the arrow when the mouse leaves the node
                    removeArrow(container);
                })
                .on("click", function (d) {
                    alert("Task Details:\nName: " + d.Name + "\nID: " + d.ID + "\nStart: " + d.Start + "\nFinish: " + d.Finish);
                });

            // Append text labels
            node.append("text")
                .attr("dx", -15)
                .attr("dy", 5)
                .text(function (d) { return d.ID; })
                .style("fill", "#113464")
                .style("font-size", "14px");

            console.log("Node: ", node);

            node.transition()
                .duration(750)
                .style("fill", "blue");


            // Drag-and-Drop Editing
            var dragHandler = d3.drag()
                .on("start", function (d) {
                    d3.select(this).raise().classed("active", true);
                })
                .on("drag", function (d) {
                    d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
                    // Update links if necessary
                })
                .on("end", function (d) {
                    d3.select(this).classed("active", false);
                });

            dragHandler(node);


            // Simulation tick handler
            simulation.nodes(nodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(links);

            // Simulation tick handler
            function ticked() {
                link.attr("x1", function (d) { return d.source.x; })
                    .attr("y1", function (d) { return d.source.y; })
                    .attr("x2", function (d) {
                        var dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,
                            angle = Math.atan2(dy, dx),
                            radius = 20 + d.target.inDegree * 0.5; // Calculate the dynamic radius based on in-degree
                        return d.target.x - Math.cos(angle) * radius;
                    })
                    .attr("y2", function (d) {
                        var dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,
                            angle = Math.atan2(dy, dx),
                            radius = 20 + d.target.inDegree * 0.5; // Calculate the dynamic radius based on in-degree
                        return d.target.y - Math.sin(angle) * radius;
                    });

                node.attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });
            }
            document.getElementById("zoomSlider").addEventListener("input", function (e) {
                var zoomLevel = e.target.value / 100; // Adjust according to your needs

                zoom.scaleTo(svg.transition().duration(750), zoomLevel);
            });


            window.zoomExtents = function () {
                var xMin = d3.min(nodes, function (d) { return d.x; });
                var xMax = d3.max(nodes, function (d) { return d.x; });
                var yMin = d3.min(nodes, function (d) { return d.y; });
                var yMax = d3.max(nodes, function (d) { return d.y; });

                var xCenter = (xMin + xMax) / 2;
                var yCenter = (yMin + yMax) / 2;

                var scale = Math.min(width / (xMax - xMin), height / (yMax - yMin)) * 0.95; // 0.95 for padding
                var translate = [width / 2 - scale * xCenter, height / 2 - scale * yCenter];

                svg.transition().duration(750)
                    .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
            };

            document.getElementById("highlightCriticalPath").addEventListener("change", function () {
                if (this.checked) {
                    const criticalPathInfo = findCriticalPath(paths, links);
                    highlightPath(criticalPathInfo.path, 'darkred', link, node, criticalPathInfo.duration);
                    showTooltip(`Critical Path Length: ${criticalPathInfo.duration}`, 'darkred');
                    // Update criticalPathDetails div with the path details
                    document.getElementById('criticalPathDetails').textContent = `Critical Path Length: ${criticalPathInfo.duration}`;
                } else {
                    clearHighlights();
                    hideTooltip();
                }
            });

            document.getElementById("highlightOutliers").addEventListener("change", function () {
                if (this.checked) {
                    const outlierPathsInfo = findOutlierPaths(paths, links);
                    // Create a container to hold all the details content
                    let detailsContent = '';
                    // Create a container to hold all the tooltip content
                    let tooltipContent = '';

                    outlierPathsInfo.paths.forEach((outlierPath, index) => {
                        const color = d3.scaleLinear().domain([0, outlierPathsInfo.paths.length - 1]).range(['orange', 'darkred'])(index);

                        // Highlight the path and update the tooltip with the path duration
                        highlightPath(outlierPath, color, link, node, outlierPathsInfo.durations[index]);
                        // Add the path duration to the details content
                        detailsContent += `Outlier Path ${index + 1} Length: ${outlierPathsInfo.durations[index]} units<br>`;
                        // Add the path duration to the tooltip content
                        // Wrap each tooltip line in a span with the appropriate color
                        tooltipContent += `<span style="color:${color}">Outlier Path ${index + 1} Length: ${outlierPathsInfo.durations[index]} units</span><br>`;
                    });

                    const criticalPathInfo = findCriticalPath(paths, links);
                    highlightPath(criticalPathInfo.path, 'darkred', link, node, criticalPathInfo.duration);
                    //tooltipContent += `Critical Path Length: ${criticalPathInfo.duration} units`;
                    tooltipContent += `<span style="color:darkred">Critical Path Length: ${criticalPathInfo.duration} units</span>`;

                    // Display the combined tooltip content
                    showTooltip(tooltipContent, 'darkred');

                    // Update outlierPathsDetails div with the details content
                    document.getElementById('outlierPathsDetails').innerHTML = detailsContent;
                } else {
                    clearHighlights();
                    hideTooltip();
                }
            });
            tasks = nodes.map(node => ({
                ID: node.ID,
                Name: node.Name,
                Start: node.Start,
                Finish: node.Finish,
                duration: node.duration, // Assuming you have a 'duration' property on each node
            }));
            drawCharts(nodes, links);
        }

        function findAllPaths(startNode, endNode, links, nodes) {
            const neighborsMap = {};
            nodes.forEach(node => {
                neighborsMap[node.ID] = links
                    .filter(link => (link.source.ID || link.source) === node.ID)
                    .map(link => nodes.find(n => n.ID === (link.target.ID || link.target)));
            });

            const memo = {};  // for memoization
            let paths = [];

            function dfs(currentNode, currentPath, visited) {
                if (currentNode.ID === endNode.ID) {
                    paths.push([...currentPath]);
                    return;
                }

                if (memo[currentNode.ID]) {
                    paths = paths.concat(memo[currentNode.ID].map(subpath => currentPath.concat(subpath)));
                    return;
                }

                visited.add(currentNode.ID);
                let subpaths = [];
                for (let neighbor of neighborsMap[currentNode.ID]) {
                    if (!visited.has(neighbor.ID)) {
                        currentPath.push(neighbor);
                        dfs(neighbor, currentPath, visited);
                        currentPath.pop();
                    }
                }
                visited.delete(currentNode.ID);

                memo[currentNode.ID] = subpaths;
            }

            dfs(startNode, [startNode], new Set());

            return paths;
        }


        /*
        For all graphs including cyclic
            function findAllPaths(startNode, endNode, links, nodes) {
                console.log("Finding paths from", startNode, "to", endNode);
                let paths = [];
                let stack = [[startNode]];
                i = 0;
                console.log("i:", i);

                // Log details about links and nodes
                console.log("Links at the start:", JSON.stringify(links));
                console.log("Nodes at the start:", JSON.stringify(nodes));

                while (stack.length > 0) {
                    let path = stack.pop();
                    let lastNode = path[path.length - 1];

                    let neighbors = links
                        .filter(link => (link.source.ID || link.source) === lastNode.ID)
                        .map(link => nodes.find(node => node.ID === (link.target.ID || link.target)))
                        .filter(neighbor => !path.includes(neighbor));

                    console.log("Neighbors of", lastNode, ":", neighbors);

                    for (let neighbor of neighbors) {
                        let newPath = [...path, neighbor];
                        console.log("New Path:", JSON.stringify(newPath));  // Logging the new path

                        if (neighbor.ID === endNode.ID) {
                            // Convert newPath to string and check if it's already in paths
                            let newPathString = JSON.stringify(newPath.map(node => node.ID));
                            if (!paths.some(path => JSON.stringify(path.map(node => node.ID)) === newPathString)) {
                                paths.push(newPath);
                            }
                        } else {
                            stack.push(newPath);
                        }
                    }
                    i = i + 1
                    console.log("i++:", i);
                }

                console.log("All paths found:", paths);
                return paths;
            }
            */

        function calculateSlack(nodes, links) {
            if (!nodes || !links || nodes.length === 0 || links.length === 0) {
                console.error("Invalid or empty nodes or links provided.");
                return;
            }
            console.log("calculateSlack entered", nodes, links)

            nodes.forEach(node => {
                node.ES = -1;
                node.EF = -1;
                node.LS = -1;
                node.LF = -1;
            });

            var startNode = nodes.find(node => node.ID === "0");
            if (!startNode) {
                console.error("Start node (ID: 0) not found.");
                return;
            }
            startNode.ES = 0;
            startNode.EF = 0;

            var endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);
            console.log("calculateSlack start node", startNode)
            console.log("calculateSlack end node", endNode)

            let forwardPass = (node) => {
                let outgoingLinks = links.filter(link => link.source.ID === node.ID);
                for (let link of outgoingLinks) {
                    let successor = nodes.find(n => n.ID === link.target.ID);
                    if (!successor) {
                        console.warn(`Successor not found for node ID: ${node.ID}`);
                        continue;
                    }
                    if (isNaN(Number(successor.Duration))) {  // Corrected here
                        console.warn(`Invalid duration for node ID: ${successor.ID}`);
                        continue;
                    }
                    if (successor.ES === -1 || successor.ES < node.EF) {
                        successor.ES = node.EF;
                        successor.EF = successor.ES + Number(successor.Duration);  // And here
                    }
                    forwardPass(successor);
                }
            };
            forwardPass(startNode);

            if (!endNode || endNode.EF === -1) {
                console.error("End node not identified or has invalid EF.");
                return;
            }

            endNode.LF = endNode.EF;
            endNode.LS = endNode.LF;

            let backwardPass = (node) => {
                let incomingLinks = links.filter(link => link.target.ID === node.ID);
                for (let link of incomingLinks) {
                    let predecessor = nodes.find(n => n.ID === link.source.ID);
                    if (!predecessor) {
                        console.warn(`Predecessor not found for node ID: ${node.ID}`);
                        continue;
                    }
                    if (isNaN(Number(predecessor.Duration))) {  // Corrected here
                        console.warn(`Invalid duration for node ID: ${predecessor.ID}`);
                        continue;
                    }
                    if (predecessor.LF === -1 || predecessor.LF > node.LS) {
                        predecessor.LF = node.LS;
                        predecessor.LS = predecessor.LF - Number(predecessor.Duration);  // And here
                    }
                    backwardPass(predecessor);
                }
            };
            backwardPass(endNode);

            nodes.forEach(node => {
                node.ES = isNaN(node.ES) ? -1 : node.ES;
                node.EF = isNaN(node.EF) ? -1 : node.EF;
                node.LS = isNaN(node.LS) ? -1 : node.LS;
                node.LF = isNaN(node.LF) ? -1 : node.LF;
            });

            nodes.forEach(node => {
                node.slack = node.LS - node.ES;
            });

            let slackValues = {};
            nodes.forEach(node => {
                slackValues[node.ID] = node.slack;
            });
            console.log("slackValues", slackValues)
            return slackValues;
        }


        function computeEigenvectorCentrality(nodes, links, maxIterations) {
            console.log("Entered computeNetworkMetrics computeEigenvectorCentrality", nodes, links, maxIterations);
            let adjacencyMatrix = [];
            let eigenvectorValues = new Array(nodes.length).fill(1);

            nodes.forEach(node_i => {
                let row = [];
                nodes.forEach(node_j => {
                    row.push(links.some(link =>
                        (link.source.ID === node_i.ID && link.target.ID === node_j.ID) ||
                        (link.source.ID === node_j.ID && link.target.ID === node_i.ID)
                    ) ? 1 : 0);
                });
                adjacencyMatrix.push(row);
            });

            console.log("Entered computeNetworkMetrics EigenvectorCentrality1 Adjacency Matrix", adjacencyMatrix);

            for (let i = 0; i < maxIterations; i++) {
                console.log("Iteration:", i); // Added log
                let newEigenvectorValues = adjacencyMatrix.map((row, idx) => {
                    return row.reduce((sum, val, j) => sum + val * eigenvectorValues[j], 0);
                });

                let norm = Math.sqrt(newEigenvectorValues.reduce((sum, val) => sum + val * val, 0));
                console.log("Norm:", norm); // Added log
                if (norm === 0) {
                    console.error("Normalization error: Norm is zero.");
                    return;
                }
                eigenvectorValues = newEigenvectorValues.map(val => val / norm);
            }

            console.log("Entered computeNetworkMetrics EigenvectorCentrality2", eigenvectorValues);

            nodes.forEach((node, idx) => {
                node.eigenvectorCentrality = eigenvectorValues[idx];
            });
            console.log("Exiting computeNetworkMetrics computeEigenvectorCentrality", eigenvectorValues);
            return new Map(nodes.map((node, idx) => [node.ID, eigenvectorValues[idx]]));
        }


        //Betweenness Centrality
        function computeBetweennessCentrality(nodes, links) {
            console.log("Entered computeNetworkMetrics computeBetweennessCentrality", nodes, links);
            let betweenness = new Map();
            nodes.forEach(node => betweenness.set(node.ID, 0));

            for (let source of nodes) {
                let shortestPaths = new Map();
                nodes.forEach(node => shortestPaths.set(node.ID, []));
                shortestPaths.get(source.ID).push([source]);

                let queue = [source];
                let visited = new Set([source.ID]);

                while (queue.length) {
                    let current = queue.shift();
                    for (let link of links.filter(l => l.source.ID === current.ID)) {
                        if (!visited.has(link.target.ID)) {
                            visited.add(link.target.ID);
                            queue.push(nodes.find(n => n.ID === link.target.ID));
                        }
                        let newPath = shortestPaths.get(current.ID).map(path => [...path, nodes.find(n => n.ID === link.target.ID)]);
                        shortestPaths.get(link.target.ID).push(...newPath);
                    }
                }

                nodes.forEach(node => {
                    if (node !== source) {
                        let pathsThroughNode = 0;
                        let totalPaths = shortestPaths.get(node.ID).length;
                        shortestPaths.get(node.ID).forEach(path => {
                            if (path.some(p => p.ID === node.ID) && path[0].ID === source.ID && path[path.length - 1].ID !== source.ID) {
                                pathsThroughNode += 1;
                            }
                        });
                        if (totalPaths !== 0) {
                            betweenness.set(node.ID, betweenness.get(node.ID) + pathsThroughNode / totalPaths);
                        }
                    }
                });
            }

            // Normalize the betweenness values
            let maxBetweenness = Math.max(...betweenness.values());
            if (maxBetweenness !== 0) {
                nodes.forEach(node => {
                    betweenness.set(node.ID, betweenness.get(node.ID) / maxBetweenness);
                    node.betweenness = betweenness.get(node.ID);
                });
            }
            console.log("Exiting computeNetworkMetrics computeBetweennessCentrality2", betweenness);
            return betweenness;
        }

        ///Calculate Clustering Coefficient
        function computeClusteringCoefficient(nodes, links) {
            console.log("Entered computeNetworkMetrics computeClusteringCoefficient", nodes, links);
            let clusteringCoefficients = new Map();

            for (let node of nodes) {
                let neighbors = links.filter(link => link.source.ID === node.ID || link.target.ID === node.ID)
                    .map(link => link.source.ID === node.ID ? link.target.ID : link.source.ID);

                let neighborLinks = 0;
                for (let i = 0; i < neighbors.length; i++) {
                    for (let j = i + 1; j < neighbors.length; j++) {
                        if (links.some(link => (link.source.ID === neighbors[i] && link.target.ID === neighbors[j]) || (link.source.ID === neighbors[j] && link.target.ID === neighbors[i]))) {
                            neighborLinks++;
                        }
                    }
                }

                let totalPossibleLinks = neighbors.length * (neighbors.length - 1) / 2;
                //clusteringCoefficients.set(node.ID, totalPossibleLinks !== 0 ? neighborLinks / totalPossibleLinks : 0);
                clusteringCoefficients.set(node.ID, Math.min(Math.max(0, totalPossibleLinks !== 0 ? neighborLinks / totalPossibleLinks : 0), 1));
                node.clusteringCoefficient = clusteringCoefficients.get(node.ID);
            }
            console.log("Exit computeNetworkMetrics computeClusteringCoefficient", clusteringCoefficients);
            return clusteringCoefficients;
        }

        // Compute Network Density
        function computeNetworkDensity(nodes, links) {
            let totalPossibleLinks = nodes.length * (nodes.length - 1) / 2;
            return links.length / totalPossibleLinks;
        }

        async function computeNetworkMetrics(nodes, links, dampingFactor, maxIterations) {
            console.log("Entered computeNetworkMetrics");

            // Compute PageRank
            console.log("Entered computeNetworkMetrics1 ", nodes, links, dampingFactor, maxIterations);
            let pageRankValues = await computePageRank(nodes, links, dampingFactor, maxIterations);
            console.log("Entered computeNetworkMetrics2");
            // Compute Betweenness Centrality
            let betweennessValues = computeBetweennessCentrality(nodes, links);
            console.log("Entered computeNetworkMetrics3");
            // Compute Clustering Coefficient
            let clusteringCoefficientValues = computeClusteringCoefficient(nodes, links);
            console.log("Entered computeNetworkMetrics4");
            // Compute Eigenvector Centrality
            let eigenvectorCentralityValues = computeEigenvectorCentrality(nodes, links, maxIterations);
            console.log("Entered computeNetworkMetrics5");
            // Compute Network Density
            let networkDensityValue = computeNetworkDensity(nodes, links);
            console.log("Entered computeNetworkMetrics6");
            // Find start and end nodes
            var startNode = nodes.find(node => node.ID === "0"); // Assuming ID is a string
            var endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);

            // Find all paths from startNode to endNode
            var paths = findAllPaths(startNode, endNode, links, nodes);
            let criticalPathResult = findCriticalPath(paths, links);
            // Assuming you have paths and links available
            //const criticalPathData = findCriticalPath(paths, links);
            //const outlierPathsData = findOutlierPaths(paths, links);

            // Compute slacks for each node
            const nodeSlacks = calculateSlack(nodes, links);

            let criticalPath = criticalPathResult.path;  // Extract the path array
            let outlierPathsResult = findOutlierPaths(paths, links);
            let outlierPaths = outlierPathsResult.paths;  // Extract the paths array of arrays

            //populatePathsTable(criticalPathResult, outlierPathsResult);

            // Append metrics and labels to each node
            for (let node of nodes) {
                node.pageRank = pageRankValues.get(node.ID);
                node.betweenness = betweennessValues.get(node.ID);
                node.clusteringCoefficient = clusteringCoefficientValues.get(node.ID);
                node.eigenvectorCentrality = eigenvectorCentralityValues.get(node.ID);
                node.isOnCriticalPath = criticalPath.some(n => n.ID === node.ID); // Indicate if node is on critical path
                node.isOnOutlierPath = outlierPaths.some(path => path.includes(node));  // Indicate if node is on any outlier path
                // Append slack to the node
                node.slack = nodeSlacks[node.ID];
            }


            // Before the nodes.forEach loop, initialize arrays to collect raw values
            let taskInfluenceScores = [];
            let bufferRequirements = [];
            let flowDisruptionPotentials = [];
            let riskExposures = [];

            // Compute the scores for each node
            nodes.forEach(node => {
                // Extract metrics
                const CRITICAL_PATH_MULTIPLIER = 1.5;  // for nodes on the critical path
                const OUTLIER_PATH_MULTIPLIER = 1.25; // for nodes on the outlier paths
                const inDegree = node.inDegree;
                const outDegree = node.outDegree;
                const betweennessCentrality = node.betweenness;
                const pageRank = node.pageRank;
                // Duration will be taken from the link duration associated with the node,
                // but if not available, a default value of 1 will be taken.
                //const duration = links.find(link => link.source.ID === node.ID || link.target.ID === node.ID)?.duration || 1;
                const duration = node.Duration;
                console.log("computeNetworkMetrics Duration", node.ID)

                // Calculate raw metrics for each node
                const taskInfluenceScore = pageRank + betweennessCentrality;
                const bufferRequirement = 1 / (1 + Math.max(node.clusteringCoefficient, 0.001));
                const flowDisruptionPotential = 1 - node.clusteringCoefficient;
                const riskExposure = duration * betweennessCentrality;

                // Local normalization
                const normalize = (value, min, max) => {
                    if (max === min) {
                        console.warn("Normalization warning: max is equal to min for value:", value, ". Defaulting to 0.");
                        return 0;  // Default value
                    }
                    return (value - min) / (max - min);
                };

                const handleNaN = (value, metricName, nodeId) => {
                    if (isNaN(value)) {
                        console.warn(`Warning: ${metricName} is NaN for node: ${nodeId}. Defaulting to 0.`);
                        return 0; // Default value
                    }
                    return value;
                }

                const maxInDegree = Math.max(...nodes.map(n => n.inDegree));
                const minInDegree = Math.min(...nodes.map(n => n.inDegree));
                const inDegreeNorm = handleNaN(normalize(node.inDegree, minInDegree, maxInDegree), "inDegreeNorm", node.ID);

                const maxOutDegree = Math.max(...nodes.map(n => n.outDegree));
                const minOutDegree = Math.min(...nodes.map(n => n.outDegree));
                const outDegreeNorm = handleNaN(normalize(node.outDegree, minOutDegree, maxOutDegree), "outDegreeNorm", node.ID);

                const maxBetweenness = Math.max(...nodes.map(n => n.betweenness));
                const minBetweenness = Math.min(...nodes.map(n => n.betweenness));
                const betweennessCentralityNorm = handleNaN(normalize(node.betweenness, minBetweenness, maxBetweenness), "betweennessCentralityNorm", node.ID);

                const maxPageRank = Math.max(...nodes.map(n => n.pageRank));
                const minPageRank = Math.min(...nodes.map(n => n.pageRank));
                const pageRankNorm = handleNaN(normalize(node.pageRank, minPageRank, maxPageRank), "pageRankNorm", node.ID);

                const maxDuration = Math.max(...nodes.map(n => n.Duration));
                const minDuration = Math.min(...nodes.map(n => n.Duration));
                const durationNorm = normalize(node.Duration, minDuration, maxDuration);

                const maxClusteringCoefficient = Math.max(...nodes.map(n => n.clusteringCoefficient));
                const minClusteringCoefficient = Math.min(...nodes.map(n => n.clusteringCoefficient));
                const clusteringCoefficientNorm = normalize(node.clusteringCoefficient, minClusteringCoefficient, maxClusteringCoefficient);

                const minTaskInfluenceScore = Math.min(...taskInfluenceScores);
                const maxTaskInfluenceScore = Math.max(...taskInfluenceScores);
                const minBufferRequirement = Math.min(...bufferRequirements);
                const maxBufferRequirement = Math.max(...bufferRequirements);
                const minFlowDisruptionPotential = Math.min(...flowDisruptionPotentials);
                const maxFlowDisruptionPotential = Math.max(...flowDisruptionPotentials);
                const minRiskExposure = Math.min(...riskExposures);
                const maxRiskExposure = Math.max(...riskExposures);

                const taskInfluenceScoreNorm = normalize(taskInfluenceScore, minTaskInfluenceScore, maxTaskInfluenceScore);
                const bufferRequirementNorm = normalize(bufferRequirement, minBufferRequirement, maxBufferRequirement);
                const flowDisruptionPotentialNorm = normalize(flowDisruptionPotential, minFlowDisruptionPotential, maxFlowDisruptionPotential);
                //const riskExposureNorm = normalize(riskExposure, minRiskExposure, maxRiskExposure);
                const riskExposureNorm = handleNaN(normalize(riskExposure, minRiskExposure, maxRiskExposure), "riskExposureNorm", node.ID);


                const dependencyRatio = (inDegree + outDegree) !== 0 ? inDegree / (inDegree + outDegree) : 0;
                const maxDependencyRatio = Math.max(...nodes.map(n => {
                    const inD = n.inDegree;
                    const outD = n.outDegree;
                    return (inD + outD) !== 0 ? inD / (inD + outD) : 0;
                }));
                const minDependencyRatio = Math.min(...nodes.map(n => {
                    const inD = n.inDegree;
                    const outD = n.outDegree;
                    return (inD + outD) !== 0 ? inD / (inD + outD) : 0;
                }));
                const dependencyRatioNorm = normalize(dependencyRatio, minDependencyRatio, maxDependencyRatio);

                const bottleneckScore = (inDegree + outDegree) / (duration);
                const maxBottleneckScore = Math.max(...nodes.map(n => {
                    const dur = n.Duration !== 0 ? n.Duration : 1; // prevent division by zero
                    return (n.inDegree + n.outDegree) / dur;
                }));
                const minBottleneckScore = Math.min(...nodes.map(n => {
                    const dur = n.Duration !== 0 ? n.Duration : 1; // prevent division by zero
                    return (n.inDegree + n.outDegree) / dur;
                }));
                const bottleneckScoreNorm = normalize(bottleneckScore, minBottleneckScore, maxBottleneckScore);


                // Calculate other metrics
                //const riskExposure = duration * betweennessCentrality;
                const EPSILON = 0.001; // a small value to avoid division by zero or near-zero values
                const adjustedClusteringCoefficient = Math.max(node.clusteringCoefficient, -1 + EPSILON);

                // Compute Risk Score
                const riskScore = (0.15 * inDegreeNorm) +
                    (0.15 * outDegreeNorm) +
                    (0.25 * betweennessCentralityNorm) +
                    (0.1 * durationNorm) +
                    (0.15 * riskExposureNorm) +
                    (0.2 * pageRank);

                // Compute Importance Score
                //const taskInfluenceScore = pageRank + betweennessCentrality; // Simplified for the example
                //const bufferRequirement = 1 / (1 + adjustedClusteringCoefficient);
                //const flowDisruptionPotential = 1 - node.clusteringCoefficient; // A simplified approach

                const importanceScore = (0.15 * dependencyRatioNorm) +
                    (0.25 * taskInfluenceScore) +
                    (0.15 * bufferRequirement) +
                    (0.05 * flowDisruptionPotential) +
                    (0.15 * bottleneckScoreNorm) +
                    (0.2 * pageRank);
                console.log("computeNetworkMetrics Final Importance Score for node", node.ID, ":", importanceScore);

                // Adjust multipliers based on node's presence on critical or outlier paths
                let riskMultiplier = 1;
                let importanceMultiplier = 1;

                if (node.isOnCriticalPath && node.isOnOutlierPath) {
                    riskMultiplier = Math.max(CRITICAL_PATH_MULTIPLIER, OUTLIER_PATH_MULTIPLIER);
                    importanceMultiplier = CRITICAL_PATH_MULTIPLIER; // We only apply the critical path multiplier for importance
                } else if (node.isOnCriticalPath) {
                    riskMultiplier = CRITICAL_PATH_MULTIPLIER;
                    importanceMultiplier = CRITICAL_PATH_MULTIPLIER;
                } else if (node.isOnOutlierPath) {
                    riskMultiplier = OUTLIER_PATH_MULTIPLIER;
                }

                // Compute Risk and Importance Score with the adjusted multipliers
                node.riskScore = riskScore * riskMultiplier;
                node.importanceScore = importanceScore * importanceMultiplier;

                // Check if riskScore or importanceScore are NaN and set them to 0
                if (isNaN(node.riskScore)) {
                    console.error("NaN detected for riskScore on node:", node.ID);
                    node.riskScore = 0.0001;
                }
                if (isNaN(node.importanceScore)) {
                    console.error("NaN detected for importanceScore on node:", node.ID);
                    node.importanceScore = 0.0001;
                }
            });
            // Dummy totalProjectOverrunProbability
            const totalProjectOverrunProbability = 0.2;  // Example value
            // Call the function
            const updatedNodes = distributeOverrunProbability(nodes, links, totalProjectOverrunProbability);
            console.log("computeNetworkMetrics7, updatedNodes", nodes);

            console.log("Exiting computeNetworkMetrics nodes", nodes, networkDensityValue);

            // Return updated nodes and network density value
            return {
                updatedNodes: nodes,
                networkDensity: networkDensityValue
            };
        }

        function computePageRank(nodes, links, dampingFactor, maxIterations) {
            let pageRankValues = new Map();
            let newPageRankValues = new Map();

            for (let node of nodes) {
                pageRankValues.set(String(node.ID), 1 / nodes.length);
            }

            console.log("Initial PageRank values:", pageRankValues);

            for (let iteration = 1; iteration <= maxIterations; iteration++) {
                let totalDifference = 0;

                // Identify dangling nodes
                let danglingNodes = [...pageRankValues.keys()].filter(key =>
                    !links.some(link => key === String(link.source.ID) || key === String(link.target.ID))
                );
                console.log(`Number of Dangling Nodes: ${danglingNodes.length}`);

                for (let node of nodes) {
                    let nodeID = String(node.ID);
                    newPageRankValues.set(nodeID, (1 - dampingFactor) / nodes.length);

                    for (let link of links) {
                        if (nodeID === String(link.target.ID)) {
                            let outgoingLinks = links.filter(l => String(l.source.ID) === String(link.source.ID));
                            let totalWeight = outgoingLinks.reduce((acc, l) => acc + l.duration, 0);

                            // Diagnostic: Average Link Weight
                            let avgWeight = totalWeight / outgoingLinks.length;
                            console.log(`Average Link Weight for Node ${nodeID}: ${avgWeight}`);

                            newPageRankValues.set(nodeID, newPageRankValues.get(nodeID) + dampingFactor * (pageRankValues.get(String(link.source.ID)) * link.duration / totalWeight));
                        }
                    }
                }

                // Calculate total difference
                for (let [nodeID, value] of newPageRankValues) {
                    totalDifference += Math.abs(value - pageRankValues.get(nodeID));
                }

                console.log(`Total Difference for Iteration ${iteration}: ${totalDifference}`);

                // Swap the new values into the old PageRank values for the next iteration
                [pageRankValues, newPageRankValues] = [newPageRankValues, pageRankValues];
            }

            console.log("Final PageRank values:", pageRankValues);
            return pageRankValues;
        }


        function enhanceWeightsWithCriticalPathAndOutliers(links, criticalPathSet, outlierTasksSet, criticalPathMultiplier, outlierMultiplier) {
            for (let link of links) {
                if (criticalPathSet.has(link.source.ID)) {
                    link.duration *= criticalPathMultiplier;
                } else if (outlierTasksSet.has(link.source.ID)) {
                    link.duration *= outlierMultiplier;
                }
            }
        }

        function distributeOverrunProbability(nodes, links, totalProjectOverrunProbability) {
            console.log("distributeOverrunProbability: Entry");
            if (!nodes || !links) {
                console.error("distributeOverrunProbability: Missing nodes or links.");
                return;
            }

            nodes.forEach(node => {
                node.overrun_probability = 0;
                if (node.Duration <= 0) {
                    console.warn(`Node ID ${node.ID} has invalid Duration: ${node.Duration}. Setting to a default value of 1.`);
                    node.Duration = 1; // Set to a default value of 1 or any other suitable value
                }
            });

            const startNode = nodes.find(node => node.ID === "0");
            const endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);

            console.log("distributeOverrunProbability: Initial Nodes:", nodes);
            let allPaths = findAllPaths(startNode, endNode, links, nodes);
            console.log("distributeOverrunProbability: All Paths:", allPaths);

            let criticalPathInfo = findCriticalPath(allPaths, links);
            console.log("distributeOverrunProbability: Initial Critical Path Info:", criticalPathInfo);

            let targetDuration = criticalPathInfo.duration * (1 + totalProjectOverrunProbability);
            let currentLongestDuration = criticalPathInfo.duration;

            // Convergence and iteration control
            let iterationCount = 0;
            const MAX_ITERATIONS = 1000;
            const EPSILON = 1e-6;
            let previousDifference = Infinity;
            while (iterationCount < MAX_ITERATIONS) {
                allPaths.forEach(path => {
                    distributeOverrunForPath(path, nodes, links, totalProjectOverrunProbability);
                    const originalPathLength = path.reduce((sum, node) => sum + parseFloat(node.Duration), 0);
                    const adjustedPathLength = path.reduce((sum, node) => sum + parseFloat(node.Duration) * (1 + node.overrun_probability), 0);
                    console.log("distributeOverrunProbability: probalilityyyyyyyyyyyy", originalPathLength, adjustedPathLength);
                    path.forEach(node => {
                        console.log("distributeOverrunProbability: probalility", node.Duration, node.overrun_probability);
                    });
                    if (adjustedPathLength < originalPathLength) {
                        console.warn(`Adjusted path length ${adjustedPathLength} is less than original path length ${originalPathLength} for path:`, path);
                    }
                });

                let updatedCriticalPathInfo = findCriticalPath(allPaths, links);
                console.log("distributeOverrunProbability: Updated Critical Path Info:", updatedCriticalPathInfo);

                currentLongestDuration = updatedCriticalPathInfo.duration;

                let currentDifference = Math.abs(currentLongestDuration - targetDuration);
                if (currentDifference < EPSILON || Math.abs(currentDifference - previousDifference) < EPSILON) {
                    break;
                }

                previousDifference = currentDifference;
                iterationCount++;

                console.log("distributeOverrunProbability: Iteration:", iterationCount, "Current Longest Duration:", currentLongestDuration, "Target Duration:", targetDuration);
            }
            if (iterationCount >= MAX_ITERATIONS) {
                console.warn("Max iterations reached. Results might not be fully converged.");
            }

            allPaths.forEach(path => {
                const originalPathLength = path.reduce((sum, node) => sum + parseFloat(node.Duration), 0);
                const adjustedPathLength = path.reduce((sum, node) => sum + parseFloat(node.Duration) * (1 + node.overrun_probability), 0);

                console.log("distributeOverrunProbability: Path:", path, "Original Length:", originalPathLength, "Adjusted Length:", adjustedPathLength);

                if (adjustedPathLength < originalPathLength) {
                    console.warn(`Adjusted path length ${adjustedPathLength} is less than original path length ${originalPathLength} for path:`, path);
                }
            });

            return nodes;
        }


        function distributeOverrunForPath(path, nodes, links, totalProjectOverrunProbability) {
            let totalPathWeight = path.reduce((sum, node) => {
                let risk = parseFloat(node.riskScore);
                let importance = parseFloat(node.importanceScore);
                if (isNaN(risk) || isNaN(importance)) {
                    console.warn(`Node ID ${node.ID} has invalid risk or importance: ${node.riskScore}, ${node.importanceScore}`);
                    return sum;
                }
                return sum + (risk * importance);
            }, 0);

            if (totalPathWeight === 0) {
                console.warn("Total path weight is 0 for path:", path);
                return;
            }

            console.log("distributeOverrunProbability: Total Path Weight:", totalPathWeight);
            for (let node of path) {
                let risk = parseFloat(node.riskScore);
                let importance = parseFloat(node.importanceScore);
                let duration = parseFloat(node.Duration);

                if (isNaN(risk) || isNaN(importance) || isNaN(duration)) {
                    console.warn(`Node ID ${node.ID} has invalid values. Risk: ${node.riskScore}, Importance: ${node.importanceScore}, Duration: ${node.Duration}`);
                    node.overrun_probability = 0;
                    continue;
                }

                // Calculate node overrun probability ensuring it's never negative
                let nodeWeight = risk * importance;
                let probability = (nodeWeight / totalPathWeight) * totalProjectOverrunProbability;
                node.overrun_probability = Math.min(1, Math.max(0, probability));

                // Ensure the overrun probability is never such that the adjusted duration is less than the original duration
                const adjustedDuration = parseFloat(node.Duration) * (1 + node.overrun_probability);
                console.log("distributeOverrunProbability: Node:", node.ID, "Duration:", node.Duration, "Overrun Probability:", node.overrun_probability, "Adjusted Duration:", adjustedDuration);

                if (adjustedDuration < parseFloat(node.Duration)) {
                    node.overrun_probability = 0;
                    console.warn(`Adjusted duration ${adjustedDuration} is less than original duration ${node.Duration} for Node ID ${node.ID}. Setting overrun_probability to 0.`);
                }
                if (isNaN(node.overrun_probability) || !isFinite(node.overrun_probability)) {
                    console.warn(`Invalid overrun_probability for Node ID ${node.ID}. Setting to 0.`);
                    node.overrun_probability = 0;
                }
            }
        }

        function generatePathsTable(nodes, links) {
            // Assuming paths and links are available
            console.log("generatePathsTable", nodes, links)
            const startNode = nodes.find(node => node.ID === "0");
            const endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);
            const allPaths = findAllPaths(startNode, endNode, links, nodes);
            const criticalPathData = findCriticalPath(allPaths, links);
            const outlierPathsData = findOutlierPaths(allPaths, links);

            // Adjust duration based on time units
            function adjustDuration(duration, timeUnits) {
                switch (timeUnits) {
                    case 'Hours':
                        return duration / 8; // assuming 8-hour workdays
                    case 'Days':
                        return duration;
                    default:
                        return duration;
                }
            }
            // Adjust the duration of each node based on its time units
            nodes.forEach(node => {
                node.AdjustedDuration = adjustDuration(node.Duration, node.TimeUnits);
            });

            // Start generating table
            let tableHTML = '<table border="1">';

            // Table header
            tableHTML += '<tr>';
            tableHTML += '<th>Path Name</th>';
            tableHTML += '<th>Original Duration</th>';
            tableHTML += '<th>Risk Adjusted Duration</th>';

            const maxActivities = Math.max(criticalPathData.path.length, ...outlierPathsData.paths.map(p => p.length));
            for (let i = 1; i <= maxActivities; i++) {
                tableHTML += `<th>Activity ${i}</th>`;
            }

            tableHTML += '</tr>';

            // Critical path data row
            tableHTML += '<tr>';
            tableHTML += '<td>Critical Path</td>';
            tableHTML += `<td>${criticalPathData.duration}</td>`;
            tableHTML += `<td>${Math.round(calculateExpectedOverrunDurationForPath(criticalPathData.path))}</td>`;
            criticalPathData.path.forEach(node => {
                tableHTML += `<td style="color:red;">${node.ID}</td>`;
            });
            for (let i = criticalPathData.path.length; i < maxActivities; i++) {
                tableHTML += '<td style="color:#41afeb;">N/A</td>';
            }
            tableHTML += '</tr>';

            // Sort the outlier paths by their duration
            const sortedOutlierPaths = outlierPathsData.paths.map((path, index) => ({
                path,
                duration: outlierPathsData.durations[index]
            })).sort((a, b) => a.duration - b.duration);

            // Outlier paths data rows
            sortedOutlierPaths.forEach(({ path, duration }, index) => {
                // Scale the color based on index
                const color = d3.scaleLinear()
                    .domain([0, sortedOutlierPaths.length - 1])
                    .range(['orange', 'red'])(index);
                console.log("colorissue", color, duration, criticalPathData.duration);
                tableHTML += '<tr>';
                tableHTML += `<td>Outlier Path ${index + 1}</td>`;
                tableHTML += `<td>${duration}</td>`;
                tableHTML += `<td>${Math.round(calculateExpectedOverrunDurationForPath(path))}</td>`;
                path.forEach(node => {
                    tableHTML += `<td style="color:${color} !important;">${node.ID}</td>`;
                });
                for (let i = path.length; i < maxActivities; i++) {
                    tableHTML += '<td style="color:#41afeb;">N/A</td>';
                }
                tableHTML += '</tr>';
            });

            tableHTML += '</table>';

            // Calculate the longest risk-adjusted duration
            const longestRiskAdjustedDuration = sortedOutlierPaths.reduce((max, curr) => {
                return Math.max(max, Math.round(calculateExpectedOverrunDurationForPath(curr.path)));
            }, 0);

            // Create the bar chart
            function createBarChart() {
                // Retrieve the start date from the Start Milestone
                const startDate = new Date(nodes.find(node => node.ID === "0").Start);

                // Calculate the planned completion date
                const plannedCompletionDate = new Date(criticalPathData.path[criticalPathData.path.length - 1].Finish);

                // Calculate the probable end date
                const probableEndDate = new Date(startDate);
                probableEndDate.setDate(startDate.getDate() + Math.round(longestRiskAdjustedDuration));

                const data = [
                    {
                        label: 'Critical Path',
                        value: adjustDuration(criticalPathData.duration, 'Days'),
                        units: 'Days',
                        startDate: startDate,
                        endDate: plannedCompletionDate
                    },
                    {
                        label: 'Risk Adjusted',
                        value: adjustDuration(longestRiskAdjustedDuration, 'Days'),
                        units: 'Days',
                        startDate: startDate,
                        endDate: probableEndDate
                    }
                ];
                console.log(data);

                const margin = { top: 20, right: 50, bottom: 40, left: 100 }; // Adjusted the margins
                const width = 700 - margin.left - margin.right;  // Increased the width
                const height = 250 - margin.top - margin.bottom;

                const svg = d3.select("#progressBars").append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const x = d3.scaleLinear()
                    .domain([0, d3.max(data, d => d.value)])
                    .range([0, width]);

                const y = d3.scaleBand()
                    .domain(data.map(d => d.label))
                    .range([height, 0])
                    .padding(0.1);

                // Add tooltip
                const tooltip = d3.select("body").append("div")
                    .attr("class", "bar-chart-tooltip")
                    .style("opacity", 0);

                svg.selectAll(".bar")
                    .data(data)
                    .enter().append("rect")
                    .attr("class", "bar")
                    .attr("y", d => y(d.label))
                    .attr("height", y.bandwidth())
                    .attr("x", 0)
                    .attr("width", d => x(d.value))
                    .on("mouseover", (event, d) => {
                        console.log("Tooltip Data:", d); // Log data for debugging
                        tooltip.style("opacity", 0.9);   // Explicitly set opacity before transition
                        tooltip.transition()
                            .duration(200)
                            .style("opacity", 0.9);
                        tooltip.html(`Path: ${d.label}<br>Duration: ${d.value} ${d.units}<br>Start Date: ${d.startDate.toLocaleDateString()}<br>End Date: ${d.endDate.toLocaleDateString()}`)
                            .style("left", `${event.pageX + 5}px`)
                            .style("top", `${event.pageY - 70}px`);
                    })
                    .on("mouseout", () => {
                        tooltip.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });


                svg.append("g")
                    .call(d3.axisLeft(y));

                svg.append("g")
                    .attr("transform", `translate(0,${height})`)
                    .call(d3.axisBottom(x).ticks(10).tickFormat(d => `${d} Days`))
                    .append("text")
                    .attr("x", width / 2)
                    .attr("y", 30)
                    .attr("fill", "#000")
                    .attr("text-anchor", "middle")
                    .text("Duration (Days)");
            }

            // Call the createBarChart function to insert the chart
            createBarChart();

            // Insert the table into the DOM
            document.getElementById("pathsDistributionTableBody").innerHTML = tableHTML;

            // Make the table sortable
            makeTableSortable(document.getElementById("pathsDistributionTableBody").closest('table'));
        }

        function makeTableSortable(table) {
            // Simple function to sort table rows based on a column
            // This is a basic implementation and might need adjustments based on the table structure
            const headers = table.querySelectorAll('th');
            headers.forEach((header, idx) => {
                header.addEventListener('click', () => {
                    const sortedRows = Array.from(table.rows)
                        .slice(1)  // Skip the header row
                        .sort((rowA, rowB) => {
                            const cellA = rowA.cells[idx].textContent;
                            const cellB = rowB.cells[idx].textContent;
                            return cellA.localeCompare(cellB, undefined, { numeric: true });
                        });
                    table.tBodies[0].append(...sortedRows);
                });
            });
        }

        function calculateExpectedOverrunDurationForPath(path) {
            return path.reduce((sum, node) => {
                const adjustedDuration = node.Duration * (1 + node.overrun_probability);
                return sum + Math.max(adjustedDuration, node.Duration);
            }, 0);
        }

        function constructNetworkUsingPageRankWithDurationsCriticalPathAndOutliers(nodes, links) {
            const dampingFactor = 0.85;
            const convergenceThreshold = 1e-6;
            const maxIterations = 100;
            const criticalPathMultiplier = 2;
            const outlierMultiplier = 1.5;  // Adjust as needed

            let criticalPathSet = new Set(nodes.filter(node => node.isOnCriticalPath).map(node => node.ID));
            let outlierTasksSet = new Set(nodes.filter(node => node.isOnOutlierPath).map(node => node.ID));

            let pageRankValues = {};
            nodes.forEach(node => pageRankValues[node.ID] = 1 / nodes.length);

            // Adjust weighting based on whether a node is part of an outlier path
            for (let link of links) {
                if (outlierTasksSet.has(link.source.ID)) {
                    link.weight = link.weight ? link.weight * outlierMultiplier : outlierMultiplier;
                }
            }

            for (let i = 0; i < maxIterations; i++) {
                let newPageRankValues = {};
                for (let node of nodes) {
                    newPageRankValues[node.ID] = (1 - dampingFactor) / nodes.length;
                    for (let link of links) {
                        if (link.target === node.ID) {
                            let totalWeight = links.filter(l => l.source === link.source).reduce((acc, l) => acc + l.duration, 0);
                            let weight = link.duration;

                            if (criticalPathSet.has(link.source.ID)) {
                                weight *= criticalPathMultiplier;
                            } else if (outlierTasksSet.has(link.source.ID)) {
                                weight *= outlierMultiplier;
                            }

                            newPageRankValues[node.ID] += dampingFactor * (pageRankValues[link.source] * weight / totalWeight);
                        }
                    }
                }

                let diff = 0;
                for (let node of nodes) {
                    diff += Math.abs(newPageRankValues[node.ID] - pageRankValues[node.ID]);
                }
                if (diff < convergenceThreshold) {
                    break;
                }

                pageRankValues = newPageRankValues;
            }

            nodes.sort((a, b) => pageRankValues[b.ID] - pageRankValues[a.ID]);
            let topNodesCount = Math.floor(0.1 * nodes.length);
            let topNodes = nodes.slice(0, topNodesCount);

            // Ensure Start Milestone and End Milestone are present
            const startMilestone = nodes.find(node => node.ID === '0');
            const endMilestone = nodes.find(node => node.ID === nodes[nodes.length - 1].ID);

            if (!topNodes.includes(startMilestone)) {
                topNodes.push(startMilestone);
            }
            if (!topNodes.includes(endMilestone)) {
                topNodes.push(endMilestone);
            }

            // Ensure all nodes (except Start and End Milestone) have at least one predecessor and one successor
            let filteredLinks = links.filter(link => {
                if (link.source === startMilestone || link.target === endMilestone) return true;
                return links.some(l => l.target === link.source) && links.some(l => l.source === link.target);
            });

            let newLinks = links.filter(link => topNodes.includes(link.source) || topNodes.includes(link.target));
            let newNodes = [...new Set(newLinks.map(link => link.source).concat(newLinks.map(link => link.target)))];

            console.log("startMilestone: ", startMilestone, "endMilestone: ", endMilestone)

            console.log("The function constructNetworkUsingPageRankWithDurationsCriticalPathAndOutliers returns", "nodes1: ", newNodes, "links: ", newLinks, "criticalPathSet: ", criticalPathSet, "outlierTasksSet: ", outlierTasksSet)
            return {
                nodes: newNodes,
                links: newLinks,
                criticalPathSet: criticalPathSet,
                outlierTasksSet: outlierTasksSet
            };
        }

        function drawReducedGraphWithVis(nodes, links) {
            console.log("drawReducedGraphWithVis", "nodes: ", nodes, "links: ", links);

            const container = document.getElementById('dependency_chart');
            const configContainer = document.getElementById('configuration-container');


            // Side panel for node information
            const infoPanel = document.getElementById('info-panel');

            // Pan and Centering Controls
            const controlsDiv = document.createElement('div');
            controlsDiv.style.textAlign = 'center';
            controlsDiv.style.padding = '10px';
            controlsDiv.style.backgroundColor = '#f5f5f5'; // Light gray background for better visibility

            const btnLeft = document.createElement('button');
            btnLeft.textContent = '←';
            controlsDiv.appendChild(btnLeft);

            const btnUp = document.createElement('button');
            btnUp.textContent = '↑';
            controlsDiv.appendChild(btnUp);

            const btnDown = document.createElement('button');
            btnDown.textContent = '↓';
            controlsDiv.appendChild(btnDown);

            const btnRight = document.createElement('button');
            btnRight.textContent = '→';
            controlsDiv.appendChild(btnRight);

            const btnCenter = document.createElement('button');
            btnCenter.textContent = 'Center';
            controlsDiv.appendChild(btnCenter);

            container.appendChild(controlsDiv);

            const clusterByHubSizeButton = document.createElement('button');
            clusterByHubSizeButton.textContent = 'Cluster by Hub Size';
            controlsDiv.appendChild(clusterByHubSizeButton);

            const clusterByAttributeButton = document.createElement('button');
            clusterByAttributeButton.textContent = 'Cluster by Attribute';
            controlsDiv.appendChild(clusterByAttributeButton);

            const declusterButton = document.createElement('button');
            declusterButton.textContent = 'De-cluster';
            controlsDiv.appendChild(declusterButton);

            // Search functionality
            const searchInput = document.createElement('input');
            searchInput.setAttribute('placeholder', 'Search for a node...');
            searchInput.addEventListener('input', function () {
                const query = this.value;
                const nodeToFocus = nodes.find(node => node.ID === query || node.Name.includes(query));
                if (nodeToFocus) {
                    network.focus(nodeToFocus.ID, {
                        scale: 1.5,
                        animation: {
                            duration: 500,
                            easingFunction: "easeInOutQuad"
                        }
                    });
                }
            });
            container.appendChild(searchInput);

            console.log("drawReducedGraphWithVis2");

            // Modify nodes based on their degree
            nodes.forEach(node => {
                if (node.degree > 4) {
                    node.color = { background: 'red' };
                } else {
                    node.color = { background: 'blue' };
                }
            });

            // Modify edges based on their length
            links.forEach(edge => {
                edge.label = `Duration: ${edge.length / 20}`;
            });
            console.log("drawReducedGraphWithVis3");
            // Prepare the data
            const data = {
                nodes: new vis.DataSet(nodes.map(node => ({
                    id: node.ID,
                    label: node.ID,
                    title: `<strong>ID:</strong> ${node.ID}<br><strong>Name:</strong> ${node.Name}`,  // enhanced tooltip
                    value: node.degree, // use degree for node size
                    color: node.degree > 2 ? "#46b9fa" : "#8ce6ff",  // dynamic coloring based on degree
                    font: {
                        color: "#ffffff",
                        size: 24
                    }
                }))),
                edges: new vis.DataSet(links.map(link => ({
                    from: link.source.ID,  // use the ID attribute of the source node
                    to: link.target.ID,    // use the ID attribute of the target node
                    arrows: {
                        to: {
                            enabled: true,
                            scaleFactor: 1.5
                        }
                    },
                    color: {
                        color: "#a3d1ff",
                        opacity: 0.8,
                        inherit: 'from'
                    },
                    length: link.duration * 20,
                    hiddenLabel: `Duration: ${isNaN(link.duration) ? 0 : link.duration}`,
                    font: { color: 'transparent' }  // hide the label initially
                })))

            };
            console.log("drawReducedGraphWithVis4", data);
            // Configure the options
            const options = {
                nodes: {
                    shape: "circle",
                    borderWidth: 3,
                    borderWidthSelected: 5,
                    scaling: {
                        min: 20,
                        max: 100
                    },
                    chosen: {
                        node: function (values, id, selected, hovering) {
                            if (hovering) {
                                values.color = '#ffa3a3';  // Color when hovering over the node
                            } else if (selected) {
                                values.color = '#ff0000';  // Color when the node is selected
                            } else {
                                values.color = values.originalColor || "#5ac8fa";  // Default color
                            }
                        }
                    },
                },
                edges: {
                    width: 2.5,
                    smooth: {
                        type: "dynamic"
                    },
                    font: {
                        size: 12,
                        align: 'middle'
                    },
                    chosen: {
                        edge: function (values, id, selected, hovering) {
                            values.color = selected ? '#ff0000' : '#a3d1ff';
                            values.font.color = hovering ? '#000000' : 'transparent'; // Show label on hover
                        }
                    }
                },
                interaction: {
                    hover: true,
                    hoverConnectedEdges: true,
                    selectConnectedEdges: true
                },
                // Physics tweaking options
                physics: {
                    maxVelocity: 50,
                    minVelocity: 0.1,
                    solver: 'barnesHut',
                    barnesHut: {
                        gravitationalConstant: -3000,
                        centralGravity: 0.5
                    },
                    stabilization: {
                        iterations: 2500
                    }
                },
                configure: {
                    enabled: true,              // Enable or disable the panel
                    filter: true,               // The filter function or boolean to determine which options are shown
                    container: configContainer,       // The DOM element where the configuration UI will be created; if not provided, it will be next to the network.
                    showButton: true            // Show or hide the generate options button
                }
            };


            // Initialize the network
            const network = new vis.Network(container, data, options);

            // Cluster by hub size
            clusterByHubSizeButton.addEventListener('click', function () {
                network.clusterByHubsize(undefined, {
                    clusterNodeProperties: {
                        shape: 'box',
                        size: 30,
                        color: '#FF9999',
                        borderWidth: 3,
                        borderWidthSelected: 5,
                        label: 'Cluster'
                    }
                });
            });

            // Cluster by attribute (for this example, we're clustering nodes with similar degrees)
            clusterByAttributeButton.addEventListener('click', function () {
                const clusterOptionsByData = {
                    joinCondition: function (childOptions) {
                        return childOptions.degree > 2;
                    },
                    clusterNodeProperties: {
                        id: 'degreeCluster',
                        borderWidth: 3,
                        shape: 'star',
                        size: 40,
                        color: '#FFFF00',
                        label: 'Nodes with high degree'
                    }
                };
                network.cluster(clusterOptionsByData);
            });

            // De-cluster
            declusterButton.addEventListener('click', function () {
                network.openCluster('degreeCluster');
            });

            // Attach event listeners for the controls
            btnLeft.addEventListener('click', function () {
                const currentPosition = network.getViewPosition();
                network.moveTo({
                    position: { x: currentPosition.x + 100, y: currentPosition.y },
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            });

            btnUp.addEventListener('click', function () {
                const currentPosition = network.getViewPosition();
                network.moveTo({
                    position: { x: currentPosition.x, y: currentPosition.y + 100 },
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            });

            btnRight.addEventListener('click', function () {
                const currentPosition = network.getViewPosition();
                network.moveTo({
                    position: { x: currentPosition.x - 100, y: currentPosition.y },
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            });

            btnDown.addEventListener('click', function () {
                const currentPosition = network.getViewPosition();
                network.moveTo({
                    position: { x: currentPosition.x, y: currentPosition.y - 100 },
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            });

            btnCenter.addEventListener('click', function () {
                network.fit({
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            });

            // Focus on a node and its direct neighbors when the node is clicked
            network.on("click", function (properties) {
                const selectedNodeId = properties.nodes[0];
                if (selectedNodeId) {
                    const selectedNode = nodes.find(node => node.ID === selectedNodeId);
                    infoPanel.innerHTML = `
                    <h3>Node Details</h3>
                    <p><strong>ID:</strong> ${selectedNode.ID}</p>
                    <p><strong>Name:</strong> ${selectedNode.Name}</p>
                    <p><strong>Degree:</strong> ${selectedNode.degree}</p>
                `;
                } else {
                    infoPanel.innerHTML = '';
                }
            });
            // Node Dragging Enhancements
            network.on("dragEnd", function (params) {
                if (params.nodes.length) {
                    const draggedNode = data.nodes.get(params.nodes[0]);
                    draggedNode.fixed = {
                        x: true,
                        y: true
                    };
                    data.nodes.update(draggedNode);
                }
            });

            // List activities sorted by ID
            const sortedNodes = nodes.sort((a, b) => a.ID - b.ID);
            const activityList = document.createElement("ul");
            sortedNodes.forEach(node => {
                const listItem = document.createElement("li");
                listItem.textContent = node.ID + ": " + node.Name;
                activityList.appendChild(listItem);
            });

            // Append the list to the path-list container
            document.getElementById("path-list").appendChild(activityList);

            // Hover enhancements
            network.on("hoverNode", function (properties) {
                const hoveredNode = nodes.find(node => node.ID === properties.node);
                const tooltipContent = `
                <strong>ID:</strong> ${hoveredNode.ID}<br>
                <strong>Name:</strong> ${hoveredNode.Name}
            `;
                // Display this content in a tooltip. (Implementation depends on your tooltip library)
            });

            // Legend (this is a simple example, you'll want to make it more dynamic)
            const legend = document.createElement('div');
            legend.style.marginTop = "20px";
            legend.innerHTML = `
                    <strong>Legend:</strong><br>
                    <span style="display:inline-block; width:12px; height:12px; background-color:red;"></span> High Degree Node<br>
                    <span style="display:inline-block; width:12px; height:12px; background-color:blue;"></span> Low Degree Node<br>
                    <span style="display:inline-block; width:20px; height:2px; background-color:#a3d1ff;"></span> Link (Hover for duration)
                `;
            container.appendChild(legend);
        }

        function drawArrow(source, target, container) {
            var line = container.append("line")
                .attr("class", "hover-arrow")
                .attr("x1", source.x)
                .attr("y1", source.y)
                .attr("x2", target.x)
                .attr("y2", target.y)
                .attr("stroke", "#0f0") // Sci-fi green color
                .attr("stroke-width", 2)
                .attr("marker-end", "url(#arrow2)");
            return line;
        }

        function removeArrow(container) {
            container.selectAll(".hover-arrow").remove();
        }

        function correctCycle(links, cycleNode, startNode) {
            // Find the link involving the cycleNode and modify the source to the startNode (ID 0)
            let linkToModify = links.find(link => link.target === cycleNode);
            if (linkToModify) {
                linkToModify.source = startNode;
                console.log("Cycle corrected by setting the predecessor of node", cycleNode, "to the start node", startNode);
            } else {
                console.error("Could not correct the cycle for node", cycleNode);
            }
        }

        function displayPaths(paths, title, targetDivID) {
            // Generate the HTML content
            let htmlContent = `<h3>${title}</h3>`;
            paths.forEach((path, index) => {
                htmlContent += `<p>Path ${index + 1}:</p><ul>`;
                path.forEach(node => {
                    htmlContent += `<li>Node ID: ${node.ID}, Name: ${node.Name}</li>`;
                });
                htmlContent += '</ul>';
            });

            // Set the HTML content of the <div> element
            document.getElementById(targetDivID).innerHTML = htmlContent;
        }

        function findCriticalPath(paths, links) {
            let criticalPath = [];
            let maxDuration = 0;

            paths.forEach(path => {
                let pathDuration = 0;

                console.log(`Evaluating path: ${path.map(node => node.ID).join(" -> ")}`); // Debugging line to display current path

                for (let i = 0; i < path.length - 1; i++) {
                    let link = links.find(l => l.source === path[i] && l.target === path[i + 1]);
                    if (!link) {
                        console.warn(`No link found between ${path[i].ID} and ${path[i + 1].ID}`);  // Warning if link is not found
                        continue;
                    }

                    let linkDuration = Number(link.duration);  // Ensure the duration is a number
                    if (isNaN(linkDuration)) {
                        console.warn(`Invalid duration for link between ${link.source.ID} and ${link.target.ID}`);
                        continue;
                    }

                    pathDuration += linkDuration;

                    console.log(`Duration of link between ${link.source.ID} and ${link.target.ID}: ${linkDuration}`);  // Debugging line
                    console.log(`Cumulative path duration: ${pathDuration}`);  // Debugging line
                }

                if (pathDuration > maxDuration) {
                    maxDuration = pathDuration;
                    criticalPath = path;
                }
            });
            // Label nodes on the critical path
            criticalPath.forEach(node => {
                node.isOnCriticalPath = true;
            });
            console.log("Critical path:", criticalPath.map(node => node.ID).join(" -> "), "Max Duration: ", maxDuration); // Debugging line
            return { path: criticalPath, duration: maxDuration };
        }

        function findOutlierPaths(paths, links) {
            const MIN_OUTLIER_PATHS = 5;  // Adjust this as needed

            console.log("findOutlierPaths: Entry, Initial Paths:", paths, links);

            // Calculate the total duration for each path
            const pathDurations = paths.map(path => {
                return {
                    path,
                    duration: path.reduce((total, node, index, array) => {
                        if (index < array.length - 1) {
                            const link = links.find(l => l.source.ID === node.ID && l.target.ID === array[index + 1].ID);
                            return link ? total + Number(link.duration) : total;
                        }
                        return total;
                    }, 0)
                };
            });

            // Remove duplicate paths
            const uniquePathDurations = [];
            pathDurations.forEach(pathDuration => {
                const pathString = JSON.stringify(pathDuration.path.map(node => node.ID));
                if (!uniquePathDurations.some(unique => JSON.stringify(unique.path.map(node => node.ID)) === pathString)) {
                    uniquePathDurations.push(pathDuration);
                }
            });

            // Sort the unique pathDurations based on duration
            uniquePathDurations.sort((a, b) => a.duration - b.duration);

            // Calculate the first and third quartiles (Q1 and Q3)
            const q1 = uniquePathDurations[Math.floor(uniquePathDurations.length / 4)].duration;
            const q3 = uniquePathDurations[Math.floor(3 * uniquePathDurations.length / 4)].duration;

            // Calculate the interquartile range (IQR)
            const iqr = q3 - q1;

            let adjustmentFactor = 1.5;  // Starting factor for IQR
            let outlierPathDurations;

            do {
                // Set the lower and upper thresholds
                const lowerThreshold = q1 - adjustmentFactor * iqr;
                const upperThreshold = q3 + adjustmentFactor * iqr;

                // Filter the outlier paths based on the thresholds
                outlierPathDurations = uniquePathDurations.filter(pathDuration => pathDuration.duration < lowerThreshold || pathDuration.duration > upperThreshold);

                // Reduce the adjustment factor to lax the bounds and find more outliers
                adjustmentFactor -= 0.1;
            } while (outlierPathDurations.length < MIN_OUTLIER_PATHS && adjustmentFactor >= 0);

            // Log information
            outlierPathDurations.forEach(pathDuration => {
                console.log(`Outlier Path:`);
                pathDuration.path.forEach((node, nodeIndex) => {
                    let linkDuration = 0;
                    if (nodeIndex < pathDuration.path.length - 1) {
                        let link = links.find(l => l.source === node && l.target === pathDuration.path[nodeIndex + 1]);
                        linkDuration = link ? Number(link.duration) : 0;
                    }
                    console.log(`Node ID: ${node.ID}, Node Duration: ${node.Duration}, Link Duration to next node: ${linkDuration}`);
                });
                console.log(`Total Duration for Path:`, pathDuration.duration);
            });

            // Label nodes on the outlier paths
            outlierPathDurations.forEach(pathDuration => {
                pathDuration.path.forEach(node => {
                    node.isOnOutlierPath = true;
                });
            });

            return {
                paths: outlierPathDurations.map(pd => pd.path),
                durations: outlierPathDurations.map(pd => pd.duration)
            };
        }


        // Displaying all paths
        displayPaths(paths, 'All Paths:', 'pathsDisplay');
        // Displaying the longest path and outlier paths
        displayPaths([longestPath], 'Longest Path:', 'longestPathDisplay');
        displayPaths(outlierPaths, 'Outlier Paths:', 'outlierPathsDisplay');

        document.getElementById("highlightCriticalPath").addEventListener("change", updatePathsDisplay);
        document.getElementById("highlightOutliers").addEventListener("change", updatePathsDisplay);

        function updatePathsDisplay() {
            // Clear previous highlights
            clearHighlights();

            // Update critical path, outlier paths, and all paths based on checkboxes
            updateCriticalPathDisplay();
            updateOutlierPathsDisplay();
            updateAllPathsDisplay();
        }

        var acc = document.getElementsByClassName("accordion-button");
        var i;

        for (i = 0; i < acc.length; i++) {
            acc[i].addEventListener("click", function () {
                this.classList.toggle("active");
                var panel = this.nextElementSibling;
                if (panel.style.maxHeight) {
                    panel.style.maxHeight = null;
                } else {
                    panel.style.maxHeight = panel.scrollHeight + "px";
                }
            });
        }

        function highlightPath(path, color, link, node, duration) {
            link.style("stroke", function (l) {
                if (path.includes(l.source) && path.includes(l.target)) {
                    return color;
                }
                // Keep the existing color if not in the path
                return d3.select(this).style("stroke");
            }).attr("stroke-width", function (l) {
                if (path.includes(l.source) && path.includes(l.target)) {
                    return 4;
                }
                // Keep the existing stroke-width if not in the path
                return d3.select(this).attr("stroke-width");
            });

            node.select("circle").style("fill", function (n) {
                if (path.includes(n)) {
                    return color;
                }
                // Keep the existing fill color if not in the path
                return d3.select(this).style("fill");
            }).attr("r", function (n) {
                if (path.includes(n)) {
                    return 30;
                }
                // Keep the existing radius if not in the path
                return d3.select(this).attr("r");
            });

            var tooltip = d3.select(".tooltip");
            tooltip.html(`Path Duration: ${duration} units`).style("background-color", 'color');
        }


        function clearHighlights() {
            link.style("stroke", null)
                .attr("stroke-width", 2);

            node.select("circle").style("fill", function (n) {
                var selectedMetric = document.querySelector('input[name="colorMetric"]:checked').value;
                var metricValue;

                switch (selectedMetric) {
                    case "inDegree":
                        metricValue = n.inDegree;
                        break;
                    case "outDegree":
                        metricValue = n.outDegree;
                        break;
                    case "degree":
                        metricValue = n.degree;
                        break;
                    default:
                        metricValue = n.inDegree; // default to in-degree if something goes wrong
                }

                switch (true) {
                    case metricValue > 4: return "#41afeb";
                    case metricValue > 3: return "#46b9fa";
                    case metricValue > 2: return "#5ac8fa";
                    case metricValue > 1: return "#8ce6ff";
                    default: return "#b4f5ff";
                }
            });
        }

        function updateCriticalPathDisplay() {
            if (document.getElementById("highlightCriticalPath").checked) {
                const criticalPath = findCriticalPath(paths, links);
                highlightPath(criticalPath.path, 'red'); // Highlight the critical path in red
            }
        }

        function updateOutlierPathsDisplay() {
            if (document.getElementById("highlightOutliers").checked) {
                const outlierPaths = findOutlierPaths(paths, links);
                outlierPaths.paths.forEach(outlierPath => {
                    highlightPath(outlierPath, 'orange'); // Highlight outlier paths in orange
                });
                const criticalPath = findCriticalPath(paths, links);
                highlightPath(criticalPath.path, 'red'); // Highlight the critical path in red
            }
        }

        function updateAllPathsDisplay() {
            // If you want to highlight all paths in a specific color, you can do so here
            paths.forEach(path => {
                highlightPath(path, 'blue'); // Highlight all paths in blue
            });
        }

        function updateLegend() {
            var selectedMetric = document.querySelector('input[name="colorMetric"]:checked').value;
            var metricText;

            switch (selectedMetric) {
                case "inDegree":
                    metricText = "In-degree";
                    break;
                case "outDegree":
                    metricText = "Out-degree";
                    break;
                case "degree":
                    metricText = "Degree";
                    break;
                default:
                    metricText = "In-degree"; // default to in-degree if something goes wrong
            }

            document.getElementById("legendMetric").textContent = metricText;
        }
        function showTooltip(content, color) {
            const tooltip = d3.select("#tooltip");
            tooltip.transition()
                .duration(200)
                .style("visibility", "visible");
            tooltip.html(content)
                .style("top", "10px")
                .style("right", "10px")
                .style("color", color);
        }

        // Add event listener to the radio buttons to update the legend when the metric changes
        var radios = document.querySelectorAll('input[name="colorMetric"]');
        radios.forEach(radio => {
            radio.addEventListener("change", updateLegend);
        });

        // Call this once at the start to set the initial state of the legend:
        updateLegend();

        function drawCharts(nodes, links) {
            let dampingFactor = 0.85;  // Example damping factor for PageRank, adjust as needed
            let maxIterations = 100;   // Example max iterations for both PageRank and Eigenvector centrality

            computeNetworkMetrics(nodes, links, dampingFactor, maxIterations).then(result => {
                console.log("Updated Nodes with Metrics:", result.updatedNodes);
                console.log("Network Density:", result.networkDensity);

                // Move all your drawing functions inside this .then() block
                drawScatterPlotWithD3(result.updatedNodes, links);  // Use the updated nodes
                console.log("Drawing S-Curve...");
                drawSCurve(result.updatedNodes, links);  // Use the updated nodes
                console.log("Drawing Histogram...");
                drawHistogramChartJS(result.updatedNodes, links);  // Use the updated nodes
                console.log("Drawing Pie Chart...");
                drawPieChart(result.updatedNodes, links);  // Use the updated nodes
                drawPathsDistributionCurve(result.updatedNodes, links);  // Use the updated nodes
                drawRadialChart(result.updatedNodes, links);  // Use the updated nodes
                drawPathDistributionStackedBarChart(nodes, links)
                drawReferenceTable(nodes);
                // Assuming you have paths and links available
                //const criticalPathData = findCriticalPath(paths, links);
                //const outlierPathsData = findOutlierPaths(paths, links);
                //populatePathsTable(criticalPathData, outlierPathsData);
                // Call the function to render the Risk Matrix chart
                drawRiskMatrix(result.updatedNodes, links);  // Use the updated nodes
                // Generate the paths table
                generatePathsTable(result.updatedNodes, links);
                generateKanbanCards(nodes, links);

                // Generate reduced graph using PageRank with durations, critical path, and outliers
                console.log("About to Enter drawReducedGraphWithVis");
                const result1 = constructNetworkUsingPageRankWithDurationsCriticalPathAndOutliers(result.updatedNodes, links);
                const resultReduced = constructNetworkUsingPageRankWithDurationsCriticalPathAndOutliers(result1.nodes, result1.links);
                //console.log("About to Enter drawReducedGraphWithVis2", resultReduced.nodes, resultReduced.links, resultReduced.criticalPathSet, resultReduced.outlierTasksSet);
                //drawReducedGraphWithVis(resultReduced.nodes, resultReduced.links, resultReduced.criticalPathSet, resultReduced.outlierTasksSet);
                drawReducedGraphWithVis(resultReduced.nodes, resultReduced.links);

            });
        }

        google.charts.load('current', { 'packages': ['corechart'] });
        google.charts.setOnLoadCallback(initializeDataAndDrawCharts);

        function drawSCurve(nodes, links) {
            links.forEach(link => {
                link.duration = +link.duration;
            });
            console.log("Drawing S-Curve with nodes data:", nodes);
            console.log("Drawing S-Curve with links data:", links);
            // Convert all durations to numbers

            //let tasksSortedByDuration = links.slice().sort((a, b) => a.duration - b.duration);
            let nonZeroDurationTasks = links.filter(link => link.duration > 0); // filtering out tasks with a duration of 0
            let tasksSortedByDuration = nonZeroDurationTasks.slice().sort((a, b) => a.duration - b.duration);

            let cumulativeData = [["Duration", "Cumulative Count"]];
            let cumulativeCount = 0;

            for (let link of tasksSortedByDuration) {
                cumulativeCount++;
                cumulativeData.push([link.duration, cumulativeCount]);
            }

            var maxDuration = Math.max(...cumulativeData.map(d => d[0]));
            var data = google.visualization.arrayToDataTable(cumulativeData);
            var options = {
                title: 'S-Curve of Task Completion',
                titleTextStyle: { color: '#ffffff' },  // Setting the title text color to white
                hAxis: { title: 'Duration', textStyle: { color: '#b4f5ff' }, gridlines: { color: '#195a8c' }, baselineColor: '#3292cd' },
                vAxis: { title: 'Cumulative Count', textStyle: { color: '#b4f5ff' }, gridlines: { color: '#195a8c' }, baselineColor: '#3292cd' },
                legend: {
                    position: 'bottom',
                    textStyle: { color: '#ffffff' } // Setting the legend text color to white
                },
                backgroundColor: '#113464',
                colors: ['#46b9fa'] // Color for the line
            };
            options.hAxis.viewWindow = { min: 0, max: maxDuration };
            var chart = new google.visualization.LineChart(document.getElementById('scurve_chart'));
            chart.draw(data, options);
        }

        function drawHistogramChartJS(nodes, links) {
            console.log("Drawing Histogram with links data:", links);

            let durations = links.map(link => link.duration);
            let histogramData = {};
            let taskNamesForDuration = {}; // Store task names for each duration

            durations.forEach((duration, index) => {
                if (histogramData[duration]) {
                    histogramData[duration]++;
                    taskNamesForDuration[duration].push(links[index].source.Name + " to " + links[index].target.Name); // Assuming source and target have a 'Name' property
                } else {
                    histogramData[duration] = 1;
                    taskNamesForDuration[duration] = [links[index].source.Name + " to " + links[index].target.Name];
                }
            });

            let maxDuration = Math.max(...durations);

            var xTicks = [];
            for (let i = 0; i <= maxDuration; i++) {
                xTicks.push(i);
            }

            new Chart(document.getElementById('histogramChart').getContext('2d'), {
                type: 'bar',
                data: {
                    labels: Object.keys(histogramData),
                    datasets: [{
                        label: 'Task Durations',
                        data: Object.values(histogramData),
                        backgroundColor: 'rgba(70, 185, 250, 0.5)',
                        borderColor: 'rgba(70, 185, 250, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Tasks',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#b4f5ff'
                            },
                            grid: {
                                color: '#195a8c'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Task Duration',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#b4f5ff',
                                autoSkip: false,
                                maxRotation: 90,
                                minRotation: 90
                            },
                            grid: {
                                color: '#195a8c'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    let duration = context.label;
                                    let taskNames = taskNamesForDuration[duration];
                                    return [
                                        'Duration: ' + duration,
                                        'Number of Tasks: ' + histogramData[duration],
                                        'Tasks: ' + taskNames.join(', ')
                                    ];
                                }
                            }
                        }
                    }
                }
            });
        }


        function drawPieChart(nodes, links) {
            console.log("Drawing Pie Chart with links data:", links);

            const sliceCount = 5; // Number of slices we want on our pie chart
            let durations = links.map(link => link.duration).sort((a, b) => a - b);
            let maxDuration = durations[durations.length - 1];
            let minDuration = durations[0];
            let rangeSize = Math.ceil((maxDuration - minDuration + 1) / sliceCount);
            let durationRanges = {};

            // Initialize the ranges
            for (let i = 0; i < sliceCount; i++) {
                let start = minDuration + i * rangeSize;
                let end = start + rangeSize - 1;
                if (i === sliceCount - 1) {
                    end = maxDuration; // For the last slice, ensure the end is the actual max duration
                }
                let key = start === end ? `${start}` : `${start}-${end}`;
                durationRanges[key] = 0;
            }

            // Categorize durations
            for (let link of links) {
                let category = Object.keys(durationRanges).find(range => {
                    let [start, end] = range.split('-').map(Number);
                    if (!end) end = start; // For ranges representing a single value
                    return link.duration >= start && link.duration <= end;
                });
                durationRanges[category]++;
            }

            // Generate the pie data with counts appended to the labels
            let pieData = [["Duration Range", "Count"]];
            for (let range in durationRanges) {
                pieData.push([`${range} days (${durationRanges[range]} tasks)`, durationRanges[range]]);
            }

            var data = google.visualization.arrayToDataTable(pieData);
            var options = {
                title: 'Distribution of Task Durations with Task Counts',
                titleTextStyle: { color: '#ffffff' },
                backgroundColor: '#113464',
                legend: {
                    position: 'bottom',
                    textStyle: { color: '#ffffff' }
                },
                tooltip: {
                    text: 'percentage',  // Display percentage in the tooltip
                    textStyle: { color: '#000000' }  // Set tooltip text color to black
                }
            };

            var chart = new google.visualization.PieChart(document.getElementById('pie_chart'));
            chart.draw(data, options);
        }


        function drawPathsDistributionCurve(nodes, links) {
            // Find start and end nodes
            var startNode = nodes.find(node => node.ID === "0"); // Assuming ID is a string
            var endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);

            // Find all paths from startNode to endNode
            var paths = findAllPaths(startNode, endNode, links, nodes);

            // Calculate the total duration for each path
            const pathDurations = paths.map(path => {
                return path.reduce((total, node, index, array) => {
                    if (index < array.length - 1) {
                        let link = links.find(l => l.source === node && l.target === array[index + 1]);
                        if (!link) {
                            return total;
                        }
                        return total + link.duration;
                    }
                    return total;
                }, 0);
            });

            // Group paths by their duration to get counts
            const durationCounts = {};
            pathDurations.forEach(duration => {
                durationCounts[duration] = (durationCounts[duration] || 0) + 1;
            });

            // Convert the durationCounts object to an array suitable for Google Charts
            const dataForChart = [["Path Length", "Number of Paths"]];
            for (let duration in durationCounts) {
                dataForChart.push([+duration, durationCounts[duration]]);
            }

            var data = google.visualization.arrayToDataTable(dataForChart);
            var options = {
                title: 'Distribution of Path Lengths',
                titleTextStyle: { color: '#ffffff' },
                hAxis: {
                    title: 'Path Length',
                    titleTextStyle: { color: '#ffffff' }, // Set title text color to white
                    textStyle: { color: '#b4f5ff' },
                    gridlines: { color: '#195a8c' },
                    baselineColor: '#3292cd'
                },
                vAxis: {
                    title: 'Number of Paths',
                    titleTextStyle: { color: '#ffffff' }, // Set title text color to white
                    textStyle: { color: '#b4f5ff' },
                    gridlines: { color: '#195a8c' },
                    baselineColor: '#3292cd'
                },
                legend: {
                    position: 'bottom',
                    textStyle: { color: '#ffffff' }
                },
                backgroundColor: '#113464',
                colors: ['#46b9fa'],
                chartArea: {
                    width: '90%',  // Adjust based on your needs
                    height: '80%'  // Adjust based on your needs
                }
            };

            var chart = new google.visualization.LineChart(document.getElementById('path_distribution_chart'));
            chart.draw(data, options);
        }

        function formatDate(dateString) {
            let date = new Date(dateString);
            let day = String(date.getUTCDate()).padStart(2, '0');
            let month = String(date.getUTCMonth() + 1).padStart(2, '0'); // Months are 0-indexed in JS
            let year = date.getUTCFullYear();
            return `${day}-${month}-${year}`;
        }


        function drawRiskMatrix(nodes, links) {
            console.log("Entered drawRiskMatrix", nodes, links);

            // Check nodes and links length
            console.log("drawRiskMatrix Number of nodes:", nodes.length);
            console.log("drawRiskMatrix Number of links:", links.length);

            var scores = nodes.map(node => ({
                id: node.ID,
                riskScore: node.riskScore,
                importanceScore: node.importanceScore,
                combinedScore: (node.riskScore + node.importanceScore) / 2,
                name: node.Name,
                start: node.Start,
                finish: node.Finish,
                pageRank: node.pageRank,
                slack: node.slack,
                path: node.isOnCriticalPath ? 'Critical Path' :
                    node.isOnOutlierPath ? 'Outlier Path' : 'Regular Path',
                overrunProbability: node.overrun_probability || 0  // Added this line
            }));

            // First, find the min and max combined scores
            // Log the combined scores for validation
            console.log("drawRiskMatrix Combined scores:", scores.map(s => s.combinedScore));

            const minCombinedScore = Math.min(...scores.map(s => s.combinedScore));
            const maxCombinedScore = Math.max(...scores.map(s => s.combinedScore));

            // Define the getColorForCombinedScore function within the drawRiskMatrix function
            function getColorForCombinedScore(combinedScore) {
                // If the combinedScore is NaN, return a distinct color
                if (isNaN(combinedScore)) {
                    return `rgb(128, 128, 128)`;  // Return a neutral gray color
                }

                // If max and min combined scores are essentially the same, normalize to 0.5 (middle value)
                if (maxCombinedScore - minCombinedScore < 0.0001) {
                    combinedScore = (maxCombinedScore + minCombinedScore) / 2;
                }

                const normalizedScore = (combinedScore - minCombinedScore) / (maxCombinedScore - minCombinedScore);

                const red = Math.floor(255 * normalizedScore);
                const green = Math.floor(255 * (1 - normalizedScore));

                const color = `rgb(${red}, ${green}, 0)`;
                console.log("Returning color:", color);  // Debug log
                return color;
            }

            // Function to calculate IQR and identify outliers
            const MIN_OUTLIERS = 5;  // Adjust this as needed

            function identifyOutliers(data) {
                const values = data.slice().sort((a, b) => a - b);
                const q1 = values[Math.floor((values.length / 4))];
                const q3 = values[Math.floor((values.length * 3) / 4)];
                const iqr = q3 - q1;

                let adjustmentFactor = 5; // Start with 5 as the adjustment factor for IQR
                let outliers;

                do {
                    const lowerBound = q1 - adjustmentFactor * iqr;
                    const upperBound = q3 + adjustmentFactor * iqr;
                    outliers = data.map(score => score < lowerBound || score > upperBound);

                    // Decrease the adjustment factor to lax the bounds and find more outliers
                    adjustmentFactor -= 0.5;
                } while (outliers.filter(Boolean).length < MIN_OUTLIERS && adjustmentFactor >= 0);

                return outliers;
            }

            const riskOutliers = identifyOutliers(scores.map(s => s.riskScore));
            const importanceOutliers = identifyOutliers(scores.map(s => s.importanceScore));

            nodes.forEach((node, idx) => {
                node.isRiskOutlier = riskOutliers[idx];
            });
            nodes.forEach((node, idx) => {
                node.isImportanceOutlier = importanceOutliers[idx];
            });


            // Filter nodes to only include outliers based on risk or importance
            const outlierScores = scores.filter((_, idx) => riskOutliers[idx] || importanceOutliers[idx]);

            const scatterData = outlierScores.map(score => ({
                x: score.riskScore,
                y: score.importanceScore,
                combinedScore: score.combinedScore,
                name: score.name,
                path: score.path
            }));

            const maxRisk = Math.max(...scores.map(s => s.riskScore));
            const minRisk = Math.min(...scores.map(s => s.riskScore));

            const maxImportance = Math.max(...scores.map(s => s.importanceScore));
            const minImportance = Math.min(...scores.map(s => s.importanceScore));

            const riskRange = maxRisk - minRisk;
            const importanceRange = maxImportance - minImportance;

            const adjustedMinRisk = minRisk - 0.05 * riskRange;
            const adjustedMaxRisk = maxRisk + 0.05 * riskRange;

            const adjustedMinImportance = minImportance - 0.05 * importanceRange;
            const adjustedMaxImportance = maxImportance + 0.05 * importanceRange;

            // Log min and max combined scores
            console.log("drawRiskMatrix Min combined score:", minCombinedScore);
            console.log("drawRiskMatrix Max combined score:", maxCombinedScore);

            // Check if there are any outliers
            console.log("drawRiskMatrix Number of risk outliers:", riskOutliers.filter(Boolean).length);
            console.log("drawRiskMatrix Number of importance outliers:", importanceOutliers.filter(Boolean).length);

            // Check the size of the scatter data
            console.log("drawRiskMatrix Scatter data length:", scatterData.length);

            var ctx = document.getElementById('riskMatrix').getContext('2d');
            var chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Risks',
                        data: scatterData,
                        backgroundColor: context => {
                            const dataPoint = context.dataset.data[context.dataIndex];
                            return dataPoint && dataPoint.combinedScore ? getColorForCombinedScore(dataPoint.combinedScore) : 'rgba(0,0,0,0.1)';
                        },
                        borderColor: 'white',
                        borderWidth: 1,
                        pointStyle: 'circle',
                        pointRadius: 8,
                        hoverRadius: 12
                    }]
                },
                options: {
                    scales: {
                        y: {
                            min: adjustedMinImportance,
                            max: adjustedMaxImportance,
                            title: {
                                display: true,
                                text: 'Importance',
                                color: 'white',
                                font: {
                                    size: 16
                                }
                            },
                            ticks: {
                                color: 'white',
                                beginAtZero: true,
                                fontSize: 14
                            },
                            grid: {
                                color: '#b4f5ff',
                                lineWidth: 0.5
                            }
                        },
                        x: {
                            min: adjustedMinRisk,
                            max: adjustedMaxRisk,
                            title: {
                                display: true,
                                text: 'Risk',
                                color: 'white',
                                font: {
                                    size: 16
                                }
                            },
                            ticks: {
                                color: 'white',
                                beginAtZero: true,
                                fontSize: 14
                            },
                            grid: {
                                color: '#b4f5ff',
                                lineWidth: 0.5
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            enabled: true,
                            mode: 'point', // Ensure tooltips show for each individual data point
                            callbacks: {
                                label: context => {
                                    var score = context.dataset.data[context.dataIndex];
                                    return score.name + ' (Risk: ' + score.x.toFixed(2) + ', Importance: ' + score.y.toFixed(2) + ', Path: ' + score.path + ')';
                                }
                            }
                        }
                    }
                }
            });


            // Populate the risk table with only outlier nodes
            var riskTableBody = document.getElementById('riskTableBody');
            riskTableBody.innerHTML = '';
            outlierScores.forEach(function (score, index) {
                if (!score) {
                    console.error("Undefined score at index:", index);
                    return; // Skip this iteration
                }
                var row = document.createElement('tr');
                var idCell = document.createElement('td');
                var nameCell = document.createElement('td');
                var riskCell = document.createElement('td');
                var importanceCell = document.createElement('td');
                var pathCell = document.createElement('td');
                var startCell = document.createElement('td');
                var finishCell = document.createElement('td');
                var pageRankCell = document.createElement('td');
                //pageRankCell.textContent = score.pageRank.toFixed(5);
                pageRankCell.textContent = (score.pageRank || 0).toFixed(5);
                var slackCell = document.createElement('td');
                slackCell.textContent = score.slack.toFixed(2); // Assuming slack is a number
                var overrunProbabilityCell = document.createElement('td');  // Added this block
                overrunProbabilityCell.textContent = score.overrunProbability.toFixed(2);

                idCell.textContent = score.id;
                nameCell.textContent = score.name;
                riskCell.textContent = score.riskScore.toFixed(2);
                importanceCell.textContent = score.importanceScore.toFixed(2);
                pathCell.textContent = score.path;
                startCell.textContent = score.start;
                finishCell.textContent = score.finish;

                startCell.textContent = formatDate(score.start);
                finishCell.textContent = formatDate(score.finish);

                // Adjust text color based on path type
                if (score.path === 'Critical Path') {
                    pathCell.style.color = 'red';
                } else if (score.path === 'Outlier Path') {
                    pathCell.style.color = 'orange';
                }

                row.appendChild(idCell);
                row.appendChild(nameCell);
                row.appendChild(riskCell);
                row.appendChild(importanceCell);
                row.appendChild(pathCell);
                row.appendChild(pageRankCell);
                row.appendChild(startCell);
                row.appendChild(finishCell);
                row.appendChild(slackCell);
                row.appendChild(overrunProbabilityCell);

                riskTableBody.appendChild(row);
            });
        }

        function populatePathsTable(criticalPathData, outlierPathsData) {
            const tableBody = document.getElementById('pathTableBody');

            // Add critical path
            const criticalRow = document.createElement('tr');
            criticalRow.innerHTML = `
                                            <td class="critical">Critical Path</td>
                                            <td class="critical">${criticalPathData.duration}</td>
                                            ${criticalPathData.path.map(node => `<td class="critical">${node.ID}</td>`).join('')}
                                        `;
            tableBody.appendChild(criticalRow);

            // Add outlier paths
            outlierPathsData.paths.forEach((path, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                                                <td class="outlier">Outlier Path</td>
                                                <td class="outlier">${outlierPathsData.durations[index]}</td>
                                                ${path.map(node => `<td class="outlier">${node.ID}</td>`).join('')}
                                            `;
                tableBody.appendChild(row);
            });
        }

        function drawReferenceTable(nodes) {
            var referenceTableBody = document.getElementById('referenceTableBody');
            referenceTableBody.innerHTML = '';
            nodes.forEach(function (node) {
                if (node.isOnCriticalPath || node.isOnOutlierPath) {
                    var row = document.createElement('tr');
                    var idCell = document.createElement('td');
                    var nameCell = document.createElement('td');
                    var pathCell = document.createElement('td');

                    idCell.textContent = node.ID;
                    nameCell.textContent = node.Name;

                    if (node.isOnCriticalPath) {
                        pathCell.textContent = 'Critical Path';
                        pathCell.style.color = 'red';
                    } else if (node.isOnOutlierPath) {
                        pathCell.textContent = 'Outlier Path';
                        pathCell.style.color = 'orange';
                    } else {
                        pathCell.textContent = 'Regular Path';
                    }

                    row.appendChild(idCell);
                    row.appendChild(nameCell);
                    row.appendChild(pathCell);

                    referenceTableBody.appendChild(row);
                }
            });
        }

        function drawRadialChart(nodes) {
            var ctx = document.getElementById('radialChart').getContext('2d');

            const themeColors = [
                "#cdfaff", "#b4f5ff", "#8ce6ff", "#5ac8fa",
                "#46b9fa", "#41afeb", "#3292cd", "#287dc8",
                "#1e69aa", "#195a8c"
            ];

            const supplementaryColors = [
                "#FFA500", // Orange (Used sparingly for differentiation)
                "#9400D3"  // Violet (Used sparingly for differentiation)
            ];

            function generateColor(index) {
                if (index < themeColors.length) {
                    return themeColors[index];
                } else {
                    return supplementaryColors[index - themeColors.length];
                }
            }

            nodes.sort((a, b) => b.Duration - a.Duration);
            const N = 8;
            nodes = nodes.slice(0, N);

            var myChart = new Chart(ctx, {
                type: 'polarArea',
                data: {
                    labels: nodes.map(node => node.Name),
                    datasets: [{
                        data: nodes.map(node => node.Duration),
                        backgroundColor: nodes.map((_, index) => generateColor(index)),
                        borderWidth: 1,
                        borderColor: ['#ffffff']
                    }]
                },
                options: {
                    responsive: true,
                    legend: {
                        position: 'top',
                        labels: {
                            fontColor: themeColors[5]
                        }
                    },
                    title: {
                        display: true,
                        text: 'Activity Duration Radial Chart',
                        fontColor: themeColors[6]
                    },
                    scale: {
                        ticks: {
                            beginAtZero: true,
                            fontColor: themeColors[7],
                            stepSize: Math.max(...nodes.map(node => node.Duration)) / 10
                        },
                        gridLines: {
                            color: themeColors[8]
                        }
                    },
                    plugins: {
                        tooltip: {
                            backgroundColor: 'rgba(17, 52, 100, 0.8)', // 80% transparency
                            titleFont: {
                                size: 14,  // Reduced font size for the title
                                weight: 'bold',
                                family: "'Orbitron', sans-serif"
                            },
                            bodyFont: {
                                size: 12,  // Reduced font size for the body
                                family: "'Orbitron', sans-serif"
                            },
                            callbacks: {
                                title: function (context) {
                                    return context[0].label;
                                },
                                label: function (context) {
                                    const node = nodes[context.dataIndex];
                                    return [
                                        `Duration: ${node.Duration} days`,
                                        `Risk: ${node.riskScore}`,
                                        `Importance: ${node.importanceScore}`
                                    ];
                                }
                            }
                        }
                    },
                    onHover: (event, chartElement) => {
                        if (event && event.target) {
                            event.target.style.cursor = chartElement[0] ? 'pointer' : 'default';
                        }
                    }
                }
            });

            ctx.canvas.onclick = function (event) {
                var activePoints = myChart.getElementsAtEventForMode(event, 'point', myChart.options);
                var firstPoint = activePoints[0];
                if (firstPoint) {
                    var node = nodes[firstPoint.index];
                    alert(`Clicked on: ${node.Name}`);
                }
            };
        }
        // Use the function as:
        // drawRadialChart(nodes);

        // Sample data
        var chartData = [
            { label: 'Supply Chain Disruption', value: 80 },
            { label: 'Budget Overrun', value: 90 },
            { label: 'Scope Creep', value: 70 },
            { label: 'Technical Failure', value: 50 },
            { label: 'Regulatory Changes', value: 30 },
            { label: 'Safety Incident', value: 20 },
            { label: 'Resource Shortage', value: 60 },
            { label: 'Schedule Delay', value: 40 }
        ];

        //redundannt function
        function drawScatterPlotWithD3(nodes, links) {
            let nonZeroDurationTasks = links.filter(link => link.duration > 0);
            let tasksSortedByDuration = nonZeroDurationTasks.slice().sort((a, b) => a.duration - b.duration);

            let cumulativeData = [];
            let cumulativeCount = 0;
            for (let link of tasksSortedByDuration) {
                cumulativeCount++;
                cumulativeData.push({ x: link.duration, y: cumulativeCount });
            }

            let svgWidth = 400, svgHeight = 300;
            let margin = { top: 20, right: 20, bottom: 30, left: 50 };
            let width = svgWidth - margin.left - margin.right;
            let height = svgHeight - margin.top - margin.bottom;

            let x = d3.scaleLinear().range([0, width]);
            let y = d3.scaleLinear().range([height, 0]);

            let svg = d3.select("#scurve_chart2").append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            x.domain(d3.extent(cumulativeData, d => d.x));
            y.domain([0, d3.max(cumulativeData, d => d.y)]);

            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            svg.append("g")
                .call(d3.axisLeft(y));

            svg.selectAll(".dot")
                .data(cumulativeData)
                .enter().append("circle")
                .attr("class", "dot")
                .attr("r", 3.5)
                .attr("cx", d => x(d.x))
                .attr("cy", d => y(d.y))
                .style("fill", "#0077b6");
        }

        function drawPathDistributionStackedBarChart(nodes, links) {
            // Compute paths and their durations as before
            var startNode = nodes.find(node => node.ID === "0");
            var endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);
            var paths = findAllPaths(startNode, endNode, links, nodes);
            const pathDurations = paths.map(path => {
                return path.reduce((total, node, index, array) => {
                    if (index < array.length - 1) {
                        let link = links.find(l => l.source === node && l.target === array[index + 1]);
                        if (!link) {
                            return total;
                        }
                        return total + link.duration;
                    }
                    return total;
                }, 0);
            });

            // Group paths by their duration to get counts
            const durationCounts = {};
            pathDurations.forEach(duration => {
                durationCounts[duration] = (durationCounts[duration] || 0) + 1;
            });

            // Prepare data for chart
            const dataForChart = {
                labels: Object.keys(durationCounts),
                datasets: [{
                    label: 'Number of Paths',
                    data: Object.values(durationCounts),
                    backgroundColor: 'rgba(70, 185, 250, 0.5)',
                    borderColor: 'rgba(70, 185, 250, 1)',
                    borderWidth: 1
                }]
            };

                // Calculate cumulative counts for overlay line graph
            let cumulativeCounts = [];
            let cumulativeCount = 0;
            Object.values(durationCounts).forEach(count => {
                cumulativeCount += count;
                cumulativeCounts.push(cumulativeCount);
            });

            // Update dataForChart to include cumulative count dataset
            dataForChart.datasets.push({
                label: 'Cumulative Count',
                data: cumulativeCounts,
                type: 'line',  // this will ensure dataset is drawn as a line
                borderColor: 'rgba(200, 50, 50, 0.8)',
                fill: false,
                pointBackgroundColor: 'rgba(200, 50, 50, 0.8)',
                pointBorderColor: 'rgba(200, 50, 50, 0.8)'
            });

            var ctx = document.getElementById('pathDistributionStackedBarChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',  // main type remains bar
                data: dataForChart,
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Paths',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#b4f5ff'
                            },
                            grid: {
                                color: '#195a8c'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Path Duration',
                                color: '#ffffff'
                            },
                            ticks: {
                                autoSkip: true,  // auto-skip overlapping labels
                                maxTicksLimit: 10,  // maximum 10 ticks on x-axis
                                color: '#b4f5ff',
                                maxRotation: 90,
                                minRotation: 90
                            },
                            grid: {
                                color: '#195a8c'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return `Duration: ${context.label}, Number of Paths: ${context.dataset.data[context.dataIndex]}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function generateKanbanCards(nodes, links) {
            const container = document.querySelector('.kanban-columns');

            // Clear existing columns
            container.innerHTML = "";

            const columns = {
                todo: [],
                inProgress: [],
                done: []
            };

            nodes.forEach(node => {
                const currentDate = new Date();
                const startDate = new Date(node.Start);
                const finishDate = new Date(node.Finish);

                // Calculate days left for deadline
                const daysLeft = Math.ceil((finishDate - currentDate) / (1000 * 60 * 60 * 24));
                const daysLeftText = daysLeft > 0 ? `${daysLeft} days left` : daysLeft === 0 ? `Due today` : `Overdue by ${Math.abs(daysLeft)} days`;

                let column = 'todo';
                if (currentDate >= startDate && currentDate <= finishDate) {
                    column = 'inProgress';
                } else if (currentDate > finishDate) {
                    column = 'done';
                }

                const pathType = node.isOnCriticalPath ? 'Critical Path' : node.isOnOutlierPath ? 'Outlier Path' : 'Regular Path';

                // Determine risk, importance, and path colors based on their values
                const riskColor = node.isRiskOutlier ? 'red' : '';
                const importanceColor = node.isImportanceOutlier ? 'red' : '';
                const pathColor = node.isOnCriticalPath ? 'red' : node.isOnOutlierPath ? 'orange' : '#8ce6ff';

                // Determine icons only if the task is an outlier
                const riskIcon = node.isRiskOutlier ? '<span class="icon"><i class="fas fa-bolt" style="color:orange;"></i> Risk Outlier</span>' : '';
                const importanceIcon = node.isImportanceOutlier ? '<span class="icon"><i class="fas fa-star" style="color:orange;"></i> Importance Outlier</span>' : '';
                const pathIcon = node.isOnCriticalPath || node.isOnOutlierPath ? `<span class="icon"><i class="fas fa-route" style="color:${pathColor};"></i> ${pathType}</span>` : '';


                // Count the number of outliers and generate the alarm icons
                const outlierCount = [node.isRiskOutlier, node.isImportanceOutlier, node.isOnCriticalPath || node.isOnOutlierPath].filter(Boolean).length;
                const alarms = '<i class="fas fa-bell" style="color:orange;"></i>'.repeat(outlierCount);

                const cardHTML = `
                <div class="kanban-card sci-fi-card" data-start-date="${node.Start}" data-due-date="${node.Finish}" data-lateness="0">
                    <div class="alarm-indicators">${alarms}</div>
                    <h4>${node.Name} (ID: ${node.ID})</h4>
                    <ul>
                        <li style="color:${riskColor}">Risk: ${node.riskScore.toFixed(2)}</li>
                        <li style="color:${importanceColor}">Importance: ${node.importanceScore.toFixed(2)}</li>
                        <li style="color:${pathColor}">Path: ${pathType}</li>
                    </ul>
                    <p>Expected Start: ${startDate.toLocaleDateString()} | Duration: ${node.Duration} days</p>
                    <div class="card-icons">
                        <span class="due-date-icon"><i class="fas fa-calendar-alt"></i> Due: ${finishDate.toLocaleDateString()} (${daysLeftText})</span>
                        <span class="slack"><i class="fas fa-clock"></i> Slack: ${node.slack} hours</span>
                
                    </div>
                    <div class="outlier-indicators">
                        ${riskIcon}
                        ${importanceIcon}
                        ${pathIcon}
                    </div>
                </div>
            `;

                columns[column].push(cardHTML);
            });



            // Create columns
            Object.keys(columns).forEach(key => {
                const columnDiv = document.createElement('div');
                columnDiv.className = 'kanban-column';
                const columnTitle = {
                    todo: 'To Do',
                    inProgress: 'In Progress',
                    done: 'Done'
                };

                columnDiv.innerHTML = `<h3 class="kanban-column-title">${columnTitle[key]}</h3>`;
                columns[key].forEach(cardHTML => {
                    columnDiv.insertAdjacentHTML('beforeend', cardHTML);
                });

                container.appendChild(columnDiv);
            });

            // Create date range picker input
            const dateRangePicker = document.createElement('input');
            dateRangePicker.id = 'dateRangePicker';
            document.body.appendChild(dateRangePicker);

            const dateRangeLabel = document.createElement('span');
            dateRangeLabel.id = 'dateRangeLabel';
            document.body.appendChild(dateRangeLabel);

            const dateRangeSlider = document.createElement('input');
            dateRangeSlider.id = 'dateRangeSlider';
            dateRangeSlider.type = 'range';
            dateRangeSlider.min = 0;
            dateRangeSlider.max = 365; // Assuming a max project duration of one year
            dateRangeSlider.step = 1;
            dateRangeSlider.value = 365; // Default to one year
            document.body.appendChild(dateRangeSlider);

            // Initialize the date range picker
            flatpickr("#dateRangePicker", {
                mode: "range",
                dateFormat: "Y-m-d",
                onChange: function (selectedDates, dateStr, instance) {
                    // When the date range changes, filter the Kanban cards
                    if (selectedDates.length === 2) {
                        const startDate = selectedDates[0];
                        const endDate = selectedDates[1];
                        filterKanbanCards(startDate, endDate);
                    }
                }
            });

            dateRangeSlider.addEventListener('input', function () {
                const days = parseInt(this.value, 10);
                const startDate = new Date();
                const endDate = new Date(startDate);
                endDate.setDate(startDate.getDate() + days);
                updateDateRangeLabel([startDate, endDate]);
                filterKanbanCards(startDate, endDate);
            });

            function updateDateRangeLabel(selectedDates) {
                if (selectedDates && selectedDates.length === 2) {
                    const diff = Math.abs(selectedDates[1] - selectedDates[0]);
                    const days = Math.ceil(diff / (1000 * 60 * 60 * 24));
                    if (days <= 30) {
                        dateRangeLabel.textContent = `${days} days`;
                    } else if (days <= 90) {
                        dateRangeLabel.textContent = `${Math.ceil(days / 7)} weeks`;
                    } else {
                        dateRangeLabel.textContent = `${Math.ceil(days / 30)} months`;
                    }
                }
            }

            // Function to filter the Kanban cards by date range
            function filterKanbanCards(startDate, endDate) {
                // Get all of the Kanban cards
                const cards = document.querySelectorAll('.kanban-card');

                // Hide or show each card based on its start date and due date
                cards.forEach(card => {
                    const start = new Date(card.getAttribute('data-start-date'));
                    const due = new Date(card.getAttribute('data-due-date'));
                    if (start >= startDate && due <= endDate) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }

                    // Calculate days to completion
                    let daysToCompletion = 0;
                    if (start > currentDate) {
                        daysToCompletion = (start - currentDate) / (1000 * 60 * 60 * 24);
                    } else if (due > currentDate) {
                        daysToCompletion = (due - currentDate) / (1000 * 60 * 60 * 24);
                    }

                    if (daysToCompletion) {
                        const daysInfo = document.createElement('p');
                        daysInfo.innerText = `Days to completion: ${Math.ceil(daysToCompletion)}`;
                        card.appendChild(daysInfo);
                    }
                });
            }
        }

    </script>
    <style>
        #sidebar {
            position: fixed;
            top: 15%;
            left: 0;
            width: 200px;
            background-color: #0e2446;
            padding: 10px;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.5);
        }

            #sidebar h3 {
                color: #fff;
                text-align: center;
                margin-bottom: 10px;
            }

            #sidebar ul {
                list-style-type: none;
                padding: 0;
            }

                #sidebar ul li {
                    margin-bottom: 10px;
                }

                    #sidebar ul li a {
                        color: #ddd;
                        text-decoration: none;
                        font-size: 0.9em;
                        display: block;
                        padding: 5px;
                        border-radius: 5px;
                        transition: background-color 0.3s;
                    }

                        #sidebar ul li a:hover {
                            background-color: #575757;
                            #sidebar ul li:hover

        {
            background-color: #8ce6ff; /* Lighter shade for hover */
            color: #113464;
        }

        #toggleSidebar {
            position: absolute;
            top: 20px;
            left: 260px;
            background-color: transparent; /* Making the button background transparent */
            color: #0d2137; /* Darker shade for the arrow */
            border: none;
            cursor: pointer;
            border-radius: 5px;
            padding: 10px 15px;
            font-size: 20px;
            transition: transform 0.3s; /* Transition for rotation */
        }

            #toggleSidebar:hover {
                color: #113464; /* Slightly different darker shade for hover */
            }

        #sidebar.collapsed {
            width: 40px; /* Adjust the width when collapsed to fit the button */
        }

            #sidebar.collapsed h3,
            #sidebar.collapsed ul {
                display: none; /* Hide other elements of the sidebar when collapsed */
            }

            #sidebar.collapsed #toggleSidebar {
                transform: rotate(180deg); /* Rotate the arrow when the sidebar is collapsed */
            }
        }
    </style>
    <style>
        /* Sidebar Styles */
        #sidebar {
            transition: width 0.5s; /* Smooth transition for width changes */
            overflow-x: hidden; /* Hide horizontal scrollbar */
        }

            /* Collapsed state styles for the sidebar */
            #sidebar.collapsed {
                width: 50px; /* Width of the sidebar when collapsed */
            }

                #sidebar.collapsed ul {
                    display: none; /* Hide the list items when sidebar is collapsed */
                }

        /* Button styles for toggling sidebar */
        #sidebarToggleBtn {
            background-color: #113464; /* Dark color from the theme */
            color: #cdfaff; /* Light color from the theme */
            border: none;
            cursor: pointer;
            padding: 10px 15px;
            margin: 10px;
            border-radius: 5px;
            font-size: 24px; /* Size of the icon */
            transition: background-color 0.3s; /* Smooth transition for hover effect */
        }

            #sidebarToggleBtn:hover {
                background-color: #1e69aa; /* Lighter color from the theme for hover effect */
            }

        /* Toggle Button in collapsed state */
        #sidebar.collapsed #sidebarToggleBtn {
            background-color: #113464; /* Dark color from the theme */
            padding: 10px 5px; /* Reduced padding to make the button more compact */
            font-size: 24px; /* Size of the icon */
        }

        /* Adjusting the position and z-index of the toggle button */
        #sidebarToggleBtn {
            position: relative; /* Relative positioning */
            z-index: 9999; /* Ensuring the button stays above other elements but doesn't interfere */
        }
    </style>
    <style>
        /* New low-profile toggle button styles */
        #sidebarToggleBtn {
            background-color: #113464; /* Dark blue from the provided palette */
            border: none;
            cursor: pointer;
            padding: 10px;
            margin: 10px 0;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, transform 0.3s;
        }

            #sidebarToggleBtn:hover {
                background-color: #0d2137; /* Slightly darker blue on hover */
            }

            #sidebarToggleBtn svg {
                fill: #b4f5ff; /* Light blue for the icon */
                width: 20px;
                height: 20px;
            }

        #sidebar.collapsed #sidebarToggleBtn {
            transform: scaleX(0.7); /* Squeeze the button horizontally when sidebar is collapsed */
        }

        /* SVG icon styles for the toggle button */
        .toggle-icon {
            transition: transform 0.3s; /* Smooth transition for icon rotation */
        }
    </style>
    <style>
        /* Distinct sci-fi theme for the container */
        .dashboard-section.introduction-section {
            background: linear-gradient(135deg, #113464, #287dc8);
            border-radius: 25px;
            padding: 30px;
            box-shadow: 0 0 25px #3292cd;
            font-family: 'Arial', sans-serif; /* Modern font */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        /* Distinct styling for the dropdowns */
        .project-dropdown, .location-dropdown {
            width: 99%;
            background: linear-gradient(135deg, #287dc8, #113464);
            border: none;
            border-bottom: 3px solid #3292cd;
            border-radius: 0;
            color: #cdfaff;
            padding: 8px 15px;
            outline: none;
            box-shadow: none;
            cursor: pointer;
            transition: border-bottom 0.3s;
            font-weight: bold;
            appearance: none;
        }

            .project-dropdown:hover, .location-dropdown:hover {
                border-bottom: 3px solid #cdfaff;
            }

        /* Distinct styling for the custom file upload button */
        /* Hiding the traditional file input */
        #xmlFileInput {
            display: none;
        }

        /* Custom designed button for file selection */
        .custom-file-upload {
            display: inline-block;
            background: linear-gradient(45deg, #3292cd, #195a8c);
            border: 2px solid #3292cd;
            border-radius: 10px;
            color: #cdfaff;
            padding: 10px 20px;
            outline: none;
            cursor: pointer;
            transition: background 0.3s, transform 0.3s;
            text-align: center;
            font-size: 16px;
            box-shadow: 0 0 10px #3292cd;
            position: relative;
            width: 26%;
        }

            .custom-file-upload:hover {
                background: linear-gradient(45deg, #287dc8, #113464);
                transform: translateY(-2px);
            }

            .custom-file-upload:active {
                transform: translateY(0);
            }

        /* Icon for the custom file upload button */
        /* .custom-file-upload:before {
                content: '⬆';
                font-size: 20px;
                position: absolute;
                left: 15px;
                top: 50%;
                transform: translateY(-50%);
            } */

        /* Feedback after file selection */
        #xmlFileInput:after {
            content: attr(data-content);
            display: block;
            background: #113464;
            color: #cdfaff;
            border: 2px dashed #3292cd;
            margin-top: 20px;
            padding: 10px;
            border-radius: 15px;
            transition: all 0.3s;
            font-style: italic;
        }
    </style>
    <style>
        /* General body styling */
        body {
            font-family: 'Arial', sans-serif; /* Modern font */
            background: #113464;
            color: #cdfaff;
        }

        /* Links enhancement */
        a {
            color: #3292cd;
            text-decoration: none;
            transition: color 0.3s;
        }

            a:hover {
                color: #cdfaff;
            }

        /* Button enhancements */
        button {
            background: linear-gradient(135deg, #287dc8, #113464);
            border: 2px solid #3292cd;
            border-radius: 15px;
            color: #cdfaff;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            font-weight: bold;
            outline: none;
        }

            button:hover {
                background: linear-gradient(135deg, #3292cd, #195a8c);
                transform: translateY(-2px);
                box-shadow: 0 0 15px #cdfaff;
            }

            button:active {
                transform: translateY(0);
            }

        /* Enhancements for different containers and sections */
        .dashboard-section {
            margin: 20px;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 0 20px #3292cd;
        }

        /* Enhancements for headers and titles */
        h2, h3, h4, h5, h6 {
            color: #cdfaff;
            border-bottom: 2px solid #3292cd;
            padding-bottom: 10px;
        }
    </style>
    <style>
        .dashboard-stat .zoom-in-icon,
        .dashboard-stat .zoom-out-icon,
        .dashboard-stat .reset-icon,
        .dashboard-stat .arrow-icon {
            font-size: 24px !important; /* Increase font size specifically for these icons */
        }
    </style>
    <style>
        /* Ensuring the progress bar content is visible */
        .dashboard-stat .progress-bar {
            background-color: #5ac8fa; /* Using a color from the provided theme */
            height: 20px; /* Increasing height for better visibility */
            border-radius: 10px; /* Rounded corners for aesthetic appeal */
        }

        /* Increasing width of the column containing the progress bar */
        .dashboard-stat .progress-column {
            width: 150px !important; /* Assigning a fixed width to ensure full visibility */
        }
    </style>
    <style>
        /* Typography */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap');

        body {
            font-family: 'Orbitron', sans-serif;
        }

        /* Colors & Background */
        body {
            background: linear-gradient(to bottom right, #0e2446, #113464);
            color: #b4f5ff;
        }

        .dashboard-section {
            background: rgba(16, 45, 80, 0.8);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        /* Buttons */
        .btn, .icon-button {
            background: #5ac8fa;
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            font-size: 14px;
            color: #0d2137;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

            .btn:hover, .icon-button:hover {
                background: #3292cd;
                box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
                transform: translateY(-2px);
            }

        /* Hover & Transition Effects */
        a:hover {
            text-decoration: underline;
            color: #cdfaff;
        }

        /* Additional Styling for Progress Bars */
        .progress-bar {
            background-color: #0d2137;
            border: 1px solid #287dc8;
        }

        .progress-bar-fill {
            background-color: #5ac8fa;
            height: 100%;
            transition: width 0.5s ease;
        }
    </style>

    <style>
        .sci-fi-loading-bar-container {
            width: 100%;
            height: 30px;
            border: 2px solid #5ac8fa;
            border-radius: 15px;
            position: relative;
            margin-top: 20px;
            background: #0d2137;
            overflow: hidden;
            width: 100%;
            height: 30px;
            border: 2px solid #5ac8fa;
            border-radius: 15px;
            margin-top: 10px;
            background: #0d2137;
            overflow: hidden;
            display: inline-block;
            box-shadow: 0 0 20px #5ac8fa;
            position: relative;
            margin-top: 10px;
            background: rgba(40, 125, 200, 0.3);
            border-radius: 8px;
        }

        .sci-fi-loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #5ac8fa, #287dc8);
            position: absolute;
            top: 0;
            left: 0;
        }

        .sci-fi-loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff;
            font-size: 14px;
            z-index: 10;
        }

        @keyframes loadingGlow {
            0% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .sci-fi-loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #5ac8fa, #287dc8, #5ac8fa);
            background-size: 200% 200%;
            animation: loadingGlow 1.5s infinite;
            position: absolute;
            top: 0;
            left: 0;
        }

        @keyframes loadingGlow {
            0% {
                background-position: 100% 50%;
            }

            100% {
                background-position: 0% 50%;
            }
        }

        .sci-fi-loading-bar-container {
            width: 60%; /* Extended length */
            height: 30px;
            border: 2px solid #5ac8fa;
            border-radius: 15px;
            position: relative;
            margin-top: 20px;
            background: #0d2137;
            overflow: hidden;
            display: inline-block; /* Displayed inline with the file upload button */
            vertical-align: middle;
            padding-bottom: 20px;
        }

        .sci-fi-loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #5ac8fa, #287dc8, #5ac8fa);
            background-size: 200% 200%;
            animation: loadingGlow 1.5s infinite;
            position: absolute;
            top: 0;
            left: 0;
            height: 42px;
        }

        #xmlFileInput {
            display: inline-block;
            padding: 10px 15px;
            background: linear-gradient(90deg, #5ac8fa, #287dc8);
            color: #ffffff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            outline: none;
            transition: background 0.3s;
            margin-right: 15px;
        }

            #xmlFileInput:hover {
                background: linear-gradient(90deg, #287dc8, #5ac8fa);
            }

        /* Additional styles for the new elements */
        .uploading-text {
            display: none;
            font-size: 16px;
            font-weight: bold;
            color: darkred;
            margin-left: 15px;
        }

        .sci-fi-loading-bar-container {
            width: 70%; /* Adjusted to accommodate the "upload in progress" text */
        }
    </style>
    <style>
        #xmlFileInput {
            display: none;
        }

        .upload-label {
            display: inline-block;
            padding: 10px 15px;
            background: linear-gradient(90deg, #5ac8fa, #287dc8);
            color: #ffffff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s, transform 0.3s;
            margin-right: 15px;
            position: relative;
            overflow: hidden;
            z-index: 1;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
        }

            .upload-label:hover {
                background: linear-gradient(90deg, #287dc8, #5ac8fa);
                transform: scale(1.05);
            }

            .upload-label::before {
                content: "📂";
                font-size: 18px;
                margin-right: 5px;
            }

            .upload-label:hover::before {
                content: "📤";
            }
    </style>
    <style>
        #xmlFileInput {
            display: none;
        }

        .upload-label {
            display: inline-block;
            padding: 10px 20px;
            background: linear-gradient(90deg, #5ac8fa, #287dc8);
            color: #ffffff;
            border: 2px solid #5ac8fa;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s, transform 0.3s;
            font-size: 16px;
            font-weight: bold;
            text-align: center;
            margin-bottom: 10px;
        }

            .upload-label:hover {
                background: linear-gradient(90deg, #287dc8, #5ac8fa);
            }

            .upload-label::before {
                content: "📤";
                font-size: 20px;
                margin-right: 8px;
            }

        .sci-fi-loading-bar-container {
            width: 70%;
            height: 20px;
            border: 3px solid #5ac8fa;
            border-radius: 10px;
            background: #0d2137;
            overflow: hidden;
            box-shadow: 0 0 20px #5ac8fa;
            position: relative;
        }

        .sci-fi-loading-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #5ac8fa, #287dc8, #5ac8fa);
            position: absolute;
            top: 0;
            left: 0;
            box-shadow: 0 0 10px #5ac8fa, 0 0 20px #5ac8fa, 0 0 30px #287dc8, 0 0 40px #5ac8fa;
        }

        .upload-container {
            display: flex;
            align-items: center;
            justify-content: start;
            gap: 20px;
            transition: all 0.3s;
        }

            .upload-container:hover {
                transform: scale(1.05);
            }

        .sci-fi-loading-bar-container {
            width: 80%;
            margin-left: 10px;
        }

        .upload-label {
            background: linear-gradient(90deg, #287dc8, #5ac8fa);
            border: 3px solid #5ac8fa;
            box-shadow: 0 0 15px rgba(42, 125, 200, 0.6);
            transition: all 0.3s;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
        }

            .upload-label:hover {
                transform: translateY(-3px);
                background: linear-gradient(90deg, #5ac8fa, #287dc8);
            }

            .upload-label::before {
                animation: iconBounce 1s infinite alternate;
            }

        .sci-fi-loading-bar-container {
            width: 100%;
            margin-top: 10px;
        }

        .sci-fi-loading-bar {
            background-color: #287dc8;
            height: 5px;
            border-radius: 5px;
        }

        .sci-fi-loading-text {
            color: #5ac8fa;
            font-size: 14px;
            margin-top: 5px;
        }

        @keyframes iconBounce {
            from {
                transform: translateY(0);
            }

            to {
                transform: translateY(-5px);
            }
        }

        .megaproject-icon {
            width: 100px;
            height: 100px;
            display: inline-block;
            position: relative;
        }

        .rotating-line {
            transform-origin: 50% 50%;
            animation: rotateAnimation 10s infinite linear;
        }

        @keyframes rotateAnimation {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        .pulsing-circle {
            transform-origin: 50% 50%;
            animation: pulseAnimation 1.5s infinite alternate;
        }

        @keyframes pulseAnimation {
            from {
                opacity: 0.2;
                stroke-width: 2px;
            }

            to {
                opacity: 1;
                stroke-width: 3px;
            }
        }

        .megaproject-icon-container {
            position: relative;
            display: inline-block;
            cursor: pointer;
        }

        .cybereum-logo {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20%; /* Adjusted size */
            height: 20%; /* Adjusted size */
            transform: translate(-50%, -50%);
            z-index: 5;
        }

        .futuristic-modal {
            display: none;
            position: fixed;
            padding-top: 100px;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background: repeating-linear-gradient(45deg, transparent, transparent 35px, rgba(90, 200, 250, 0.2) 35px, rgba(90, 200, 250, 0.2) 70px);
            background-color: rgba(0, 0, 0, 0.5); /* Increased transparency */
            z-index: 1000;
            overflow-y: auto;
        }

        .futuristic-modal-content {
            background: linear-gradient(145deg, #0d2137, #1a3458); /* Gradient background */
            margin: 10% auto;
            padding: 20px;
            width: 60%;
            max-width: 800px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4), 0 0 20px #5ac8fa; /* Glowing border effect */
            border: 1px solid #5ac8fa;
            border-radius: 10px;
            position: relative;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Sleek font */
        }

        .futuristic-modal-header {
            background-color: #5ac8fa;
            padding: 10px;
            border-top-left-radius: 8px;
            border-top-right-radius: 8px;
            color: white;
            font-size: 20px;
        }

        .modal-header {
            background: linear-gradient(145deg, #5ac8fa, #287dc8); /* Gradient background for header */
            padding: 10px;
            margin-bottom: 15px;
            border-radius: 8px;
            color: white;
        }

        .modal-body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
        }

        .futuristic-list {
            list-style-type: none;
            padding-left: 0;
        }

            .futuristic-list li {
                position: relative;
                margin-bottom: 10px;
                padding-left: 20px;
            }

                .futuristic-list li:before {
                    content: '•';
                    position: absolute;
                    left: 0;
                    top: 0;
                    color: #5ac8fa; /* Glowing bullet points */
                    text-shadow: 0 0 5px #5ac8fa;
                }

                .futuristic-list li:hover {
                    color: #5ac8fa; /* Hover effect */
                    text-shadow: 0 0 5px #5ac8fa;
                }

        .close-btn {
            color: white;
            float: right;
            font-size: 28px;
            margin-left: 15px;
            cursor: pointer;
            transition: color 0.3s, text-shadow 0.3s;
        }

            .close-btn:hover {
                color: red;
                text-shadow: 0 0 5px #5ac8fa; /* Glowing effect on hover */
            }

        .hs-form-9535e8fc-88e8-43f6-b6e9-c06e15d584a2_4dcb79cf-c5fb-40ef-a3b4-02eb8c1f695d .hs-form-field label:not(.hs-error-msg) {
            color: #e0e0e0;
        }

        .cybereum-logo {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20%; /* Adjusted size */
            height: 20%; /* Adjusted size */
            transform: translate(-50%, -50%);
            z-index: 5;
        }
    </style>

    >
</head></html>

<body>
    <script charset="utf-8" src="//js.hsforms.net/forms/embed/v2.js" type="text/javascript"></script>
    <div class="dashboard-card futuristic-card" style="background: rgba(255, 255, 255, 0.03); border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 15px; margin: 20px 0; padding: 20px; box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);background-image: url('https://www.transparenttextures.com/patterns/space.png');background-color: rgba(0, 0, 0, 0.6);padding: 40px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; position: relative;">
        <div class="project-network-animation-enhanced" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; z-index: 0;">
            <canvas id="networkCanvasEnhanced"></canvas>
        </div>
        <div class="border-graphic-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;"></div>
        <div class="introduction-logo-container" style="text-align: center; margin-bottom: 20px;position: relative; z-index: 2;">
            <img alt="Cybereum Logo" src="https://cybereum.io/wp-content/uploads/2022/12/cropped-circle6.png" style="max-width: 120px; border-radius: 50%; box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);box-shadow: 0 0 40px #5ac8fa;" />
        </div>
        <div id="networkAnimationTooltip" style="position: absolute; display: none; padding: 5px 10px; background-color: rgba(0, 0, 0, 0.8); border-radius: 5px; color: #cdfaff; pointer-events: none; font-size: 14px; transition: opacity 0.3s; z-index: 999;"></div>
        <div id="connectionLabel" style="position: absolute; display: none; padding: 5px 10px; background-color: rgba(0, 0, 0, 0.8); border-radius: 5px; color: #cdfaff; pointer-events: none; font-size: 14px; transition: opacity 0.3s; z-index: 1000;"></div>
        <div class="block-header futuristic-header" style="background: rgba(0, 0, 0, 0.2); border-top-left-radius: 15px; border-top-right-radius: 15px; padding: 10px 20px; box-shadow: 0 0 10px #5ac8fa;position: relative; z-index: 2;">
            <h1 class="block-title text-white" style="text-shadow: 0 0 10px #5ac8fa;"><i class="fas fa-rocket"></i> Welcome to Cybereum - the Future of Project Management</h1>
        </div>
        <p class="futuristic-introduction" style="color: #cdfaff; font-size: 18px; margin-top: 20px; line-height: 1.6; text-align: center; padding: 0 10%; margin-bottom: 30px;position: relative; z-index: 2;max-width: 600px; text-align: center;">
            Dive deep into a world where data-driven decision-making and insights merge seamlessly.
            Harness the unmatched power of Cybereum's futuristic project analysis platform, a harmonious blend of advanced algorithms
            and intuitive design. Every piece of project data tells a story, and our tools are crafted meticulously to bring those stories to life.
            Embark on this transformative journey with us and redefine the boundaries of project management.

            The Cybereum platform offers not just ground-breaking tools; it  transcends traditional boundaries between companies and data,
            offering insights that are profound and ground breaking. Cybereum is here to revolutionize the way you
            perceive project management. So, are you ready to take a leap into the future?
        </p>
        <div class="introduction-graphic-container" style="text-align: center; margin-top: 30px;position: relative; z-index: 2;">
            <img alt="Futuristic Graphic" src="https://placeimg.com/500/500/tech" style="max-width: 100%; border-radius: 15px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);" />
        </div>
        <style>
            .block-title.text-white:hover {
                color: #5ac8fa; /* Change to the desired "lit up" color */
                text-shadow: 0 0 15px #5ac8fa; /* Adds a glow effect */
            }

            .project-network-animation-enhanced {
                position: relative;
                width: 80%;
                height: 80%;
                overflow: hidden;
                background-color: rgba(0, 0, 0, 0.2);
                border-radius: 10px;
            }

            #networkCanvasEnhanced {
                width: 100%;
                height: 100%;
            }

            #connectionLabel {
                position: absolute;
                display: none; /* Initially hidden */
                padding: 5px 10px;
                background-color: rgba(0, 0, 0, 0.8);
                border-radius: 5px;
                color: #cdfaff;
                pointer-events: none;
                font-size: 14px;
                transition: opacity 0.3s;
                z-index: 1000;
                transform-origin: center;
            }
        </style>
        <script>
            const canvasEnhanced = document.getElementById('networkCanvasEnhanced');
            const ctxEnhanced = canvasEnhanced.getContext('2d');
            //const nodeLabel = document.getElementById('nodeLabel');
            //const tooltipDiv = document.getElementById('networkAnimationTooltip');
            canvasEnhanced.width = canvasEnhanced.parentElement.offsetWidth;
            canvasEnhanced.height = canvasEnhanced.parentElement.offsetHeight;

            const phrases = [
                "Empower your projects with Cybereum's cutting-edge platform.",
                "Dive deep into data-driven decision-making.",
                "Harness the power of Cybereum's futuristic platform.",
                "Blend of advanced algorithms and intuitive design.",
                "ML for forecasting, AI for intelligence, DLT for collaboration.",
                "Every piece of data tells a story with Cybereum.",
                "Redefine the boundaries of project management.",
                "We offer experiences, not just tools.",
                "Revolutionize the way you perceive project management.",
                "Take a leap into the future with Cybereum.",
                "Experience the next-gen project analytics.",
                "Where innovation meets intuition.",
                "Your project's success, our priority.",
                "Elevate project management norms through Cybereum",
                "Strategic choices through data-driven insights.",
                "Leapfrog into the future with Cybereum at your side.",
                "Predictive analytics, intelligent AI, and collaborative DLT - Cybereum's trifecta."
            ];

            const connectionLabel = document.getElementById('connectionLabel');
            const synergyPhrases = [
                "Synergistic combination of AI & DLT",
                "DLT for collaboration",
                "AI for intelligence and assistance",
                "ML for forecasting",
                "Connecting project teams into a symbiotic organization"
            ];
            let lastPhraseIndex = -1;  // to keep track of last shown phrase

            class NodeEnhanced {
                constructor(x, y, phrase) {
                    this.x = x;
                    this.y = y;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.radius = Math.random() * 5 + 5;
                    this.color = 'rgba(205, 250, 255, 0.8)';
                    this.phrase = phrase;
                }

                draw() {
                    ctxEnhanced.beginPath();
                    ctxEnhanced.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctxEnhanced.fillStyle = this.color;
                    ctxEnhanced.fill();
                    ctxEnhanced.shadowColor = 'rgba(205, 250, 255, 1)';
                    ctxEnhanced.shadowBlur = 15;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x < 0 || this.x > canvasEnhanced.width) this.vx = -this.vx;
                    if (this.y < 0 || this.y > canvasEnhanced.height) this.vy = -this.vy;

                    this.draw();
                }
            }

            const nodesEnhanced = [];
            for (let i = 0; i < phrases.length; i++) {
                const x = Math.random() * canvasEnhanced.width;
                const y = Math.random() * canvasEnhanced.height;
                nodesEnhanced.push(new NodeEnhanced(x, y, phrases[i]));
            }

            canvasEnhanced.addEventListener('mousemove', (e) => {
                const tooltipDiv = document.getElementById('networkAnimationTooltip');
                const rect = canvasEnhanced.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                let closestNodes = [];
                nodesEnhanced.forEach(node => {
                    if (Math.pow(x - node.x, 2) + Math.pow(y - node.y, 2) < Math.pow(node.radius * 7, 2)) {
                        closestNodes.push(node);
                    }
                });

                if (closestNodes.length === 1) {
                    tooltipDiv.style.display = 'block';  // Make the tooltip visible
                    tooltipDiv.innerHTML = closestNodes[0].phrase;
                    tooltipDiv.style.left = `${closestNodes[0].x}px`;
                    tooltipDiv.style.top = `${closestNodes[0].y - 20}px`; // Above the node
                    tooltipDiv.style.transform = 'scale(1)';
                    tooltipDiv.style.opacity = '1';
                } else if (closestNodes.length >= 2) {
                    console.log('Two or more closest nodes found!');  // Debug line
                    const midX = (closestNodes[0].x + closestNodes[1].x) / 2;
                    const midY = (closestNodes[0].y + closestNodes[1].y) / 2;

                    lastPhraseIndex = (lastPhraseIndex + 1) % synergyPhrases.length;
                    connectionLabel.innerHTML = synergyPhrases[lastPhraseIndex];
                    connectionLabel.style.left = `${midX}px`;
                    connectionLabel.style.top = `${midY}px`;
                    connectionLabel.style.display = 'block';  // <-- Make sure you're setting display to block
                    connectionLabel.style.transform = 'scale(1)';
                    connectionLabel.style.opacity = '1';
                    connectionLabel.style.animation = 'fadeIn 0.5s ease-out';
                } else {
                    tooltipDiv.style.display = 'none';  // Hide the tooltip
                    connectionLabel.style.display = 'none';  // <-- Also hide the connectionLabel
                    connectionLabel.style.transform = 'scale(0)';
                    connectionLabel.style.opacity = '0';
                    tooltipDiv.style.transform = 'scale(0)';
                    tooltipDiv.style.opacity = '0';
                }
            });

            let connectionDivs = [];

            const maxConnections = nodesEnhanced.length * (nodesEnhanced.length - 1) / 2;
            const connectionPool = Array.from({ length: maxConnections }, (_, i) => {
                const div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.padding = '5px 10px';
                div.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                div.style.borderRadius = '5px';
                div.style.color = '#cdfaff';
                div.style.pointerEvents = 'none';
                div.style.fontSize = '14px';
                div.style.zIndex = '1000';
                div.style.display = 'none';
                document.querySelector('.project-network-animation-enhanced').appendChild(div);
                return div;
            });

            // Create a mapping to store a synergy phrase for each unique pair of nodes
            const nodePairToSynergyPhrase = new Map();

            function animateEnhanced() {
                ctxEnhanced.clearRect(0, 0, canvasEnhanced.width, canvasEnhanced.height);

                nodesEnhanced.forEach(node => {
                    node.update();
                });

                connectionLabel.style.display = 'none';  // Hide the connectionLabel by default

                for (let i = 0; i < nodesEnhanced.length; i++) {
                    for (let j = i + 1; j < nodesEnhanced.length; j++) {
                        const dx = nodesEnhanced[i].x - nodesEnhanced[j].x;
                        const dy = nodesEnhanced[i].y - nodesEnhanced[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < 150) {
                            ctxEnhanced.beginPath();
                            ctxEnhanced.moveTo(nodesEnhanced[i].x, nodesEnhanced[i].y);
                            ctxEnhanced.lineTo(nodesEnhanced[j].x, nodesEnhanced[j].y);
                            ctxEnhanced.strokeStyle = 'rgba(205, 250, 255, ' + (1 - distance / 150) + ')';
                            ctxEnhanced.lineWidth = 0.5;
                            ctxEnhanced.stroke();

                            // Show the connectionLabel between the nodes
                            const midX = (nodesEnhanced[i].x + nodesEnhanced[j].x) / 2;
                            const midY = (nodesEnhanced[i].y + nodesEnhanced[j].y) / 2;

                            // Create a unique identifier for each pair of nodes
                            const nodePairIdentifier = `${i}-${j}`;

                            // Assign a synergy phrase to each unique pair of nodes, if not already done
                            if (!nodePairToSynergyPhrase.has(nodePairIdentifier)) {
                                nodePairToSynergyPhrase.set(nodePairIdentifier, synergyPhrases[lastPhraseIndex]);
                                lastPhraseIndex = (lastPhraseIndex + 1) % synergyPhrases.length;
                            }

                            connectionLabel.innerHTML = nodePairToSynergyPhrase.get(nodePairIdentifier);
                            connectionLabel.style.left = `${midX}px`;
                            connectionLabel.style.top = `${midY}px`;
                            connectionLabel.style.display = 'block';  // Make sure you're setting display to block
                        }
                    }
                }

                requestAnimationFrame(animateEnhanced);
            }


            animateEnhanced();

            document.querySelector('.block-title.text-white').addEventListener('mouseover', function () {
                this.style.color = '#5ac8fa';  // Change to the desired "lit up" color
                this.style.textShadow = '0 0 15px #5ac8fa';  // Adds a glow effect
            });

            document.querySelector('.block-title.text-white').addEventListener('mouseout', function () {
                this.style.color = 'white';  // Resets to the original color
                this.style.textShadow = '0 0 10px #5ac8fa';  // Resets to the original shadow
            });</script>
    </div>
    <script charset="utf-8" src="//js.hsforms.net/forms/embed/v2.js" type="text/javascript"></script>
    <script>
        hbspt.forms.create({
            region: "na1",
            portalId: "20558785",
            formId: "9535e8fc-88e8-43f6-b6e9-c06e15d584a2"
        });</script>
    <div id="hubspot-form-container">
        <script>
            hbspt.forms.create({
                region: "na1",
                portalId: "20558785",
                formId: "9535e8fc-88e8-43f6-b6e9-c06e15d584a2"
            });</script>
    </div>
    <section class="dashboard-section introduction-section">
        <div class="project-selection-container">
            <!--
                <div class="megaproject-icon-container">
                    <div class="megaproject-icon">
                        <img alt="Cybereum Logo" class="cybereum-logo" src="https://cybereum.io/wp-content/uploads/2022/12/cropped-circle6.png" />
                        <svg fill="none" height="100" viewbox="0 0 100 100" width="100" xmlns="http://www.w3.org/2000/svg"> -->
            <!-- Outer Circle
                    <circle cx="50" cy="50" fill="none" r="48" stroke="#5ac8fa" stroke-width="2"></circle>
                    <!-- Rotating Lines
                    <line class="rotating-line" stroke="#b4f5ff" stroke-width="2" x1="50" x2="50" y1="2" y2="20"></line>
                    <line class="rotating-line" stroke="#b4f5ff" stroke-width="2" x1="50" x2="50" y1="98" y2="80"></line>
                    <line class="rotating-line" stroke="#b4f5ff" stroke-width="2" x1="2" x2="20" y1="50" y2="50"></line>
                    <line class="rotating-line" stroke="#b4f5ff" stroke-width="2" x1="98" x2="80" y1="50" y2="50"></line>
                    <!-- Central Node
                    <circle cx="50" cy="50" fill="#5ac8fa" r="10"></circle>
                    <!-- Pulsing Effects
                    <circle class="pulsing-circle" cx="50" cy="50" fill="none" r="15" stroke="#5ac8fa" stroke-width="2"></circle>
                    <circle class="pulsing-circle" cx="50" cy="50" fill="none" r="20" stroke="#5ac8fa" stroke-width="2"></circle>
                    </svg>
                </div>
                    </div>
                        -->
            <div class="project-dropdown-container">
                <label for="projectDropdown">Select Project Sector:</label>
                <select class="project-dropdown" id="projectDropdown">
                    <option value="Residential Construction">Residential Construction</option>
                    <option value="Commercial Construction">Commercial Construction</option>
                    <option value="Industrial Construction">Industrial Construction</option>
                    <option value="Highway Construction">Highway Construction</option>
                    <option value="Heavy Civil Construction">Heavy Civil Construction</option>
                    <option value="Offshore O&amp;G">Offshore O&amp;G</option>
                    <option value="Offshore Wind">Offshore Wind</option>
                    <option value="Refinery">Refinery</option>
                    <option value="Solar Farm">Solar Farm</option>
                    <option value="Railway">Railway</option>
                </select>
            </div>
            <div class="location-dropdown-container">
                <label for="locationDropdown">Select Location:</label>
                <select class="location-dropdown" id="locationDropdown">
                    <!-- Adding a few countries for illustration. In the actual code, you'll have all countries listed. -->
                    <option value="USA">USA</option>
                    <option value="Canada">Canada</option>
                    <option value="UK">UK</option>
                    <option value="Australia">Australia</option>
                    <option value="India">India</option>
                    <!-- ... and so on for all countries -->
                </select>
            </div>
        </div>
        <label class="custom-file-upload">


            <label class="upload-label" for="xmlFileInput" style="font-weight: bold; font-size: 16px; padding: 12px 25px; box-shadow: inset 0 0 15px rgba(42, 125, 200, 0.6);">
                Upload File
            </label>
            <input accept=".xml" id="xmlFileInput" name="file" style="display: none;" type="file" />
            <div class="sci-fi-loading-bar-container" style="width: 100%; margin-top: 10px; background: rgba(40, 125, 200, 0.3); border-radius: 8px;">
                <div class="sci-fi-loading-bar" style="background: linear-gradient(90deg, #287dc8, #5ac8fa); height: 5px; border-radius: 5px; transition: width 0.5s;"></div>
                <div class="sci-fi-loading-text" style="color: #5ac8fa; font-size: 14px; margin-top: 5px; font-weight: bold; transition: opacity 0.5s;">0%</div>
                <span class="uploading-text">Upload in progress...</span>
            </div>
        </label>
        <div id="data_div"></div>
    </section>

    <style>
        #networkViualization,
        #chart_div_wrapper,
        #riskTable,
        #referenceTable,
        #riskMatrix,
        #histogram,
        #pieChart,
        #pathsDistributionCurve,
        #radialChart,
        #sidebar,
        #dash1,
        #chart-container,
        #SCurve,
        #graph-container,
        #dash4,
        #RadialRisk,
        #Kanban,
        #reducedGraph {
            display: none; /* Initially hide the sections */
        }
    </style>


    <div class="dashboard-section" id="dash1">
        <div id="self-referencing-tasks-warning"><h1>Self Referencing Errors</h1></div>
    </div>
    <div class="dashboard-card" id="networkViualization">
        <h1>Interactive Project Task Map</h1>
        <button onclick="openModal('modal0')">More Information about Project NEtwork Visualization</button>
        <div class="control-panel">
            <div class="dashboard-stat">
                <label class="control-label">Zoom:</label>
                <button onclick="zoomIn()">+</button>
                <button onclick="zoomOut()">-</button>
                <input class="slider" id="zoomSlider" max="100" min="1" type="range" value="50" />
                <button onclick="zoomExtents()">Extents</button>
                <label class="control-label">Rotate:</label>
                <button onclick="rotate(10)">Right</button>
                <button onclick="rotate(-10)">Left</button>
            </div>
            <!-- Pan Controls -->
            <div class="dashboard-stat">
                <label class="control-label">Pan:</label>
                <div class="joystick">
                    <div class="arrow up" onclick="pan(0, -50)">↑</div>
                    <div class="arrow left" onclick="pan(-50, 0)">←</div>
                    <div class="center" onclick="center()">•</div>
                    <div class="arrow right" onclick="pan(50, 0)">→</div>
                    <div class="arrow down" onclick="pan(0, 50)">↓</div>
                </div>
            </div>
            <!-- Rotate Controls -->
            <!-- Node Color Legend -->
            <div class="dashboard-stat">
                <div id="legend">
                    <h3>Node Colors by <span id="legendMetric">In-degree</span>:</h3>
                    <label><input checked="" name="colorMetric" type="radio" value="inDegree" /> In-degree</label>
                    <label><input name="colorMetric" type="radio" value="outDegree" /> Out-degree</label>
                    <label><input name="colorMetric" type="radio" value="degree" /> Degree</label>
                    <div class="legend-item"><span class="color-box" style="background-color: #b4f5ff;"></span> &gt; 0</div>
                    <div class="legend-item"><span class="color-box" style="background-color: #8ce6ff;"></span> &gt; 1</div>
                    <div class="legend-item"><span class="color-box" style="background-color: #5ac8fa;"></span> &gt; 2</div>
                    <div class="legend-item"><span class="color-box" style="background-color: #46b9fa;"></span> &gt; 3</div>
                    <div class="legend-item"><span class="color-box" style="background-color: #41afeb;"></span> &gt; 4</div>
                </div>
            </div>
            <!-- Filter Controls -->
            <div class="dashboard-stat">
                <div class="= dashboard-card2">
                    <label class="control-label">Filter Nodes (in-degree):</label>
                    <span id="filterValue">&gt; 0</span>
                    <input class="slider" id="filterSlider" max="5" min="0" step="1" type="range" />
                </div>
                <div class="= dashboard-card2">
                    <div class="label-container">
                        <label class="control-label">Filter Nodes (out-degree):</label>
                        <span id="outDegreeFilterValue">&gt; 0</span>
                    </div>
                    <input class="slider" id="outDegreeFilterSlider" max="5" min="0" step="1" type="range" />
                </div>
                <div class="= dashboard-card2">
                    <div class="label-container">
                        <!-- New section for degree -->
                        <label class="control-label">Filter Nodes (degree):</label>
                        <span id="degreeFilterValue">&gt; 0</span>
                    </div>
                    <input class="slider" id="degreeFilterSlider" max="10" min="0" step="1" type="range" />
                </div>
            </div>
            <!-- Accordion for Path Details -->
            <div class="accordion" style="display: flex;">
                <button class="accordion-button">Critical Path</button>
                <div class="panel">
                    <p id="criticalPathDetails">Critical path details go here...</p>
                </div>
                <button class="accordion-button">Outlier Paths</button>
                <div class="panel">
                    <p id="outlierPathsDetails">Outlier paths details go here...</p>
                </div>
                <button class="accordion-button">All Paths</button>
                <div class="panel">
                    <p id="allPathsDetails">All paths details go here...</p>
                </div>
            </div>
        </div>
        <div class="control-panel">
            <!-- Search and Highlight Controls -->
            <div class="controls search-controls" style="width: 500px;">
                <input id="searchInput" placeholder="Search by name or ID" type="text" />
            </div>
            <div class="highlight-controls">
                <label><input id="highlightAllConnected" type="checkbox" /> Highlight All Connected Nodes</label>
            </div>
            <!-- Path Details Display -->
            <div id="pathsDisplay"></div>
            <div id="longestPathDisplay"></div>
            <div id="outlierPathsDisplay"></div>
            <div class="highlight-controls">
                <label><input id="highlightCriticalPath" type="checkbox" /> Highlight Critical Path</label>
                <label><input id="highlightOutliers" type="checkbox" /> Highlight Outlier Paths</label>
            </div>
            <!-- Info Panel -->
            <div id="infoPanel"></div>
        </div>
    </div>
    <div id="graph-container">
        <!-- Your other graph-related content here -->
        <div id="tooltip" style="position: absolute; visibility: hidden; background: #8ce6ff; padding: 8px; border: 2px solid #3292cd; border-radius: 3px; "></div>
        <svg>
            <defs>
                <marker id="arrow" markerheight="10" markerwidth="6" orient="auto" refx="9" refy="0" viewbox="0 -6 10 12">
                    <path d="M0,-5 L10,0 L0,5" fill="#cdfaff"></path>
                </marker>
                <marker id="arrow2" markerheight="10" markerunits="strokeWidth" markerwidth="10" orient="auto" refx="8" refy="3">
                    <path d="M0,0 L0,6 L9,3 z" fill="#0f0"></path>
                </marker>
            </defs>
            <g class="container"></g>
        </svg>
    </div>

    <div id="sidebar" style="z-index: 1000;">
        <button id="sidebarToggleBtn" onclick="toggleSidebar(event)">
            <svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path class="toggle-icon" d="M4 6h16l-8 -8Z"></path>
            </svg>
        </button>
        <h3>Menu</h3>
        <ul>
            <li><a href="#networkViualization">Network Visualization </a></li>
            <li><a href="#chart_div_wrapper">GANTT Chart</a></li>
            <li><a href="#riskTable">Risk Table</a></li>
            <li><a href="#referenceTable">Path Metrics</a></li>
            <li><a href="#riskMatrix">Risk Matrix</a></li>
            <li><a href="#histogram">Histogram</a></li>
            <li><a href="#pieChart">Pie Chart</a></li>
            <li><a href="#pathsDistributionCurve">Paths Distribution Curve</a></li>
            <li><a href="#radialChart">Radial Chart</a></li>
            <li><a href="#Kanban">Kanban Project Flow</a></li>
            <li><a href="#reducedGraph">Reduced Graph</a></li>
        </ul>
    </div>
    <div class="charts-container">
        <!-- Row for Risk Matrix -->
        <div class="charts-row">
            <div class="dashboard-card-full" id="dash4">

                <h2>Risk Matrix</h2>
                <style>
                    .legend {
                        display: flex;
                        align-items: center;
                        justify-content: space-between;
                    }

                    .scale {
                        width: 60px;
                        height: 20px;
                        border: 1px solid #000;
                        display: inline-block;
                    }

                    .low {
                        background: rgb(255, 255, 0);
                    }

                    .medium {
                        background: rgb(255, 128, 0);
                    }

                    .high {
                        background: rgb(255, 0, 0);
                    }

                    .legend-text {
                        color: #0d2137; /* Set the text color to white */
                        font-weight: bold; /* Made the text bold for better visibility */
                    }
                </style>
                <div class="risk-content">
                    <div class="charts-row">
                        <div class="dashboard-card2" id="chart-container">
                            <h2>Risk Matrix</h2>

                            <div class="legend">
                                <h4>Risk Importance Scale:</h4>
                                <div class="scale low">Low</div>
                                <div class="scale medium">Medium</div>
                                <div class="scale high">High</div>
                            </div>
                            <canvas height="280" id="riskMatrix" width="300"></canvas>
                            </br>
                            <button class="learn-more-btn" onclick="openModal('riskMatrixModal')">Learn More</button>
                        </div>
                        <div class="dashboard-card2" id="RadialRisk">
                            <h2>Radial Risk Chart</h2>
                            <canvas height="280" id="radialChart" width="300"></canvas>
                            </br>
                            <button class="learn-more-btn" onclick="openModal('radialChartModal')">Learn More</button>
                        </div>
                    </div>
                    <div class="table-container" id="pathMetrics">
                        <!-- Risk Table -->
                        <h2>Risk Table</h2>
                        <table class="sortable" id="riskTable">
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>Name</th>
                                    <th>Risk</th>
                                    <th>Importance</th>
                                    <th>Path</th> <!-- Column for Path -->
                                    <th>PageRank Centrality</th>
                                    <th>Start Date</th> <!-- New column for Start Date -->
                                    <th>End Date</th> <!-- New column for End Date -->
                                    <th>Slack</th>  <!--  slack -->
                                    <th>Overrun</th>
                                </tr>
                            </thead>
                            <tbody id="riskTableBody"></tbody>
                        </table>

                        <!-- Reference Table for Critical & Outlier Paths -->
                        <div class="table-container" id="referenceTable">
                            <h2>Critical & Outlier Paths</h2>
                            <table class="sortable">
                                <thead>
                                    <tr>
                                        <th>ID</th>
                                        <th>Name</th>
                                        <th>Path</th>
                                    </tr>
                                </thead>
                                <tbody id="referenceTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                    <div class="charts-row">
                        <div class="dashboard-card2" id="pathsDistributionCurve">
                            <h2>Paths Distribution Curve</h2>
                            <div id="path_distribution_chart" style="width: 300px; height: 280px;"></div>
                            </br>
                            <button class="learn-more-btn" onclick="openModal('pathsDistributionCurveModal')">Learn More</button>
                        </div>
                        <div class="dashboard-card2" id="pathDistributionCard">
                            <h2>Path Distribution Bar Chart</h2>
                            <canvas height="280" id="pathDistributionStackedBarChart" width="300"></canvas>
                            </br>
                            <button class="learn-more-btn" onclick="openModal('pathDistributionModal')">Learn More</button>
                        </div>
                    </div>
                    <div class="dashboard-card2" id="pathDistributionCard">
                        <h2>Expected Completion</h2>
                        <div id="progressBars"></div>
                    </div>
                    <!-- Paths Distribution Table -->
                    <div class="table-container" id="pathsDistributionTableContainer">
                        <h2>Paths Distribution</h2>
                        <table class="sortable" id="pathsDistributionTable">
                            <thead>
                                <tr>
                                </tr>
                            </thead>
                            <tbody id="pathsDistributionTableBody"></tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="charts-row">
        <div class="dashboard-card2" id="SCurve">
            <h2>S-Curve (Cumulative Distribution Chart)</h2>

            <div id="scurve_chart" style="width: 300px; height: 280px;"></div>
            </br>
            <button class="learn-more-btn" onclick="openModal('SCurveModal')">Learn More</button>
        </div>
        <div class="dashboard-card2" id="histogram">
            <h2>Task Duration Histogram</h2>
            <canvas height="280" id="histogramChart" width="300"></canvas>
            </br>
            <button class="learn-more-btn" onclick="openModal('histogramModal')">Learn More</button>
        </div>
        <div class="dashboard-card2" id="pieChart">
            <h2>Distribution of Task Types (Pie Chart)</h2>
            <div id="pie_chart" style="width: 300px; height: 280px;"></div>
            </br>
            <button class="learn-more-btn" onclick="openModal('pieChartModal')">Learn More</button>

        </div>
        <div class="dashboard-card2" id="pathsDistributionCurve">
            <h2>Paths Distribution Curve</h2>
            <div id="path_distribution_chart" style="width: 300px; height: 280px;"></div>
            </br>
            <button class="learn-more-btn" onclick="openModal('pathsDistributionCurveModal')">Learn More</button>
        </div>
        <div class="dashboard-card2" id="RadialRisk">
            <h2>Radial Risk Chart</h2>
            <canvas height="280" id="radialChart" width="300"></canvas>
            </br>
            <button class="learn-more-btn" onclick="openModal('radialChartModal')">Learn More</button>
        </div>
    </div>
    </div>

    <section id="Kanban">
        <!-- Date Range Slider -->
        <div class="date-slider-container">
            <input type="text" id="dateRangePicker" placeholder="Select Date Range...">
        </div>

        <div class="kanban-columns">

            <!-- Column 1: Planned -->
            <div class="kanban-column" id="plannedColumn">
                <h3 class="kanban-column-title">Planned</h3>
                <!-- Cards will be dynamically added here -->
            </div>

            <!-- Column 2: In Progress -->
            <div class="kanban-column" id="inProgressColumn">
                <h3 class="kanban-column-title">In Progress</h3>
                <!-- Cards will be dynamically added here -->
            </div>

            <!-- Column 3: Completed -->
            <div class="kanban-column" id="completedColumn">
                <h3 class="kanban-column-title">Completed</h3>
                <!-- Cards will be dynamically added here -->
            </div>

        </div>
    </section>

    <div class="dashboard-section" id="chart_div_wrapper">
        <h2>GANTT Chart</h2>
        <div id="chart_div"></div>
    </div>
    <div id="error_div"></div>

    <div class="dashboard-section" id="reducedGraph">
        <h1>Reduced Graph</h1>
        <!--
        <button id="clusterBtn">Cluster</button>
        <button id="declusterBtn">De-cluster</button>
        -->
        <div id="graph-container">
            <div id="tooltip" style="position: absolute; visibility: hidden; background: #8ce6ff; padding: 8px; border: 2px solid #3292cd; border-radius: 3px; "></div>
            <div id="path-list" style="position: absolute; top: 0; left: 0; max-height: 600px; overflow-y: auto;"></div>
            
            <div id="dependency_chart" style="width: 90%; height: 600px; margin-left: 10%;">Graph will be rendered here.</div>

        </div>
        <div id="configuration-container"></div>
    </div>
    <section class="dashboard-section banner-section"><div class="ran-inspired-banner" style="background: linear-gradient(to bottom, #ffff00, #ff0000); padding: 50px 0; text-align: center; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3); margin: 40px 0; border-radius: 20px; position: relative; overflow: hidden;"><canvas class="particle-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas><img alt="Cybereum Logo" src="https://cybereum.io/wp-content/uploads/2023/05/Red_Logo.png" style="width: 120px; margin-bottom: 20px; filter: drop-shadow(0 0 15px #fdfd96);" /><h1 style="color: #ffff00; font-size: 28px; margin-bottom: 15px; font-weight: bold; text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);">Cybereum: A Symphony of Data and Design</h1><p style="color: #ffff00; font-size: 20px; max-width: 900px; margin: 0 auto; text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.5);">Our platform combines traditional project management with cutting-edge innovation. Expereince and Manage your Projects.</p></div></section>
    <!-- Footer -->
    <div class="footer" style="background-color: rgba(0, 0, 0, 0.8); padding: 20px; color: #58a6ff; text-align: center;">
        <p>© 2023 Cybereum. All rights reserved.</p>
        <p>Powered by Advanced Algorithms, Intuitive Design, ML, AI, and DLT.</p>
    </div>
    <script>
        function toggleSidebar() {
            var sidebar = document.getElementById('sidebar');
            if (sidebar.classList.contains('collapsed')) {
                sidebar.classList.remove('collapsed');
            } else {
                sidebar.classList.add('collapsed');
            }
        }</script>
    <script>
        function toggleSidebar(event) {
            event.stopPropagation();  // Prevent event from propagating further

            var sidebar = document.getElementById('sidebar');
            var toggleBtn = document.getElementById('sidebarToggleBtn');
            if (sidebar.classList.contains('collapsed')) {
                sidebar.classList.remove('collapsed');
                toggleBtn.innerHTML = "≡";  /* Hamburger icon for expanded state */
            } else {
                sidebar.classList.add('collapsed');
                toggleBtn.innerHTML = "←";  /* Arrow icon for collapsed state */
            }
        }</script>
    <script>
        document.getElementById('xmlFileInput').addEventListener('change', function () {
            var fileName = this.files[0].name;
            this.setAttribute('data-content', 'Selected: ' + fileName);
        });</script>

    <script>
        document.getElementById("xmlFileInput").addEventListener("change", function () {
            if (this.files.length > 0) {
                // If a file is selected, show all the sections
                document.getElementById('networkViualization').style.display = 'block';
                document.getElementById('chart_div_wrapper').style.display = 'block';
                document.getElementById('riskTable').style.display = 'block';
                document.getElementById('referenceTable').style.display = 'block';
                document.getElementById('riskMatrix').style.display = 'block';
                document.getElementById('histogram').style.display = 'block';
                document.getElementById('pieChart').style.display = 'block';
                document.getElementById('pathsDistributionCurve').style.display = 'block';
                document.getElementById('radialChart').style.display = 'block';
                document.getElementById('reducedGraph').style.display = 'block';
                document.getElementById('dash1').style.display = 'block';
                document.getElementById('chart-container').style.display = 'block';
                document.getElementById('sidebar').style.display = 'block';
                document.getElementById('SCurve').style.display = 'block';
                document.getElementById('graph-container').style.display = 'block';
                document.getElementById('dash4').style.display = 'block';
                document.getElementById('Kanban').style.display = 'block';
                document.getElementById('RadialRisk').style.display = 'block';
            }
            //document.querySelector(".sci-fi-loading-text").innerText = "Loading...";
            // Simulate loading progression (this can be replaced with actual loading progression in the real environment)
            let progress = 0;
            document.querySelector('.uploading-text').style.display = 'inline-block';
            const interval = setInterval(() => {
                progress += 10;
                if (progress > 100) {
                    progress = 100;
                    clearInterval(interval);
                    document.querySelector(".sci-fi-loading-text").innerText = "";
                    document.querySelector('.uploading-text').style.display = 'none';
                }
                document.querySelector(".sci-fi-loading-bar").style.width = progress + "%";
            }, 500);
        });
    </script>
    <div id="modal0" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('modal0')">&times;</span>
            <h2 class="modal-header">Introduction:</h2>
            <div class="modal-body">
                <b>Features & Navigation:</b>
                <ul class="futuristic-list">
                    <li><b>Zoom & Pan:</b> Navigate across the expansive network with ease. Use the mouse wheel to zoom in or out and click-drag to pan.</li>
                    <li><b>Node Details:</b> Hover over nodes to see detailed insights. Click on them for a deeper dive.</li>
                    <li><b>Color-coded Paths:</b> Different paths, like 'Critical' or 'Outlier', are represented with distinct colors for better clarity.</li>
                    <li><b>Interactive Links:</b> The connections between nodes are as informative as the nodes themselves. Hover or click for more details.</li>
                    <li><b>Dynamic Layout:</b> Add, remove, or modify nodes and watch the network adjust in real-time.</li>
                </ul>
            </div>
        </div>
    </div>

    <div id="networkVisualizationModal" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('networkVisualizationModal')">&times;</span>
            <h2>Introduction:</h2>
            Dive deep into the interconnections of your project with Cybereum's Network Visualization. This interactive tool offers a graphical representation of nodes and their relationships, making complex data structures understandable at a glance.
            <br><br>
            <b>Features & Navigation:</b>
            <ul>
                <li><b>Zoom & Pan:</b> Navigate across the expansive network with ease. Use the mouse wheel to zoom in or out and click-drag to pan.</li>
                <li><b>Node Details:</b> Hover over nodes to see detailed insights. Click on them for a deeper dive.</li>
                <li><b>Color-coded Paths:</b> Different paths, like 'Critical' or 'Outlier', are represented with distinct colors for better clarity.</li>
                <li><b>Interactive Links:</b> The connections between nodes are as informative as the nodes themselves. Hover or click for more details.</li>
                <li><b>Dynamic Layout:</b> Add, remove, or modify nodes and watch the network adjust in real-time.</li>
            </ul>
        </div>
    </div>

    <div id="ganttChartModal" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('ganttChartModal')">&times;</span>
            <h2>GANTT Chart: A Timeline of Progress</h2>
            Track project milestones and task progress with the GANTT Chart. This horizontal bar chart gives you a visual timeline of when each task starts, its duration, and when it concludes.
            <br><br>
            <b>Features & Navigation:</b>
            <ul>
                <li><b>Resizable Bars:</b> Adjust task durations by dragging the edges of the bars.</li>
                <li><b>Dependencies:</b> See how tasks are interlinked with arrows. A delay in one task impacts dependent tasks.</li>
                <li><b>Hover Insights:</b> For a quick summary of task details, just hover over its bar.</li>
                <li><b>Color-coded Status:</b> Tasks are color-coded based on their progress or status, making it easy to identify pending, ongoing, or completed tasks.</li>
            </ul>
        </div>
    </div>

    <div id="riskMatrixModal" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('riskMatrixModal')">&times;</span>
            <h2>Risk Matrix: Evaluating Potential Pitfalls</h2>
            The Risk Matrix helps assess and prioritize risks based on their potential impact and likelihood. Understand which risks require immediate attention and which can be monitored over time.
            <br><br>
            <b>Features & Navigation:</b>
            <ul>
                <li><b>Quadrant View:</b> Risks are plotted on a 2D matrix, categorizing them into four quadrants based on severity and occurrence probability.</li>
                <li><b>Interactive Points:</b> Hover over points to see detailed risk descriptions.</li>
                <li><b>Color Indicators:</b> High-priority risks are marked distinctly for quick identification.</li>
                <li><b>Adjustable Axes:</b> Customize the matrix's axes to suit your risk evaluation criteria.</li>
            </ul>
        </div>
    </div>

    <div id="histogramModal" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('histogramModal')">&times;</span>
            <h2>Histogram: Data Distribution Insights</h2>
            The Histogram offers a visual representation of the frequency distribution of your data. It helps you understand where most of your data points lie and identify any outliers.
            <br><br>
            <b>Features & Navigation:</b>
            <ul>
                <li><b>Bins:</b> The x-axis represents data ranges, while the y-axis shows the frequency of data points within those ranges.</li>
                <li><b>Interactive Bars:</b> Hover over bars for exact counts.</li>
                <li><b>Customizable Ranges:</b> Adjust the bin width to analyze data distribution at varying levels of granularity.</li>
            </ul>
        </div>
    </div>

    <div id="pieChartModal" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('pieChartModal')">&times;</span>
            <h2>Pie Chart: A Slice of Your Data</h2>
            The Pie Chart provides a circular statistical graphic divided into slices to illustrate numerical proportions. It's a visual treat that also offers deep data insights.
            <br><br>
            <b>Features & Navigation:</b>
            <ul>
                <li><b>Segmented View:</b> Each segment represents a category, and its size is proportional to its value.</li>
                <li><b>Hover Insights:</b> For detailed percentages and values, hover over slices.</li>
                <li><b>Color-coded Categories:</b> Each category gets a unique color for easy differentiation.</li>
            </ul>
        </div>
    </div>

    <div id="pathsDistributionCurveModal" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('pathsDistributionCurveModal')">&times;</span>
            <h2>Paths Distribution Curve: Understanding Path Frequencies</h2>
            The Paths Distribution Curve visualizes how often different paths are taken within your project. It aids in identifying common routes and anomalies.
            <br><br>
            <b>Features & Navigation:</b>
            <ul>
                <li><b>Area Under Curve:</b> The shaded region helps understand path frequencies at a glance.</li>
                <li><b>Interactive Points:</b> Hover over specific points on the curve for detailed insights.</li>
                <li><b>Customizable Axes:</b> Adjust axis scales to focus on specific sections of the distribution.</li>
            </ul>
        </div>
    </div>

    <div id="radialChartModal" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('radialChartModal')">&times;</span>
            <h2>Radial Chart: A 360° View of Your Data</h2>
            The Radial Chart, or Circular Bar Chart, offers a unique twist to traditional bar charts. Data categories are represented in a circular fashion, providing a comprehensive view of your metrics.
            <br><br>
            <b>Features & Navigation:</b>
            <ul>
                <li><b>Circular Bars:</b> Each bar's length is proportional to its value.</li>
                <li><b>Hover Details:</b> Hover over bars for specific data insights.</li>
                <li><b>Segmented Categories:</b> Each category is distinctly color-coded.</li>
            </ul>
        </div>
    </div>

    <div id="reducedGraphModal" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('reducedGraphModal')">&times;</span>
            <h2>Reduced Graph: A Simplified Network View</h2>
            When networks become overwhelmingly complex, the Reduced Graph comes into play. It offers a simplified view, focusing on key nodes and connections.
            <br><br>
            <b>Features & Navigation:</b>
            <ul>
                <li><b>Key Nodes:</b> Only the most significant nodes are displayed.</li>
                <li><b>Simplified Connections:</b> Redundant or non-critical links are omitted for clarity.</li>
                <li><b>Interactive Elements:</b> As with the full Network Visualization, you can zoom, pan, and click for detailed insights.</li>
            </ul>
        </div>
    </div>


    <div id="SCurveModal" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('SCurveModal')">&times;</span>
            <h2>S Curve: Cumulative Distribution</h2>
            When networks become overwhelmingly complex, the Reduced Graph comes into play. It offers a simplified view, focusing on key nodes and connections.
            <br><br>
            <b>Features & Navigation:</b>
            <ul>
                <li><b>Key Nodes:</b> Only the most significant nodes are displayed.</li>
                <li><b>Simplified Connections:</b> Redundant or non-critical links are omitted for clarity.</li>
                <li><b>Interactive Elements:</b> As with the full Network Visualization, you can zoom, pan, and click for detailed insights.</li>
            </ul>
        </div>
    </div>

    <div id="pathDistributionModal" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('pathDistributionModal')">&times;</span>
            <h2>Path Distribution Bar Chart: Visualizing Path Durations</h2>
            The Path Distribution Bar Chart showcases the number of paths based on their durations. It aids in understanding the most frequent path durations and their respective counts within the network.
            <br><br>
            <b>Features & Navigation:</b>
            <ul>
                <li><b>Duration Bins:</b> The x-axis showcases various path durations, while the y-axis displays the count of paths for each duration.</li>
                <li><b>Interactive Bars:</b> Hover over bars to get the exact count of paths for specific durations.</li>
                <li><b>Cumulative Line Overlay:</b> A line overlaying the bars shows the cumulative count of paths, aiding in understanding the growth in path counts as duration increases.</li>
            </ul>
        </div>
    </div>

    <div id="riskMatrixModal" class="futuristic-modal">
        <div class="futuristic-modal-content">
            <span class="close-btn" onclick="closeModal('riskMatrixModal')">&times;</span>
            <h2>Risk Matrix: Evaluating Risk Impact vs. Likelihood</h2>
            The Risk Matrix is a critical tool for risk assessment. By plotting risks based on their impact and likelihood, it helps in prioritizing and strategizing risk management efforts.
            <br><br>
            <b>Features & Navigation:</b>
            <ul>
                <li><b>Risk Importance Scale:</b> Risks are color-coded based on their importance. Shades of red, yellow, and green signify high, medium, and low risks respectively.</li>
                <li><b>Interactive Cells:</b> Hover over specific cells in the matrix to get detailed insights on the number of risks and their descriptions.</li>
                <li><b>Grid Layout:</b> The matrix is divided into a grid where the x-axis represents risk likelihood and the y-axis showcases risk impact.</li>
            </ul>
        </div>
    </div>

    <script>
        // Function to open a modal
        function openModal(modalId) {
            document.getElementById(modalId).style.display = "block";
        }

        // Function to close a modal
        function closeModal(modalId) {
            document.getElementById(modalId).style.display = "none";
        }

        // Closing modal if clicked outside the modal content
        window.onclick = function(event) {
            if (event.target.classList.contains('futuristic-modal')) {
                event.target.style.display = "none";
            }
        }
    </script>
</body>
