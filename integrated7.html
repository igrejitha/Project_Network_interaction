<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8" />
    <meta content="width=device-width, initial-scale=1.0" name="viewport" />
    <title>Interactive Project Task Map</title>
    <!-- D3.js -->
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <!-- Google Charts -->
    <script src="https://www.gstatic.com/charts/loader.js" type="text/javascript"></script>
    <script src="https://d3js.org/d3.v6.min.js"></script>
    <title>Gantt Chart</title>
    <script src="https://www.gstatic.com/charts/loader.js" type="text/javascript"></script>
    <script src="https://kryogenix.org/code/browser/sorttable/sorttable.js"></script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <!-- Scripts for Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/moment.js/2.29.1/moment.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-moment@1.0.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.7.1/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link href="https://unpkg.com/vis-network@7.6.2/dist/vis-network.min.css" rel="stylesheet" type="text/css" />
    <script src="https://unpkg.com/vis-network@7.6.2/dist/vis-network.min.js" type="text/javascript"></script>
    <!-- <link href="css/style.css" rel="stylesheet"/> -->
    <!-- <link href="css/site.css" rel="stylesheet"/> -->
     <link rel="stylesheet" href="css/general.css"> 
    <link href="img/Blue_Logo.png" rel="stylesheet"/>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.css" type="text/css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vis/4.21.0/vis.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">


    <!-- Include the Materialize CSS library -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>

    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-doughnutlabel@0.1.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.5.1"></script>

    <!-- Include Flatpickr CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">

    <!-- Include Flatpickr JS -->
    <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
    <script>
        const centerTextPlugin = {
            afterDraw: (chart) => {
                let width = chart.chart.width,
                    height = chart.chart.height,
                    ctx = chart.chart.ctx;

                ctx.restore();
                let fontSize = (height / 114).toFixed(2);
                ctx.font = fontSize + "em Orbitron";
                ctx.textBaseline = "middle";

                let sum = chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                let text = `Total: ${sum} days`,
                    textX = Math.round((width - ctx.measureText(text).width) / 2),
                    textY = height / 2;

                ctx.fillText(text, textX, textY);
                ctx.save();
            }
        };
        Chart.plugins.register(centerTextPlugin);

    </script>
   
    <script type="text/javascript">
        google.charts.load('current', { 'packages': ['gantt'] });
        google.charts.setOnLoadCallback(initFileInput);

        function initFileInput() {
            var fileInput = document.getElementById('xmlFileInput');
            fileInput.addEventListener('change', handleFileSelect, false);
        }

        function clearPreviousData() {
            // Clear the data table
            document.getElementById('data_div').innerHTML = '';

            // Clear Graphs and Charts
            document.getElementById('graph-container').innerHTML = '<div id="tooltip" style="position: absolute; visibility: hidden; background: #8ce6ff; padding: 8px; border: 2px solid #3292cd; border-radius: 3px; "></div><svg><defs><marker id="arrow" viewBox="0 -6 10 12" refX="9" refY="0" markerWidth="6" markerHeight="10" orient="auto"><path d="M0,-5 L10,0 L0,5" fill="#cdfaff" /></marker><marker id="arrow2" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto" markerUnits="strokeWidth"><path d="M0,0 L0,6 L9,3 z" fill="#0f0" /></marker></defs><g class="container"></g></svg>';
            document.getElementById('chart_div').innerHTML = '';
            document.getElementById('scurve_chart').innerHTML = '';
            document.getElementById('histogramChart').getContext('2d').clearRect(0, 0, 300, 280);  // Clearing canvas for histogram
            document.getElementById('pie_chart').innerHTML = '';
            document.getElementById('path_distribution_chart').innerHTML = '';
            document.getElementById('dependency_chart').innerHTML = '';

            // Clear Error Messages
            document.getElementById('error_div').innerText = '';

            // Clearing Control Values
            document.getElementById('searchInput').value = '';
            document.getElementById('highlightAllConnected').checked = false;
            document.getElementById('highlightCriticalPath').checked = false;
            document.getElementById('highlightOutliers').checked = false;

            // Reset sliders
            document.getElementById('zoomSlider').value = 50;
            document.getElementById('filterSlider').value = 0;
            document.getElementById('outDegreeFilterSlider').value = 0;
            document.getElementById('degreeFilterSlider').value = 0;

            // Clear Path Details
            document.getElementById('criticalPathDetails').innerText = 'Critical path details go here...';
            document.getElementById('outlierPathsDetails').innerText = 'Outlier paths details go here...';
            document.getElementById('allPathsDetails').innerText = 'All paths details go here...';
        }

        var nodes = [];
        var links = [];
        function clearGraphData() {
            nodes.length = 0;  // Clear the array without losing reference
            links.length = 0;
        }

        function handleFileSelect(event) {
            clearPreviousData();  // Clearing the DOM
            clearGraphData();     // Clearing the data structures
            var file = event.target.files[0];
            console.log("Selected file: ", file);
            if (file) {
                var reader = new FileReader();
                reader.onload = function (e) {
                    var contents = e.target.result;
                    var parser = new DOMParser();
                    var xmlDoc = parser.parseFromString(contents, "text/xml");
                    console.log("Parsed XML: ", xmlDoc);
                    drawChart(xmlDoc);
                };
                reader.readAsText(file);
            } else {
                console.error("Failed to load file");
            }
        }
        /**
         * Draws the data table.
         * @param {Object} data - The Google visualization DataTable.
         */
        function drawDataTable(data) {
            // Create the table and set its class.
            var table = document.createElement('table');
            table.className = 'dashboard-table';

            // Create the table header and body elements.
            var thead = document.createElement('thead');
            var tbody = document.createElement('tbody');

            // Add column names to the table header.
            var headerRow = document.createElement('tr');
            for (var i = 0; i < data.getNumberOfColumns(); i++) {
                var th = document.createElement('th');
                th.innerText = data.getColumnLabel(i);
                headerRow.appendChild(th);
            }
            thead.appendChild(headerRow);
            table.appendChild(thead);
            table.appendChild(tbody);

            // Clear previous contents of the data_div and append the new table.
            var dataDiv = document.getElementById('data_div');
            dataDiv.innerHTML = '';
            dataDiv.appendChild(table);

            // Use event delegation to handle cell editing.
            table.addEventListener('input', function (e) {
                if (e.target.tagName.toLowerCase() === 'td') {
                    var cell = e.target;
                    var newValue = cell.innerText;
                    var row = cell.parentNode.rowIndex - 1;
                    var col = cell.cellIndex;

                    // Validate the newValue based on its column
                    if (!validateCellValue(col, newValue)) {
                        // If invalid, revert the cell's value and show an error
                        cell.innerText = data.getFormattedValue(row, col);
                        displayError("Invalid input. Please try again.");
                        return;
                    }

                    // If valid, update the data model and redraw the charts
                    data.setCell(row, col, newValue);
                    var graphData = parseXML(xmlDocGlobal, data);
                    drawGanttChart(data);
                    //drawGraph(graphData.nodes, graphData.links);
                }
            });

            function validateCellValue(col, value) {
                switch (col) {
                    case 0: // Task ID
                        return /^\d+$/.test(value);
                    case 3: // Start Date
                    case 4: // End Date
                        return !isNaN(new Date(value).getTime());
                    case 5: // Duration
                        return !isNaN(value) && parseFloat(value) >= 0;
                    case 6: // Percent Complete
                        var percent = parseFloat(value);
                        return !isNaN(percent) && percent >= 0 && percent <= 100;
                    case 7: // Dependencies
                        // Check if all dependencies are positive integers
                        return value.split(',').every(dep => /^\d+$/.test(dep.trim()));
                    default:
                        return true;
                }
            }

            function displayError(message) {
                // Assuming there's a <div> with id 'error-message' to display errors
                var errorDiv = document.getElementById('error_div');
                errorDiv.innerText = message;
                errorDiv.style.display = 'block';
                setTimeout(() => {
                    errorDiv.style.display = 'none';
                }, 5000); // Hide the error message after 5 seconds
            }

            var maxTaskDuration = 0;
            for (var i = 0; i < data.getNumberOfRows(); i++) {
                var taskDuration = data.getValue(i, data.getColumnIndex('Duration'));
                maxTaskDuration = Math.max(maxTaskDuration, taskDuration);
            }

            // Populate the table body with data from the Google DataTable.
            for (var i = 0; i < data.getNumberOfRows(); i++) {
                var dataRow = document.createElement('tr');
                for (var j = 0; j < data.getNumberOfColumns(); j++) {
                    var td = document.createElement('td');
                    if (j === data.getColumnIndex('Progress Bar')) {
                        var taskDuration = data.getValue(i, data.getColumnIndex('Duration'));
                        var barLengthPercentage = (taskDuration / maxTaskDuration) * 100;
                        td.innerHTML = `
                                                            <div class="progress-bar-container" style="width: 100%;">
                                                                <div class="progress-bar" style="width: ${barLengthPercentage}%;">
                                                                    <div class="progress-bar-fill" style="width: 0%;"></div>
                                                                </div>
                                                            </div>`;
                    } else {
                        td.innerText = data.getFormattedValue(i, j);
                        td.contentEditable = 'true';
                    }
                    dataRow.appendChild(td);
                }
                tbody.appendChild(dataRow);
            }

            // Make the table sortable.
            sorttable.makeSortable(table);
        }

        function drawChart(xmlDoc) {
            console.log("Drawing chart with data: ", xmlDoc);
            var data = new google.visualization.DataTable();
            data.addColumn('string', 'Task ID');
            data.addColumn('string', 'Task Name');
            data.addColumn('string', 'Resource');
            data.addColumn('date', 'Start Date');
            data.addColumn('date', 'End Date');
            data.addColumn('number', 'Duration');
            data.addColumn('number', 'Percent Complete');
            data.addColumn('string', 'Dependencies');
            data.addColumn('number', 'Progress Bar');

            try {
                parseXML(xmlDoc, data);
                var dataJSON = data.toJSON();
                //document.getElementById('data_div').innerText = "DataTable in JSON format: \n" + dataJSON;
                drawDataTable(data);
                drawGanttChart(data);
                console.log('Nodes2')
                console.log("About to call drawGraph")

                var graphData = parseXML(xmlDoc, data);

                console.log('Nodes to the Charts', graphData.nodes)
                console.log('Links to the Charts', graphData.links)
                //drawCharts(graphData.nodes, graphData.links);
                console.log('Links to the Graph', graphData.links)
                drawGraph(graphData.nodes, graphData.links);
                // Now, call the chart functions with the parsed nodes and links

            } catch (err) {
                console.error("Error while parsing the XML data: ", err);
                document.getElementById('error_div').innerText = "Error: " + err.message;
            }
        }

        function insertStartMilestone(data, nodes, taskIDs, date) {
            if (!taskIDs['0']) {
                date.setHours(0, 0, 0, 0);
                data.addRow(['0', 'Start Milestone', '', date, date, 0, 100, null, null]);
                taskIDs['0'] = true;
                nodes.push({ ID: '0', Name: 'Start Milestone', Duration: '0', Start: date.toISOString(), Finish: date.toISOString() }); // Add the Start Node to the nodes array
            }
        }

        function insertEndMilestone(endMilestoneID, data, nodes, taskIDs, date, tasksWithoutSuccessors) {
            var milestoneID = endMilestoneID.toString();
            console.log('endMilestoneID: ', endMilestoneID)
            if (!taskIDs[milestoneID]) {
                date.setHours(23, 59, 59, 999);  // Set the time to the end of the day
                // Convert tasksWithoutSuccessors array to a comma-separated string to use as dependencies
                var dependencies = tasksWithoutSuccessors.join(", ");
                //data.addRow([milestoneID, 'End Milestone', '', date, date, 0, 0, null]);
                data.addRow([milestoneID, 'End Milestone', '', date, date, 0, 0, dependencies, null]);
                taskIDs[milestoneID] = true;
                //nodes.push({ ID: milestoneID, Name: 'End Milestone', Duration: '0'; Start: date.toISOString(), Finish: date.toISOString() }); // Add the End Node to the nodes array
                //EndMilestone_Date = date.toISOString();
                var EndMilestone_Date = date;
                console.log("CHART_DEBUG EndMilestone_Date", EndMilestone_Date);
            }
        }

        /**
         * Parses the XML to extract task data and dependencies.
         * @param {Object} xmlDoc - The XML document.
         * @param {Object} data - The Google visualization DataTable.
         */
        function parseXML(xmlDoc, data) {
            console.log("parseXML called");
            var projectTitle = '';
            var projectDuration = '';

            // Store the XML data for future use
            xmlDocGlobal = xmlDoc;
            var root = xmlDoc.documentElement;
            console.log("Root element: ", root.nodeName);

            var minStartDate = new Date(2100, 0, 1); // a future date
            var maxEndDate = new Date(1900, 0, 1);   // a past date

            var tasks = xmlDoc.getElementsByTagName("Task");
            console.log("Number of tasks: ", tasks.length);

            var taskIDs = {}; // To keep track of task IDs
            var taskUIDtoID = {}; // To map UIDs to IDs
            var idIncrementRequired = false; //if there is a Task IDs with '0' it coincides theh our start node and all IDs must be incremented
            var selfReferencingTasks = [];

            // Initialize nodes and links arrays for the graph
            console.log("Initialize nodes and links arrays for the graph")
            var nodes = [];
            var links = [];

            var Sum_nodes = [];
            var Sum_links = [];

            // Initialize dependencyGraph and checkedTasks
            var dependencyGraph = {};
            var checkedTasks = {};

            var minDate = null;  // To keep track of the minimum start date

            var parsedTasks = [];

            // First pass to extract task IDs and UIDs
            var tasksData = [];
            for (var i = 0; i < tasks.length; i++) {
                // Initialize tasksData array to store task details
                //var parsedTask = parseTask(tasks[i], data, taskUIDtoID, idIncrementRequired, selfReferencingTasks);

                //tasksData.push(parsedTask);
                var uidElement = tasks[i].getElementsByTagName("UID")[0];
                var idElement = tasks[i].getElementsByTagName("ID")[0];

                if (uidElement && idElement) {
                    var uid = uidElement.childNodes[0].nodeValue.trim();
                    var id = idElement.childNodes[0].nodeValue.trim();
                    taskUIDtoID[uid] = id;
                    if (id === '0') {
                        idIncrementRequired = true;
                    }
                }
            }
            console.log('Log the taskUIDtoID', taskUIDtoID); // Log the taskUIDtoID
            console.log('Log the taskUIDtoID'); // Log the taskUIDtoID

            if (idIncrementRequired) {
                for (var uid in taskUIDtoID) {
                    taskUIDtoID[uid] = (parseInt(taskUIDtoID[uid], 10) + 1).toString();
                }
            }

            // Find minimum date
            for (var i = 0; i < tasks.length; i++) {
                var startDateNode = tasks[i].getElementsByTagName("Start")[0];
                if (startDateNode) {
                    var startDateText = startDateNode.childNodes[0].nodeValue.trim();
                    var startDate = new Date(startDateText);  // Parse the date string
                    if (!minDate || startDate < minDate) {
                        minDate = startDate;
                    }
                }
            }

            insertStartMilestone(data, nodes, taskIDs, minDate); // Insert Start Milestone after finding the minimum date.

            //Determine the Maximum ID:
            var maxID = -1;
            var maxEndDate = new Date(0); // This is set to the earliest possible date for initialization
            var secondMaxEndDate = new Date(0); // This will store the second maximum end date

            for (var i = 0; i < tasks.length; i++) {
                var taskIDElement = tasks[i].getElementsByTagName("ID")[0];
                if (taskIDElement && taskIDElement.childNodes[0]) {
                    var taskID = parseInt(taskIDElement.childNodes[0].nodeValue.trim(), 10);
                    if (idIncrementRequired) {
                        taskID += 1;
                    }
                    maxID = Math.max(maxID, taskID);
                }

                var taskFinishElement = tasks[i].getElementsByTagName("Finish")[0];
                if (taskFinishElement && taskFinishElement.childNodes[0]) {
                    var taskFinishDate = new Date(taskFinishElement.childNodes[0].nodeValue.trim());
                    if (taskFinishDate > maxEndDate) {
                        secondMaxEndDate = maxEndDate;
                        maxEndDate = taskFinishDate;
                    } else if (taskFinishDate > secondMaxEndDate) {
                        secondMaxEndDate = taskFinishDate;
                    }
                }
            }

            //Create the End Milestone:
            var endMilestoneID = maxID + 1;
            //nodes.push({ ID: endMilestoneID, Name: 'End Milestone', Duration: '0', Start: secondMaxEndDate, Finish: maxEndDate });
            console.log("CHART_DEBUG EndMilestone_Date", endMilestoneID, "Start: ", secondMaxEndDate, "Finish: ", maxEndDate);

            //nodes.push({ ID: endMilestoneID, Name: 'End Milestone', Duration: '0', Start: EndMilestone_Date, Finish: EndMilestone_Date });
            //console.log("CHART_DEBUG EndMilestone_Date2");
            //data.addRow([endMilestoneID, 'End Milestone', '', 'someStartDate', 'someEndDate', null, 100, null]);

            var projectTitle = "";
            var projectDuration = "";
            // Second pass to parse the tasks
            var successorCounts = {};
            for (var i = 0; i < tasks.length; i++) {
                var task = tasks[i];

                var outlineLevelElement = task.getElementsByTagName("OutlineLevel")[0];
                var summaryElement = task.getElementsByTagName("Summary")[0];
                var OutlineNumberElement = task.getElementsByTagName("OutlineNumber")[0];
                var MilestoneElement = task.getElementsByTagName("Milestone")[0];
                console.log("MilestoneElement", outlineLevelElement, summaryElement, OutlineNumberElement, MilestoneElement);

                var parsedTask = parseTask(tasks[i], data, taskUIDtoID, idIncrementRequired, selfReferencingTasks, minDate, maxEndDate);
                parsedTasks.push(parsedTask);

                var taskID = parsedTask.taskID;
                var taskName = task.getElementsByTagName("Name")[0].childNodes[0].nodeValue.trim();
                var startDate = task.getElementsByTagName("Start")[0].childNodes[0].nodeValue.trim();
                var endDate = task.getElementsByTagName("Finish")[0].childNodes[0].nodeValue.trim();
                var duration = parsedTask.duration;
                // Extracting "Percentage Complete" and "Time Units"
                var percentCompleteNode = task.getElementsByTagName("PercentComplete")[0];
                var percentComplete = percentCompleteNode ? percentCompleteNode.childNodes[0].nodeValue.trim() : "0";

                var timeUnitsNode = task.getElementsByTagName("TimeUnits")[0]; // Assuming the XML tag is "TimeUnits"
                var timeUnits = timeUnitsNode ? timeUnitsNode.childNodes[0].nodeValue.trim() : "Hours"; // Defaulting to "Hours" if not found

                // Update minStartDate and maxEndDate
                var parsedStartDate = new Date(startDate);
                // If endDate is missing or invalid
                if (!endDate || new Date(endDate) == "Invalid Date") {
                    switch (timeUnits) {
                        case "Hours":
                            parsedEndDate = new Date(parsedStartDate);
                            parsedEndDate.setHours(parsedEndDate.getHours() + parseInt(duration));
                            break;
                        case "Days":
                            parsedEndDate = new Date(parsedStartDate);
                            parsedEndDate.setDate(parsedEndDate.getDate() + parseInt(duration));
                            break;
                        // ... handle other time units similarly if needed
                        default:
                            parsedEndDate = new Date(parsedStartDate); // default behavior if timeUnits is unrecognized
                    }
                } else {
                    parsedEndDate = new Date(endDate);
                }
                if (parsedStartDate < minStartDate) {
                    minStartDate = parsedStartDate;
                }
                if (parsedEndDate > maxEndDate) {
                    maxEndDate = parsedEndDate;
                }
                if (MilestoneElement && MilestoneElement.childNodes[0].nodeValue.trim() === "0") {
                    Milestone_Val = 0;
                }
                if (MilestoneElement && MilestoneElement.childNodes[0].nodeValue.trim() === "1") {
                    Milestone_Val = 1;
                }


                // Check if the OutlineLevel is 0
                if (outlineLevelElement && outlineLevelElement.childNodes[0].nodeValue.trim() === "0") {
                    var taskNameElement = task.getElementsByTagName("Name")[0];
                    var durationElement = task.getElementsByTagName("Duration")[0];

                    // Store the name and duration in the global variables
                    projectTitle = taskNameElement ? taskNameElement.childNodes[0].nodeValue.trim() : "";
                    projectDuration = durationElement ? durationElement.childNodes[0].nodeValue.trim() : "";
                    console.log("Project Title: ", projectTitle, projectDuration);
                    nodes.push({
                        projectTitle: projectTitle,
                        projectDuration: projectDuration,
                        ID: taskID,
                        Name: taskName,
                        Duration: 0,
                        Start: startDate,
                        Finish: endDate,
                        PercentComplete: percentComplete,
                        Milestone: Milestone_Val,
                        TimeUnits: timeUnits
                    });
                    //continue;  // Skip this iteration and move to the next task
                }
                else if (summaryElement && summaryElement.childNodes[0].nodeValue.trim() === "1") {
                    Sum_nodes.push({
                        ID: taskID,
                        Name: taskName,
                        outline_duration: duration,
                        Duration: duration,
                        Start: startDate,
                        Finish: endDate,
                        PercentComplete: percentComplete,
                        Milestone: Milestone_Val,
                        TimeUnits: timeUnits
                    });
                    nodes.push({
                        ID: taskID,
                        Name: taskName,
                        outline_duration: duration,
                        Duration: "0",
                        Start: startDate,
                        Finish: endDate,
                        PercentComplete: percentComplete,
                        Milestone: Milestone_Val,
                        TimeUnits: timeUnits
                    });
                }
                else {
                    nodes.push({
                        ID: taskID,
                        Name: taskName,
                        Duration: duration,
                        Start: startDate,
                        Finish: endDate,
                        PercentComplete: percentComplete,
                        Milestone: Milestone_Val,
                        TimeUnits: timeUnits
                    });
                    //console.log("Project Title: AAAA", taskID);
                }

                // Add the task to the nodes array
                //nodes.push({ UID: taskID, Name: taskName, Start: startDate, Finish: endDate });

                console.log('CHART_DEBUG Nodes', nodes)

                taskIDs[taskID] = true;
                var dependenciesNodeList = tasks[i].getElementsByTagName("PredecessorLink");

                for (var j = 0; j < dependenciesNodeList.length; j++) {
                    var predecessorUIDNode = dependenciesNodeList[j].getElementsByTagName("PredecessorUID")[0];
                    if (predecessorUIDNode) {
                        var dependencyUID = predecessorUIDNode.childNodes[0].nodeValue.trim();
                        var dependency = taskUIDtoID[dependencyUID];
                        var dependencyID = taskUIDtoID[dependencyUID];
                        // Log the values being used
                        console.log("Dependency UID:", dependencyUID);
                        console.log("Mapped Dependency ID (source):", dependencyID);
                        console.log("Task ID (target):", taskID);
                        console.log("Task duration:", duration);

                        links.push({ source: dependencyID, target: taskID, duration: duration });
                        if (!(taskID in dependencyGraph)) {
                            dependencyGraph[taskID] = [];
                        }
                        dependencyGraph[taskID].push(dependency);
                    }
                }
                // Check if the task has no predecessors
                if (dependenciesNodeList.length === 0) {
                    // Link the task with no predecessors to the Start Milestone (ID 0)
                    if (outlineLevelElement && outlineLevelElement.childNodes[0].nodeValue.trim() === "0") {
                        //var taskNameElement = task.getElementsByTagName("Name")[0];
                        //var durationElement = task.getElementsByTagName("Duration")[0];

                        // Store the name and duration in the global variables
                        //projectTitle = taskNameElement ? taskNameElement.childNodes[0].nodeValue.trim() : "";
                        //projectDuration = durationElement ? durationElement.childNodes[0].nodeValue.trim() : "";
                        console.log("Project Title: links ", taskID, duration.toString());
                        links.push({ source: '0', target: taskID, duration: "0", outline_duration: duration.toString() });
                    }
                    else if (summaryElement && summaryElement.childNodes[0].nodeValue.trim() === "1") {
                        console.log("Project Title: summaryElement ", taskName, taskID, duration.toString());
                        Sum_links.push({ source: '0', target: taskID, duration: duration.toString(), outline_duration: duration.toString() });
                        links.push({ source: '0', target: taskID, duration: "0", outline_duration: duration.toString() });
                    }
                    else {
                        console.log("Project Title: links ", taskID, duration.toString());
                        links.push({ source: '0', target: taskID, duration: duration.toString() });
                    }
                    //links.push({ source: '0', target: taskID, duration: duration.toString() });
                }

                // Initialize successor counts
                successorCounts[taskID] = 0;

            }

            // Increment successor counts
            for (var i = 0; i < tasks.length; i++) {
                //var task = tasks[i];
                //var parsedTask = parseTask(tasks[i], data, taskUIDtoID, idIncrementRequired, selfReferencingTasks);
                var taskID = parsedTask.taskID;
                var dependenciesNodeList = tasks[i].getElementsByTagName("PredecessorLink");
                for (var j = 0; j < dependenciesNodeList.length; j++) {
                    var predecessorUIDNode = dependenciesNodeList[j].getElementsByTagName("PredecessorUID")[0];
                    if (predecessorUIDNode) {
                        var dependencyUID = predecessorUIDNode.childNodes[0].nodeValue.trim();
                        var dependencyID = taskUIDtoID[dependencyUID];
                        // Increment successor count for each predecessor
                        successorCounts[dependencyID]++;
                    }
                }
            }

            // Connect Tasks Without Successors
            var tasksWithoutSuccessors = [];
            for (var taskID in successorCounts) {
                if (successorCounts[taskID] === 0) {
                    links.push({ source: taskID, target: endMilestoneID, duration: duration });
                    tasksWithoutSuccessors.push(taskID);
                }
            }
            //print the name and dates and duration of the end milestone to the console from its node properties. the end milestone is the one with the largest ID
            console.log("CHART_DEBUG EndMilestoneeeeeeeeeeeee", nodes[nodes.length - 1].ID, nodes[nodes.length - 1].Name, nodes[nodes.length - 1].Start, nodes[nodes.length - 1].Finish, nodes[nodes.length - 1].Duration);
            console.log("CHART_DEBUG EndMilestone_Date", endMilestoneID, "Start: ", secondMaxEndDate, "Finish: ", maxEndDate);
            //nodes.push({ ID: endMilestoneID, Name: 'End Milestone', Duration: '0', Start: secondMaxEndDate, Finish: maxEndDate });
            nodes.push({
                ID: endMilestoneID,
                Name: 'End Milestone',
                //outline_duration: duration,
                Duration: "0",
                Start: secondMaxEndDate,
                Finish: maxEndDate,
                PercentComplete: 0,
                Milestone: 1,
                //pageRank: 0,
                TimeUnits: timeUnits
            });

            console.log('Links', links);
            // Insert Start and End Milestones
            //insertStartMilestone(data, nodes, taskIDs, minStartDate);
            insertEndMilestone(endMilestoneID, data, nodes, taskIDs, maxEndDate, tasksWithoutSuccessors);

            // Third pass to check for invalid dependencies
            for (var i = 0; i < tasks.length; i++) {
                checkDependencies(tasks[i], taskIDs, taskUIDtoID, dependencyGraph);
            }

            // After constructing the entire dependency graph
            try {
                checkCycles(dependencyGraph);
            } catch (error) {
                console.error(error);
            }


            if (selfReferencingTasks.length > 0) {
                var warningMessage = "Self-referencing tasks found with IDs: " + selfReferencingTasks.join(", ");
                console.warn(warningMessage);
                document.getElementById('self-referencing-tasks-warning').innerText = warningMessage;
            }

            return { nodes: nodes, links: links, selfReferencingTasks: selfReferencingTasks, tasksData: tasksData };

        }


        function checkDependencies(task, taskIDs, taskUIDtoID, dependencyGraph) {
            var taskIDElement = task.getElementsByTagName("ID")[0];
            var taskID = taskIDElement.childNodes[0].nodeValue.trim();
            var dependencies = dependencyGraph[taskID] || [];
            for (var i = 0; i < dependencies.length; i++) {
                var dependency = dependencies[i];
                if (!taskIDs[dependency]) {
                    throw new Error("Invalid task dependency ID: " + dependency + " in task with ID: " + taskID);

                }
            }
        }

        function detectCycle(graph, startNode, visited, recursionStack) {
            visited[startNode] = true;
            recursionStack[startNode] = true;

            var neighbors = graph[startNode];
            if (neighbors) {
                for (var i = 0; i < neighbors.length; i++) {
                    var neighbor = neighbors[i];

                    if (!visited[neighbor]) {
                        if (detectCycle(graph, neighbor, visited, recursionStack)) {
                            return true;
                        }
                    } else if (recursionStack[neighbor]) {
                        // if the neighbor node is visited and it's in the recursion stack, then it's a cycle
                        return true;
                    }
                }
            }

            recursionStack[startNode] = false; // remove the node from the recursion stack before returning
            return false;
        }

        function checkCycles(graph) {
            var visited = {};
            var recursionStack = {};

            function detectCycle(graph, startNode) {
                visited[startNode] = true;
                recursionStack[startNode] = true;

                var neighbors = graph[startNode];
                if (neighbors) {
                    for (var i = 0; i < neighbors.length; i++) {
                        var neighbor = neighbors[i];

                        if (!visited[neighbor]) {
                            if (detectCycle(graph, neighbor)) {
                                return true;
                            }
                        } else if (recursionStack[neighbor]) {
                            // if the neighbor node is visited and it's in the recursion stack, then it's a cycle
                            console.error("Cycle detected involving tasks with IDs: " + startNode + " and " + neighbor);
                            // Removing the cycle-causing dependency:
                            var index = graph[startNode].indexOf(neighbor);
                            if (index > -1) {
                                graph[startNode].splice(index, 1);
                            }
                            return false; // Remove the cycle but continue checking
                        }
                    }
                }

                recursionStack[startNode] = false; // remove the node from the recursion stack before returning
                return false;
            }

            for (var node in graph) {
                if (!visited[node]) {
                    detectCycle(graph, node);
                }
            }
        }

        function parseTask(task, data, taskUIDtoID, idIncrementRequired, selfReferencingTasks, minDate, maxEndDate) {
            console.log("parseTask called");

            // Extract the data from the XML task element, with checks for missing elements

            var taskIDElement = task.getElementsByTagName("ID")[0];
            var taskNameElement = task.getElementsByTagName("Name")[0];
            var startDateElement = task.getElementsByTagName("Start")[0];
            var endDateElement = task.getElementsByTagName("Finish")[0];
            var durationElement = task.getElementsByTagName("Duration")[0];

            if (!taskIDElement || !taskNameElement || !startDateElement || !endDateElement || !durationElement) {
                throw new Error("Task element missing one or more expected child elements");
            }

            var taskID = taskIDElement.childNodes[0].nodeValue.trim();
            if (idIncrementRequired) {
                taskID = String(Number(taskID) + 1);
            }
            console.log("Task ID: ", taskID);


            var taskName = taskNameElement.childNodes[0].nodeValue.trim();
            console.log("Task Name: ", taskName);

            var startDateString = startDateElement.childNodes[0].nodeValue.trim();
            console.log("Start Date: ", startDateString);

            var endDateString = endDateElement.childNodes[0].nodeValue.trim();
            console.log("End Date: ", endDateString);

            var durationString = durationElement.childNodes[0].nodeValue.trim();
            console.log("Duration: ", durationString);

            // If PercentComplete element is missing, set it to "0"
            var percentCompleteElement = task.getElementsByTagName("PercentComplete")[0];
            var percentCompleteString = percentCompleteElement ? percentCompleteElement.childNodes[0].nodeValue.trim() : "0";
            console.log("Percent Complete: ", percentCompleteString);

            // When parsing dependencies, convert PredecessorUID into the corresponding ID
            var dependenciesNodeList = task.getElementsByTagName("PredecessorLink");
            var dependencies = [];

            for (var i = 0; i < dependenciesNodeList.length; i++) {
                var predecessorUIDNode = dependenciesNodeList[i].getElementsByTagName("PredecessorUID")[0];

                if (predecessorUIDNode) {
                    var uid = predecessorUIDNode.childNodes[0].nodeValue.trim();
                    if (taskUIDtoID[uid]) {
                        dependencies.push(taskUIDtoID[uid]);
                    }
                }
            }

            var dependenciesString = dependencies.length > 0 ? dependencies.join(",") : "None";
            console.log("Dependencies: ", dependenciesString);


            // Instead of throwing an error for invalid task ID, just log it and return
            if (isNaN(parseFloat(taskID))) {
                console.error("Invalid task ID value.");
                return;
            }

            // Validate date strings match expected format (yyyy-mm-dd or yyyy-mm-ddThh:mm:ss)
            var dateRegexShort = /^\d{4}-\d{2}-\d{2}$/;
            var dateRegexLong = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}$/;
            if (startDateString.length === 10 && !dateRegexShort.test(startDateString) ||
                startDateString.length === 19 && !dateRegexLong.test(startDateString) ||
                endDateString.length === 10 && !dateRegexShort.test(endDateString) ||
                endDateString.length === 19 && !dateRegexLong.test(endDateString)) {
                throw new Error("Invalid date format in task with ID: " + taskID);

            }

            // Create dates from strings, and add error checking.
            var startDate = new Date(startDateString);
            var endDate = new Date(endDateString);

            // Check if dates are valid
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                console.error("Invalid task date format for taskID: " + taskID);
                return;
            }

            // Remove time portion of date if exists
            if (startDateString.length === 19) {
                startDate.setHours(0, 0, 0, 0);
            }
            if (endDateString.length === 19) {
                endDate.setHours(0, 0, 0, 0);
            }

            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                throw new Error("Invalid task date format.");
            }

            // Handle invalid duration values
            var duration;
            if (durationString.startsWith('PT')) {
                // Parse ISO 8601 duration format (PTxxHxxMxxS)
                var match = durationString.match(/PT(\d+H)?(\d+M)?(\d+S)?/);
                var hours = match[1] ? parseInt(match[1].slice(0, -1)) : 0;
                var minutes = match[2] ? parseInt(match[2].slice(0, -1)) : 0;
                var seconds = match[3] ? parseInt(match[3].slice(0, -1)) : 0;
                duration = hours + minutes / 60 + seconds / 3600;
            } else {
                duration = parseFloat(durationString);
            }
            if (isNaN(duration) || duration < 0) {
                console.error("Invalid task duration value for task with ID: " + taskID);
                return;
            }

            // Validate percent complete value, and handle invalid values.
            var percentComplete = parseFloat(percentCompleteString);
            if (isNaN(percentComplete) || percentComplete < 0 || percentComplete > 100) {
                console.error("Invalid task percent complete value for task with ID: " + taskID);
                return;
            }

            // Check the validity of dependency IDs and handle invalid values
            for (var i = 0; i < dependencies.length; i++) {
                if (isNaN(parseFloat(dependencies[i]))) {
                    throw new Error("Invalid task dependencies format.");
                }
            }

            // Handle empty/missing dependency values
            if (dependencies.length === 0) {
                dependenciesString = "0";  // Here the startMilestoneID should be "0";
            } else {
                // Adjust dependencies array based on the incremented task IDs
                dependencies = dependencies.map(dependency => {
                    if (dependency === "0") {
                        return "1";
                    } else {
                        //return String(parseInt(dependency) + 1);
                        return String(parseInt(dependency) + 0);
                    }
                });

                // Convert dependencies array to a string with comma separated values
                dependenciesString = dependencies.join(",");
            }

            // Handle empty/missing dependency values and self-referencing tasks
            var hasOtherDependencies = false;
            for (var i = 0; i < dependencies.length; i++) {
                if (dependencies[i] === taskID) {
                    console.warn("Task with ID: " + taskID + " has itself as a dependency. Removing the self-referencing dependency.");
                    selfReferencingTasks.push(taskID);
                } else {
                    hasOtherDependencies = true;
                }
            }
            if (dependencies.length === 0 || (!hasOtherDependencies && dependencies.includes(taskID))) {
                dependenciesString = "0";  // Default to the startMilestoneID if no valid dependencies
            } else {
                dependenciesString = dependencies.join(",");
            }

            // Add parsed task data to the DataTable.
            //console.log("Row: ", taskID, taskName, '', startDate, endDate, duration, percentComplete, dependenciesString);
            var maxEndDateObj = new Date(maxEndDate);
            var minDateObj = new Date(minDate);
            var endDateObj = new Date(endDate);
            var startDateObj = new Date(startDate);

            var totalDuration = (maxEndDateObj - minDateObj) / (1000 * 60 * 60 * 24);
            var taskDuration = (endDateObj - startDateObj) / (1000 * 60 * 60 * 24);

            var barWidthPercentage = totalDuration !== 0 ? (taskDuration / totalDuration) * 100 : 0;

            var progressBar = '<div class="progress-bar-container"><div class="progress-bar" style="width: ' + barWidthPercentage + '%;"></div></div>';

            //data.addRow([taskID, taskName, resource, taskStartDate, taskEndDate, taskDuration, percentComplete, dependencies, progressBar]);
            try {
                data.addRow([taskID, taskName, '', startDate, endDate, duration, percentComplete, dependenciesString, barWidthPercentage]);

            } catch (err) {
                console.error("Error adding row to DataTable for taskID: " + taskID);
                console.error(err.message);
                return;
            }

            return {
                taskID: taskID,
                duration: duration,
                taskName: taskName,
                startDate: startDate,
                endDate: endDate
            };
            // Return the task ID

        }
        function drawGanttChart(data) {
            console.log("drawGanttChart called");
            try {
                var numRows = data.getNumberOfRows();
                var height = numRows * 30 + 80;
                var options = {
                    height: height,
                    backgroundColor: '#cdfaff',
                    gantt: {
                        trackHeight: 30,
                        barCornerRadius: 5,
                        criticalPathEnabled: true,
                        criticalPathStyle: {
                            stroke: '#1e69aa',
                            strokeWidth: 2
                        },
                        labelStyle: {
                            fontName: 'Orbitron',  // Futuristic font
                            fontSize: 14,
                            color: '#113464' // Dark blue text
                        },
                        barHeight: 25,
                        percentEnabled: false,
                        shadowEnabled: true,
                        arrow: {
                            angle: 90,  // Make links less curvy
                            width: 2,
                            color: '#195a8c',
                            length: 10
                        },
                        defaultStartDate: null,
                        palette: [
                            {
                                color: {
                                    linearGradient: { x0: 0, y0: 0, x1: 0, y1: 1 },
                                    colorStops: [{ offset: 0, color: '#3292cd' }, { offset: 1, color: '#287dc8' }]
                                },
                                dark: '#113464',
                                stroke: '#195a8c',
                                strokeWidth: 2
                            }
                        ],
                        gridlines: {
                            color: '#3292cd'
                        },
                        minorGridlines: {
                            color: '#287dc8',
                            count: 15
                        },
                        labelMaxWidth: 300, // Increase if labels are long
                        labelTextStyle: {
                            fontName: 'Orbitron',
                            fontSize: 14,
                            color: '#113464'
                        },
                        tooltip: {
                            isHtml: true
                        }
                    },
                    chartArea: {
                        backgroundColor: '#cdfaff'
                    },
                    hAxis: {
                        textStyle: {
                            fontName: 'Orbitron',
                            color: '#1e69aa'
                        },
                        gridlines: {
                            color: '#287dc8'
                        }
                    },
                    vAxis: {
                        textStyle: {
                            fontName: 'Orbitron',
                            color: '#1e69aa'
                        }
                    }
                };
                var chart = new google.visualization.Gantt(document.getElementById('chart_div'));
                chart.draw(data, options);
            } catch (err) {
                console.error(err);
            }
        }
        // Completion of all computations and renderings
        updateProgressBar(100);
        document.querySelector(".sci-fi-loading-text").innerText = "";
    </script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
        google.charts.load('current', { 'packages': ['corechart'] });
        google.charts.setOnLoadCallback(initializeDataAndDrawCharts);
        var currentRotation = 0;

        function drawGraph(nodes, links) {
            console.log("drawGraph has been called");
            console.log("drawGraph called: Nodes", nodes);
            console.log("drawGraph called: Links", links);

            // Find start and end nodes
            var startNode = nodes.find(node => node.ID === "0"); // Assuming ID is a string
            var endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);
            console.log("End Node: ", endNode);

            // Find all paths from startNode to endNode
            console.log("Links array:", links);
            console.log("Links from start node:", links.filter(link => link.source === startNode || link.target === startNode));
            var paths = findAllPaths(startNode, endNode, links, nodes);
            console.log("All paths:", paths);


            // Create the SVG container
            var svg = d3.select("svg"),
                container = d3.select(".container"),
                dashboardCard = document.querySelector(".dashboard-card"),
                width = dashboardCard.clientWidth,
                height = dashboardCard.clientHeight;
            svg.attr("width", width).attr("height", height);


            console.log("SVG container: ", svg);
            console.log("Container: ", container);

            // Responsive Design
            window.addEventListener("resize", function () {
                var dashboardCard = document.querySelector(".dashboard-card");
                width = dashboardCard.clientWidth;
                height = dashboardCard.clientHeight;
                svg.attr("width", width).attr("height", height);
            });

            // Initialize in-degree to 0 for each node
            nodes.forEach(function (node) {
                node.inDegree = 0;
                node.outDegree = 0;  // New initialization for out-degree
            });


            // Calculate the in-degree for each node
            links.forEach(function (link) {
                var targetNode = nodes.find(function (node) { return node.ID === link.target; });
                targetNode.inDegree++;
            });

            // Calculate the out-degree for each node
            links.forEach(function (link) {
                var sourceNode = nodes.find(function (node) { return node.ID === link.source; });
                sourceNode.outDegree++;
            });

            // Calculate the degree for each node
            nodes.forEach(function (node) {
                node.degree = node.inDegree + node.outDegree;
            });

            drawCharts(nodes, links);

            // Filtering
            function updateNodeVisibility() {
                var inDegreeThreshold = parseInt(document.getElementById("filterSlider").value);
                var outDegreeThreshold = parseInt(document.getElementById("outDegreeFilterSlider").value);
                var degreeThreshold = parseInt(document.getElementById("degreeFilterSlider").value);
                var riskThreshold = parseFloat(document.getElementById("riskFilterSlider").value);
                var importanceThreshold = parseFloat(document.getElementById("importanceFilterSlider").value);

                node.style("visibility", function (d) {
                    return (d.inDegree >= inDegreeThreshold && d.outDegree >= outDegreeThreshold && d.degree >= degreeThreshold && d.riskScore >= riskThreshold && d.importanceScore >= importanceThreshold) ? "visible" : "hidden";
                });
            }

            var filterSlider = document.getElementById("filterSlider");
            var filterValue = document.getElementById("filterValue");

            filterSlider.addEventListener("input", function () {
                var threshold = parseInt(this.value);
                filterValue.innerHTML = "> " + threshold;
                updateNodeVisibility(); // Use the unified function here
            });
            var outDegreeFilterSlider = document.getElementById("outDegreeFilterSlider");
            var outDegreeFilterValue = document.getElementById("outDegreeFilterValue");

            // Out-degree filter
            outDegreeFilterSlider.addEventListener("input", function () {
                var threshold = parseInt(this.value);
                outDegreeFilterValue.innerHTML = "> " + threshold;
                updateNodeVisibility(); // And here
            });

            var degreeFilterSlider = document.getElementById("degreeFilterSlider");
            var degreeFilterValue = document.getElementById("degreeFilterValue");

            // Degree filter (corrected)
            degreeFilterSlider.addEventListener("input", function () {
                var threshold = parseInt(this.value);
                degreeFilterValue.innerHTML = "> " + threshold;
                updateNodeVisibility(); // And here
            });

            var riskFilterSlider = document.getElementById("riskFilterSlider");
            var riskFilterValue = document.getElementById("riskFilterValue");

            riskFilterSlider.addEventListener("input", function () {
                var threshold = parseFloat(this.value);
                riskFilterValue.innerHTML = "> " + threshold.toFixed(1);
                updateNodeVisibility();
            });

            var importanceFilterSlider = document.getElementById("importanceFilterSlider");
            var importanceFilterValue = document.getElementById("importanceFilterValue");

            importanceFilterSlider.addEventListener("input", function () {
                var threshold = parseFloat(this.value);
                importanceFilterValue.innerHTML = "> " + threshold.toFixed(1);
                updateNodeVisibility();
            });

            // Search Functionality
            document.getElementById("searchInput").addEventListener("input", function () {
                var query = this.value.toLowerCase();
                node.attr("stroke", function (d) {
                    return (d.Name.toLowerCase().includes(query) || d.ID === query) ? "red" : "none";
                });
            });

            window.rotate = function (angle) {
                currentRotation += angle;
                container.attr("transform", "rotate(" + currentRotation + "," + (width / 2) + "," + (height / 2) + ")");
            };


            // Zoom and pan behavior
            var zoom = d3.zoom().scaleExtent([0.1, 4])
                .translateExtent([[-width, -height], [2 * width, 3 * height]])
                .on("zoom", function () { container.attr("transform", d3.event.transform); });
            svg.call(zoom); // Change container to svg

            // Define zoom functions inside drawGraph
            window.zoomIn = function () {
                zoom.scaleBy(svg.transition().duration(750), 1.2);
            }

            window.zoomOut = function () {
                zoom.scaleBy(svg.transition().duration(750), 0.8);
            }

            window.pan = function (dx, dy) {
                var currentTransform = d3.zoomTransform(svg.node());
                var newX = currentTransform.x + dx;
                var newY = currentTransform.y + dy;

                zoom.transform(svg.transition().duration(750), d3.zoomIdentity.translate(newX, newY));
            };

            window.center = function () {
                let x = width / 2;
                let y = height / 2;
                zoom.translateTo(svg.transition().duration(750), x, y);
            }

            function updateNodeColors() {
                d3.selectAll(".node")  // Select all nodes
                    .attr("fill", function (d) {
                        var selectedMetric = document.querySelector('input[name="colorMetric"]:checked').value;
                        var metricValue;
                        console.log("Colors", "Selected Metric: ", selectedMetric)
                        switch (selectedMetric) {
                            case "inDegree":
                                metricValue = d.inDegree;
                                break;
                            case "outDegree":
                                metricValue = d.outDegree;
                                break;
                            case "degree":
                                metricValue = d.degree;
                                break;
                            case "risk":
                                metricValue = d.riskScore;
                                break;
                            case "importance":
                                metricValue = d.importanceScore;
                                break;
                            default:
                                metricValue = d.inDegree;
                        }
                        console.log("Colors", "Metric Value: ", metricValue)
                        if (selectedMetric === "risk") {
                            console.log("Colors", "Color: risk importance");
                            switch (true) {
                                case metricValue > 0.2: return "red";
                                case metricValue > 0.1: return "orange";
                                case metricValue > 0.5: return "yellow";
                                case metricValue > 0.025: return "yellowgreen";
                                default: return "green";
                            }
                        } else if (selectedMetric === "importance") {
                            console.log("Colors", "Color: risk importance");
                            switch (true) {
                                case metricValue > 0.5: return "red";
                                case metricValue > 0.3: return "orange";
                                case metricValue > 0.2: return "yellow";
                                case metricValue > 0.1: return "yellowgreen";
                                default: return "green";
                            }
                        } else {
                            console.log("Colors", "Color: degree")
                            switch (true) {
                                case metricValue > 4: return "#41afeb";
                                case metricValue > 3: return "#46b9fa";
                                case metricValue > 2: return "#5ac8fa";
                                case metricValue > 1: return "#8ce6ff";
                                default: return "#b4f5ff";
                            }
                        }
                        console.log("Colors", "Color: ")
                    });
            }

            document.querySelectorAll('input[name="colorMetric"]').forEach(function (radio) {
                radio.addEventListener('change', function () {
                    // Uncheck the "highlightCriticalPath" and "highlightOutliers" checkboxes
                    document.getElementById("highlightCriticalPath").checked = false;
                    document.getElementById("highlightOutliers").checked = false;
                    console.log("highlightCriticalPath unchecked");
                    clearHighlights(link, node);
                    hideTooltip();
                    // Call the function to update node colors
                    updateNodeColors();
                });
            });

            // Create the tooltip element
            var tooltip = d3.select("#graph-container").append("div")
                .attr("class", "tooltip")
                .style("opacity", 0);

            // Simulation setup
            var simulation = d3.forceSimulation(nodes)
                //.force("link", d3.forceLink(links).id(function (d) { return d.UID; })) //UID instead of ID
                //.force("link", d3.forceLink(links).id(function (d) { return d.ID; })) //ID instead of UID
                .force("link", d3.forceLink(links)
                    .id(function (d) { return d.ID; }) //ID instead of UID
                    .distance(function (d) { return d.duration; })) // Using 'duration' property for distance
                .force("charge", d3.forceManyBody().strength(-400))
                .force("center", d3.forceCenter(width / 2, height / 2));

            // Draw links (edges) with arrows
            var link = container.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("class", "link")
                .attr("stroke-width", 2)
                .attr("marker-end", "url(#arrow)");


            console.log("Link: ", link);

            link.on("mouseover", function (d) {
                // Make the link thicker
                d3.select(this)
                    .style("stroke", "white")
                    .attr("stroke-width", 10);  // Increase the width to make it thicker

                // Enlarge the source node
                node.filter(n => n.ID === d.source.ID)
                    .select("circle")
                    .attr("r", function (d) {
                        return 40 + d.inDegree * 0.5; // Increase the base radius value
                    });

                // Enlarge the target node
                node.filter(n => n.ID === d.target.ID)
                    .select("circle")
                    .attr("r", function (d) {
                        return 40 + d.inDegree * 0.5;  // Increase the base radius value
                    })
                    .style("fill", "#113464");

                // Show tooltip with duration
                tooltip.transition().duration(200).style("opacity", .9);
                tooltip.html("Duration: " + d.duration)
                    .style("left", (d3.event.pageX + 10) + "px")
                    .style("top", (d3.event.pageY - 28) + "px");
            })
                .on("mouseout", function (d) {
                    // Restore the link to its original thickness
                    d3.select(this)
                        .style("stroke", "#cdfaff")
                        .attr("stroke-width", 2); // Restore to original width

                    // Restore the source node size
                    node.filter(n => n.ID === d.source.ID)
                        .select("circle")
                        .attr("r", function (d) {
                            return 20 + d.inDegree * 0.5; // Restore the original size
                        });

                    // Restore the target node size and color
                    node.filter(n => n.ID === d.target.ID)
                        .select("circle")
                        .attr("r", function (d) {
                            return 20 + d.inDegree * 0.5; // Restore the original size
                        })
                        .style("fill", function (d) {
                            return updateNodeColors(d);
                        });

                    // Hide tooltip
                    tooltip.transition().duration(500).style("opacity", 0);
                });

            // Draw nodes
            var node = container.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .enter().append("g");

            // Append circles
            node.append("circle")
                .attr("class", "node")
                .style("stroke", "#1e69aa ")
                .attr("r", function (d) {
                    if (d.Milestone === 1) {
                        return 30 + d.inDegree * 0.5;  // A larger radius for milestone nodes
                    }
                    return 20 + d.inDegree * 0.5; // Base radius is 10, and each additional link increases the radius by 5
                })
                .attr("fill", function (d) {
                    //if (d.Milestone === 1) {
                    //    return "#FFD700";  // Gold color for milestones
                    //}
                    return updateNodeColors(d);
                })
                .on("mouseover", function (d) {
                    // Check if user wants to highlight all connected nodes
                    var highlightAllConnected = document.getElementById("highlightAllConnected").checked;
                    var highlightCriticalPath = document.getElementById("highlightCriticalPath").checked;
                    var highlightOutliers = document.getElementById("highlightOutliers").checked;
                    // Check the status of the radio button
                    var selectedMetric = document.querySelector('input[name="colorMetric"]:checked').value;

                    d3.select(this)
                        .interrupt()  // <-- interrupt any ongoing transitions
                        .transition()
                        .duration(200)
                        .attr("r", 50)
                        .style("stroke", "red")
                        .style("stroke-width", "2px")
                        .style("fill", "#0f0");

                    // Find the corresponding text element and modify its style
                    d3.select(this.parentNode) // go up to the group element (assuming your nodes and texts are wrapped inside a <g> element)
                        .select("text") // select the text element
                        .interrupt()  // <-- interrupt any ongoing transitions
                        .transition()
                        .duration(10)
                        .style("font-size", "2em") // increase font size
                        .style("fill", "red"); // change color to red

                    var paths = [];
                    if (highlightAllConnected) {
                        var pathsFromStart = findAllPaths(startNode, d, links, nodes);
                        var pathsToEnd = findAllPaths(d, endNode, links, nodes);
                        var paths = [];

                        pathsFromStart.forEach(pathFromStart => {
                            pathsToEnd.forEach(pathToEnd => {
                                paths.push(pathFromStart.concat(pathToEnd.slice(1))); // slice to avoid adding hovered node twice
                            });
                        });
                    }
                    console.log("d Node: ", d);
                    console.log("End Node: ", endNode);
                    console.log("All Paths: ", paths);

                    link.style("stroke", function (l) {
                        if (highlightAllConnected) {
                            return paths.some(path => {
                                // Convert path array of nodes to array of IDs for easier comparison
                                const pathIDs = path.map(node => node.ID); // <-- 'path' should be the parameter of this function
                                return pathIDs.includes(l.source.ID) && pathIDs.includes(l.target.ID);
                            }) ? "yellow" : null;
                        } else {
                            return (l.source === d || l.target === d) ? "yellow" : null;
                        }
                    }).attr("stroke-width", function (l) {
                        if (highlightAllConnected) {
                            return paths.some(path => {
                                // Convert path array of nodes to array of IDs for easier comparison
                                const pathIDs = path.map(node => node.ID); // <-- 'path' should be the parameter of this function
                                return pathIDs.includes(l.source.ID) && pathIDs.includes(l.target.ID);
                            }) ? 4 : 2;
                        } else {
                            return (l.source === d || l.target === d) ? 4 : 2;
                        }
                    });


                    node.select("circle")
                        .style("fill", function (n) {
                            var selectedMetric = document.querySelector('input[name="colorMetric"]:checked').value;
                            var metricValue;
                            console.log("Colors", "mouseover Selected Metric: ", selectedMetric)
                            switch (selectedMetric) {
                                case "inDegree":
                                    metricValue = n.inDegree;
                                    break;
                                case "outDegree":
                                    metricValue = n.outDegree;
                                    break;
                                case "degree":
                                    metricValue = n.degree;
                                    break;
                                default:
                                    metricValue = n.inDegree; // default to in-degree if something goes wrong
                            }

                            var baseColor;
                            switch (true) {
                                case metricValue > 4: baseColor = "#41afeb"; break;
                                case metricValue > 3: baseColor = "#46b9fa"; break;
                                case metricValue > 2: baseColor = "#5ac8fa"; break;
                                case metricValue > 1: baseColor = "#8ce6ff"; break;
                                default: baseColor = "#b4f5ff";
                            }

                            if (highlightAllConnected) {
                                return paths.some(path => path.includes(n)) ? "yellow" : baseColor;
                            } else {
                                return (n === d || links.some(l => (l.source === d && l.target === n) || (l.target === d && l.source === n))) ? "yellow" : baseColor;
                            }
                        })
                        .attr("r", function (n) {
                            if (highlightAllConnected) {
                                return paths.some(path => path.includes(n)) ? 30 : d3.select(this).attr("r");
                            } else {
                                return (n === d || links.some(l => (l.source === d && l.target === n) || (l.target === d && l.source === n))) ? 30 : d3.select(this).attr("r");
                            }
                        });


                    if (highlightCriticalPath) {
                        const criticalPath = findCriticalPath(paths, links);
                        highlightPath(criticalPath.path, 'red', link, node); // Highlight the critical path in red
                    }

                    if (highlightOutliers) {
                        const outlierPaths = findOutlierPaths(paths);
                        outlierPaths.forEach(outlierPath => {
                            highlightPath(outlierPath, 'orange', link, node); // Highlight outlier paths in orange
                        });
                        highlightPath(criticalPath, 'red', link, node); // Highlight the critical path in red
                    }

                    var tooltipEndX = d3.select("#graph-container").node().getBoundingClientRect().right - 10; // 10px offset from right
                    var tooltipEndY = d3.select("#graph-container").node().getBoundingClientRect().top + 10;  // 10px offset from top

                    tooltip.style("right", "10px")
                        .style("top", "10px");

                    tooltip.transition()
                        .duration(200)
                        .style("opacity", .9);
                    tooltip.html("<strong>ID:</strong> " + d.ID + "<br/>" +
                        "<strong>Name:</strong> " + d.Name + "<br/>" +
                        "<strong>Start:</strong> " + d.Start + "<br/>" +
                        "<strong>Finish:</strong> " + d.Finish)
                        .style("right", "10px")
                        .style("top", "10px");
                    //document.getElementById("infoPanel").innerHTML = "<strong>Name:</strong> " + d.Name + "<br/><strong>ID:</strong> " + d.ID + "<br/><strong>Start:</strong> " + d.Start + "<br/><strong>Finish:</strong> " + d.Finish + "<br/><strong>Duration:</strong> " + d.duration;

                    // Draw arrow from node to tooltip
                    //drawArrow(d, { x: tooltipEndX, y: tooltipEndY }, container);
                    /* container.append("circle")
                        .attr("cx", tooltipEndX)
                        .attr("cy", tooltipEndY)
                        .attr("r", 5)
                        .style("fill", "red");
                        */
                })
                .on("mouseout", function (d) {
                    d3.select(this)
                        .transition()
                        .duration(500)
                        .attr("r", 20 + d.inDegree * 0.5)
                        .style("fill", function () {
                            return updateNodeColors(d);
                        })
                        .style("stroke", null) // Remove the stroke (border) added during mouseover
                        .style("stroke-width", "1px");;

                    // Restore text element's style
                    d3.select(this.parentNode)
                        .select("text")
                        .transition()
                        .duration(300)
                        .style("font-size", "12px")
                        .style("fill", "#113464");

                    // Restore link colors and width
                    link.style("stroke", null)
                        .attr("stroke-width", 2);

                    // Restore other nodes
                    node.select("circle")
                        .style("stroke", "#1e69aa ")
                        .style("fill", function (n) {
                            return updateNodeColors(d);
                        })
                        .attr("r", function (n) {
                            return 20 + n.inDegree * 0.5;
                        });
                    tooltip.transition()
                        .duration(500)
                        .style("opacity", 0);
                    // Remove the arrow when the mouse leaves the node
                    removeArrow(container);
                })
                .on("click", function (d) {
                    // Determine risk, importance, and path colors based on their outlier flags
                    var riskColor = d.isRiskOutlier ? "red" : "green";
                    var importanceColor = d.isImportanceOutlier ? "red" : "green";
                    var pathColor = d.isOnOutlierPath || d.isOnCriticalPath ? "red" : "green";
                    var pathType = d.isOnCriticalPath ? "Critical" : "Non-Critical";
                    var startDate = new Date(d.Start);
                    var finishDate = new Date(d.Finish);
                    var daysLeft = Math.round((finishDate - new Date()) / (1000 * 60 * 60 * 24));
                    var daysLeftText = daysLeft >= 0 ? daysLeft + " days left" : -daysLeft + " days overdue";

                    var riskIcon = d.isRiskOutlier ? '<i class="fas fa-exclamation-circle"></i>' : '';
                    var importanceIcon = d.isImportanceOutlier ? '<i class="fas fa-star"></i>' : '';
                    var pathIcon = d.isOnOutlierPath ? '<i class="fas fa-route"></i>' : '';

                    var content = `
                            <div class="kanban-card sci-fi-card">
                                <div class="alarm-indicators">${riskIcon} ${importanceIcon} ${pathIcon}</div>
                                <h4>${d.Name} (ID: ${d.ID})</h4>
                                <ul class="futuristic-list">
                                    <li style="color:${riskColor}">Risk: ${d.riskScore.toFixed(2)}</li>
                                    <li style="color:${importanceColor}">Importance: ${d.importanceScore.toFixed(2)}</li>
                                    <li style="color:${pathColor}">Path: ${pathType}</li>
                                </ul>
                                <p>Expected Start: ${startDate.toLocaleDateString()} | Duration: ${d.Duration} hours</p>
                                <div class="card-icons">
                                    <span class="due-date-icon"><i class="fas fa-calendar-alt"></i> Due: ${finishDate.toLocaleDateString()} (${daysLeftText})</span>
                                    <span class="slack"><i class="fas fa-clock"></i> Slack: ${d.slack} hours</span>
                                </div>
                            </div>
                        `;

                    document.getElementById("taskDetail").innerHTML = content;
                    document.getElementById("taskModal").style.display = "block";
                });

            // Get the modal and the close button
            var modal = document.getElementById("taskModal");
            var span = document.getElementsByClassName("close")[0];

            // When the user clicks on the close button, close the modal
            span.onclick = function () {
                modal.style.display = "none";
            }

            // When the user clicks anywhere outside of the modal, close it
            window.onclick = function (event) {
                if (event.target == modal) {
                    modal.style.display = "none";
                }
            }


            // Append text labels
            node.append("text")
                .attr("dx", -15)
                .attr("dy", 5)
                .text(function (d) { return d.ID; })
                .style("fill", "#113464")
                .style("font-size", "14px");

            console.log("Node: ", node);

            node.transition()
                .duration(750)
                .style("fill", "blue");


            // Drag-and-Drop Editing
            var dragHandler = d3.drag()
                .on("start", function (d) {
                    d3.select(this).raise().classed("active", true);
                })
                .on("drag", function (d) {
                    d3.select(this).attr("cx", d.x = d3.event.x).attr("cy", d.y = d3.event.y);
                    // Update links if necessary
                })
                .on("end", function (d) {
                    d3.select(this).classed("active", false);
                });

            dragHandler(node);


            // Simulation tick handler
            simulation.nodes(nodes)
                .on("tick", ticked);

            simulation.force("link")
                .links(links);

            // Simulation tick handler
            function ticked() {
                link.attr("x1", function (d) { return d.source.x; })
                    .attr("y1", function (d) { return d.source.y; })
                    .attr("x2", function (d) {
                        var dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,
                            angle = Math.atan2(dy, dx),
                            radius = 20 + d.target.inDegree * 0.5; // Calculate the dynamic radius based on in-degree
                        return d.target.x - Math.cos(angle) * radius;
                    })
                    .attr("y2", function (d) {
                        var dx = d.target.x - d.source.x,
                            dy = d.target.y - d.source.y,
                            angle = Math.atan2(dy, dx),
                            radius = 20 + d.target.inDegree * 0.5; // Calculate the dynamic radius based on in-degree
                        return d.target.y - Math.sin(angle) * radius;
                    });

                node.attr("transform", function (d) {
                    return "translate(" + d.x + "," + d.y + ")";
                });
            }
            document.getElementById("zoomSlider").addEventListener("input", function (e) {
                var zoomLevel = e.target.value / 100; // Adjust according to your needs

                zoom.scaleTo(svg.transition().duration(750), zoomLevel);
            });


            window.zoomExtents = function () {
                var xMin = d3.min(nodes, function (d) { return d.x; });
                var xMax = d3.max(nodes, function (d) { return d.x; });
                var yMin = d3.min(nodes, function (d) { return d.y; });
                var yMax = d3.max(nodes, function (d) { return d.y; });

                var xCenter = (xMin + xMax) / 2;
                var yCenter = (yMin + yMax) / 2;

                var scale = Math.min(width / (xMax - xMin), height / (yMax - yMin)) * 0.95; // 0.95 for padding
                var translate = [width / 2 - scale * xCenter, height / 2 - scale * yCenter];

                svg.transition().duration(750)
                    .call(zoom.transform, d3.zoomIdentity.translate(translate[0], translate[1]).scale(scale));
            };


            document.getElementById("highlightCriticalPath").addEventListener("change", function () {
                if (this.checked) {
                    clearHighlights(link, node);
                    hideTooltip();
                    const criticalPathInfo = findCriticalPath(paths, links);
                    highlightPath(criticalPathInfo.path, 'darkred', link, node, criticalPathInfo.duration);
                    showTooltip(`Critical Path Length: ${criticalPathInfo.duration}`, 'darkred');
                    // Update criticalPathDetails div with the path details
                    document.getElementById('criticalPathDetails').textContent = `Critical Path Length: ${criticalPathInfo.duration}`;
                    document.getElementById("highlightOutliers").checked = false;
                } else {
                    console.log("highlightCriticalPath unchecked");
                    clearHighlights(link, node);
                    hideTooltip();
                }
            });

            document.getElementById("highlightOutliers").addEventListener("change", function () {
                if (this.checked) {
                    clearHighlights(link, node);
                    hideTooltip();
                    document.getElementById("highlightCriticalPath").checked = false;
                    const outlierPathsInfo = findOutlierPaths(paths, links);
                    // Create a container to hold all the details content
                    let detailsContent = '';
                    // Create a container to hold all the tooltip content
                    let tooltipContent = '';

                    outlierPathsInfo.paths.forEach((outlierPath, index) => {
                        const color = d3.scaleLinear().domain([0, outlierPathsInfo.paths.length - 1]).range(['orange', 'darkred'])(index);

                        // Highlight the path and update the tooltip with the path duration
                        highlightPath(outlierPath, color, link, node, outlierPathsInfo.durations[index]);
                        // Add the path duration to the details content
                        detailsContent += `Outlier Path ${index + 1} Length: ${outlierPathsInfo.durations[index]} units<br>`;
                        // Add the path duration to the tooltip content
                        // Wrap each tooltip line in a span with the appropriate color
                        tooltipContent += `<span style="color:${color}">Outlier Path ${index + 1} Length: ${outlierPathsInfo.durations[index]} units</span><br>`;
                    });

                    const criticalPathInfo = findCriticalPath(paths, links);
                    highlightPath(criticalPathInfo.path, 'darkred', link, node, criticalPathInfo.duration);
                    //tooltipContent += `Critical Path Length: ${criticalPathInfo.duration} units`;
                    tooltipContent += `<span style="color:darkred">Critical Path Length: ${criticalPathInfo.duration} units</span>`;

                    // Display the combined tooltip content
                    showTooltip(tooltipContent, 'darkred');

                    // Update outlierPathsDetails div with the details content
                    document.getElementById('outlierPathsDetails').innerHTML = detailsContent;
                } else {
                    console.log("highlightPath unchecked");
                    clearHighlights(link, node);
                    hideTooltip();
                }
            });
            tasks = nodes.map(node => ({
                ID: node.ID,
                Name: node.Name,
                Start: node.Start,
                Finish: node.Finish,
                duration: node.duration, // Assuming you have a 'duration' property on each node
            }));

        }

        //Utilty function to calculate node dgrees -  not currently used
        function computeDegrees(nodes, links) {
            // Initialize in-degree and out-degree for each node to 0
            nodes.forEach(node => {
                node.inDegree = 0;
                node.outDegree = 0;
            });

            // Calculate in-degree and out-degree based on links
            links.forEach(link => {
                nodes.find(node => node.ID === link.target).inDegree++;
                nodes.find(node => node.ID === link.source).outDegree++;
            });

            // Calculate the degree for each node
            nodes.forEach(node => {
                node.degree = node.inDegree + node.outDegree;
            });
        }

        // Call the function
        computeDegrees(nodes, links);


        function findAllPaths(startNode, endNode, links, nodes) {
            const neighborsMap = {};
            nodes.forEach(node => {
                neighborsMap[node.ID] = links
                    .filter(link => (link.source.ID || link.source) === node.ID)
                    .map(link => nodes.find(n => n.ID === (link.target.ID || link.target)));
            });

            const memo = {};  // for memoization
            let paths = [];

            function dfs(currentNode, currentPath, visited) {
                if (currentNode.ID === endNode.ID) {
                    paths.push([...currentPath]);
                    return;
                }

                if (memo[currentNode.ID]) {
                    paths = paths.concat(memo[currentNode.ID].map(subpath => currentPath.concat(subpath)));
                    return;
                }

                visited.add(currentNode.ID);
                let subpaths = [];
                for (let neighbor of neighborsMap[currentNode.ID]) {
                    if (!visited.has(neighbor.ID)) {
                        currentPath.push(neighbor);
                        dfs(neighbor, currentPath, visited);
                        currentPath.pop();
                    }
                }
                visited.delete(currentNode.ID);

                memo[currentNode.ID] = subpaths;
            }

            dfs(startNode, [startNode], new Set());

            return paths;
        }


        /*
        For all graphs including cyclic
            function findAllPaths(startNode, endNode, links, nodes) {
                console.log("Finding paths from", startNode, "to", endNode);
                let paths = [];
                let stack = [[startNode]];
                i = 0;
                console.log("i:", i);

                // Log details about links and nodes
                console.log("Links at the start:", JSON.stringify(links));
                console.log("Nodes at the start:", JSON.stringify(nodes));

                while (stack.length > 0) {
                    let path = stack.pop();
                    let lastNode = path[path.length - 1];

                    let neighbors = links
                        .filter(link => (link.source.ID || link.source) === lastNode.ID)
                        .map(link => nodes.find(node => node.ID === (link.target.ID || link.target)))
                        .filter(neighbor => !path.includes(neighbor));

                    console.log("Neighbors of", lastNode, ":", neighbors);

                    for (let neighbor of neighbors) {
                        let newPath = [...path, neighbor];
                        console.log("New Path:", JSON.stringify(newPath));  // Logging the new path

                        if (neighbor.ID === endNode.ID) {
                            // Convert newPath to string and check if it's already in paths
                            let newPathString = JSON.stringify(newPath.map(node => node.ID));
                            if (!paths.some(path => JSON.stringify(path.map(node => node.ID)) === newPathString)) {
                                paths.push(newPath);
                            }
                        } else {
                            stack.push(newPath);
                        }
                    }
                    i = i + 1
                    console.log("i++:", i);
                }

                console.log("All paths found:", paths);
                return paths;
            }
            
        //findShortestDistance using Djikstra's method more computational intensive but more accurate
        function findShortestDistance(startNode, targetNode, links, nodes) {
            // Initialize the distances object and set every distance to Infinity, except for the startNode
            const distances = {};
            nodes.forEach(node => {
                distances[node.ID] = Infinity;
            });
            distances[startNode.ID] = 0;

            const previousNodes = {};

            // Create a list of unvisited nodes. The startNode's distance is zero and all others are Infinity
            const unvisitedSet = new Set(nodes.map(node => node.ID));

            let currentNode = startNode;

            // Loop as long as we have unvisited nodes
            while (unvisitedSet.size > 0) {
                // Find all neighbors of the current node
                const neighbors = links.filter(link => link.source.ID === currentNode.ID)
                    .map(link => nodes.find(node => node.ID === link.target.ID));

                // Update tentative distances and previous nodes for neighbors of the current node
                for (let neighbor of neighbors) {
                    const link = links.find(link => (link.source.ID === currentNode.ID && link.target.ID === neighbor.ID));
                    const weight = link.duration;  // Using 'duration' as the weight
                    const tentativeDistance = distances[currentNode.ID] + weight;

                    if (tentativeDistance < distances[neighbor.ID]) {
                        distances[neighbor.ID] = tentativeDistance;
                        previousNodes[neighbor.ID] = currentNode;
                    }
                }

                // Remove the current node from the unvisited set
                unvisitedSet.delete(currentNode.ID);

                // If we've reached the target node, we can break
                if (currentNode.ID === targetNode.ID) {
                    break;
                }

                // Select the unvisited node with the smallest tentative distance
                currentNode = Array.from(unvisitedSet)
                    .map(id => nodes.find(node => node.ID === id))
                    .reduce((nearestNode, node) => {
                        return (distances[node.ID] < distances[nearestNode.ID]) ? node : nearestNode;
                    }, { ID: null, distance: Infinity });
            }

            return distances[targetNode.ID];
        }
        */
        function findShortestDistance(startNode, targetNode, links, nodes) {
            const neighborsMap = {};
            nodes.forEach(node => {
                neighborsMap[node.ID] = links
                    .filter(link => (link.source.ID || link.source) === node.ID)
                    .map(link => nodes.find(n => n.ID === (link.target.ID || link.target)));
            });

            let shortestDistance = Infinity;

            function dfs(currentNode, currentDistance, visited) {
                if (currentNode.ID === targetNode.ID) {
                    shortestDistance = Math.min(shortestDistance, currentDistance);
                    return;
                }

                visited.add(currentNode.ID);
                for (let neighbor of neighborsMap[currentNode.ID]) {
                    if (!visited.has(neighbor.ID)) {
                        const link = links.find(link => link.source.ID === currentNode.ID && link.target.ID === neighbor.ID);
                        dfs(neighbor, currentDistance + link.duration, visited);
                    }
                }
                visited.delete(currentNode.ID);
            }

            dfs(startNode, 0, new Set());

            return shortestDistance === Infinity ? -1 : shortestDistance;
        }


        function calculateSlack(nodes, links) {
            if (!nodes || !links || nodes.length === 0 || links.length === 0) {
                console.error("Invalid or empty nodes or links provided.");
                return;
            }
            console.log("calculateSlack entered", nodes, links)

            nodes.forEach(node => {
                node.ES = -1;
                node.EF = -1;
                node.LS = -1;
                node.LF = -1;
            });

            var startNode = nodes.find(node => node.ID === "0");
            if (!startNode) {
                console.error("Start node (ID: 0) not found.");
                return;
            }
            startNode.ES = 0;
            startNode.EF = 0;

            var endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);
            console.log("calculateSlack start node", startNode)
            console.log("calculateSlack end node", endNode)

            let forwardPass = (node) => {
                let outgoingLinks = links.filter(link => link.source.ID === node.ID);
                for (let link of outgoingLinks) {
                    let successor = nodes.find(n => n.ID === link.target.ID);
                    if (!successor) {
                        console.warn(`Successor not found for node ID: ${node.ID}`);
                        continue;
                    }
                    if (isNaN(Number(successor.Duration))) {  // Corrected here
                        console.warn(`Invalid duration for node ID: ${successor.ID}`);
                        continue;
                    }
                    if (successor.ES === -1 || successor.ES < node.EF) {
                        successor.ES = node.EF;
                        successor.EF = successor.ES + Number(successor.Duration);  // And here
                    }
                    forwardPass(successor);
                }
            };
            forwardPass(startNode);

            if (!endNode || endNode.EF === -1) {
                console.error("End node not identified or has invalid EF.");
                return;
            }

            endNode.LF = endNode.EF;
            endNode.LS = endNode.LF;

            let backwardPass = (node) => {
                let incomingLinks = links.filter(link => link.target.ID === node.ID);
                for (let link of incomingLinks) {
                    let predecessor = nodes.find(n => n.ID === link.source.ID);
                    if (!predecessor) {
                        console.warn(`Predecessor not found for node ID: ${node.ID}`);
                        continue;
                    }
                    if (isNaN(Number(predecessor.Duration))) {  // Corrected here
                        console.warn(`Invalid duration for node ID: ${predecessor.ID}`);
                        continue;
                    }
                    if (predecessor.LF === -1 || predecessor.LF > node.LS) {
                        predecessor.LF = node.LS;
                        predecessor.LS = predecessor.LF - Number(predecessor.Duration);  // And here
                    }
                    backwardPass(predecessor);
                }
            };
            backwardPass(endNode);

            nodes.forEach(node => {
                node.ES = isNaN(node.ES) ? -1 : node.ES;
                node.EF = isNaN(node.EF) ? -1 : node.EF;
                node.LS = isNaN(node.LS) ? -1 : node.LS;
                node.LF = isNaN(node.LF) ? -1 : node.LF;
            });

            nodes.forEach(node => {
                node.slack = node.LS - node.ES;
            });

            let slackValues = {};
            nodes.forEach(node => {
                slackValues[node.ID] = node.slack;
            });
            console.log("slackValues", slackValues)
            return slackValues;
        }


        function computeEigenvectorCentrality(nodes, links, maxIterations) {
            console.log("Entered computeNetworkMetrics computeEigenvectorCentrality", nodes, links, maxIterations);
            let adjacencyMatrix = [];
            let eigenvectorValues = new Array(nodes.length).fill(1);

            nodes.forEach(node_i => {
                let row = [];
                nodes.forEach(node_j => {
                    row.push(links.some(link =>
                        (link.source.ID === node_i.ID && link.target.ID === node_j.ID) ||
                        (link.source.ID === node_j.ID && link.target.ID === node_i.ID)
                    ) ? 1 : 0);
                });
                adjacencyMatrix.push(row);
            });

            console.log("Entered computeNetworkMetrics EigenvectorCentrality1 Adjacency Matrix", adjacencyMatrix);

            for (let i = 0; i < maxIterations; i++) {
                console.log("Iteration:", i); // Added log
                let newEigenvectorValues = adjacencyMatrix.map((row, idx) => {
                    return row.reduce((sum, val, j) => sum + val * eigenvectorValues[j], 0);
                });

                let norm = Math.sqrt(newEigenvectorValues.reduce((sum, val) => sum + val * val, 0));
                console.log("Norm:", norm); // Added log
                if (norm === 0) {
                    console.error("Normalization error: Norm is zero.");
                    return;
                }
                eigenvectorValues = newEigenvectorValues.map(val => val / norm);
            }

            console.log("Entered computeNetworkMetrics EigenvectorCentrality2", eigenvectorValues);

            nodes.forEach((node, idx) => {
                node.eigenvectorCentrality = eigenvectorValues[idx];
            });
            console.log("Exiting computeNetworkMetrics computeEigenvectorCentrality", eigenvectorValues);
            return new Map(nodes.map((node, idx) => [node.ID, eigenvectorValues[idx]]));
        }


        //Betweenness Centrality
        function computeBetweennessCentrality(nodes, links) {
            console.log("Entered computeNetworkMetrics computeBetweennessCentrality", nodes, links);
            let betweenness = new Map();
            nodes.forEach(node => betweenness.set(node.ID, 0));

            for (let source of nodes) {
                let shortestPaths = new Map();
                nodes.forEach(node => shortestPaths.set(node.ID, []));
                shortestPaths.get(source.ID).push([source]);

                let queue = [source];
                let visited = new Set([source.ID]);

                while (queue.length) {
                    let current = queue.shift();
                    for (let link of links.filter(l => l.source.ID === current.ID)) {
                        if (!visited.has(link.target.ID)) {
                            visited.add(link.target.ID);
                            queue.push(nodes.find(n => n.ID === link.target.ID));
                        }
                        let newPath = shortestPaths.get(current.ID).map(path => [...path, nodes.find(n => n.ID === link.target.ID)]);
                        shortestPaths.get(link.target.ID).push(...newPath);
                    }
                }

                nodes.forEach(node => {
                    if (node !== source) {
                        let pathsThroughNode = 0;
                        let totalPaths = shortestPaths.get(node.ID).length;
                        shortestPaths.get(node.ID).forEach(path => {
                            if (path.some(p => p.ID === node.ID) && path[0].ID === source.ID && path[path.length - 1].ID !== source.ID) {
                                pathsThroughNode += 1;
                            }
                        });
                        if (totalPaths !== 0) {
                            betweenness.set(node.ID, betweenness.get(node.ID) + pathsThroughNode / totalPaths);
                        }
                    }
                });
            }

            // Normalize the betweenness values
            let maxBetweenness = Math.max(...betweenness.values());
            if (maxBetweenness !== 0) {
                nodes.forEach(node => {
                    betweenness.set(node.ID, betweenness.get(node.ID) / maxBetweenness);
                    node.betweenness = betweenness.get(node.ID);
                });
            }
            console.log("Exiting computeNetworkMetrics computeBetweennessCentrality2", betweenness);
            return betweenness;
        }

        ///Calculate Clustering Coefficient
        function computeClusteringCoefficient(nodes, links) {
            console.log("Entered computeNetworkMetrics computeClusteringCoefficient", nodes, links);
            let clusteringCoefficients = new Map();

            for (let node of nodes) {
                let neighbors = links.filter(link => link.source.ID === node.ID || link.target.ID === node.ID)
                    .map(link => link.source.ID === node.ID ? link.target.ID : link.source.ID);

                let neighborLinks = 0;
                for (let i = 0; i < neighbors.length; i++) {
                    for (let j = i + 1; j < neighbors.length; j++) {
                        if (links.some(link => (link.source.ID === neighbors[i] && link.target.ID === neighbors[j]) || (link.source.ID === neighbors[j] && link.target.ID === neighbors[i]))) {
                            neighborLinks++;
                        }
                    }
                }

                let totalPossibleLinks = neighbors.length * (neighbors.length - 1) / 2;
                //clusteringCoefficients.set(node.ID, totalPossibleLinks !== 0 ? neighborLinks / totalPossibleLinks : 0);
                clusteringCoefficients.set(node.ID, Math.min(Math.max(0, totalPossibleLinks !== 0 ? neighborLinks / totalPossibleLinks : 0), 1));
                node.clusteringCoefficient = clusteringCoefficients.get(node.ID);
            }
            console.log("Exit computeNetworkMetrics computeClusteringCoefficient", clusteringCoefficients);
            return clusteringCoefficients;
        }

        // Compute Network Density
        function computeNetworkDensity(nodes, links) {
            let totalPossibleLinks = nodes.length * (nodes.length - 1) / 2;
            return links.length / totalPossibleLinks;
        }

        async function computeNetworkMetrics(nodes, links, dampingFactor, maxIterations) {
            console.log("Entered computeNetworkMetrics");

            const projectData = {
                'Nuclear storage': { costOverrun: 2.38, scheduleOverrun: 0.65 },
                'Olympic Games': { costOverrun: 1.57, scheduleOverrun: 1 },
                'Nuclear power PWR': { costOverrun: 0.95, scheduleOverrun: 0.61 },
                'Nuclear power BWR': { costOverrun: 1.79, scheduleOverrun: 0.63 },
                'Nuclear power PHWR': { costOverrun: 1.60, scheduleOverrun: 1.25 },
                'Hydroelectric dams': { costOverrun: 0.75, scheduleOverrun: 0.18 },
                'Flood control': { costOverrun: 0.03, scheduleOverrun: 0.03 },
                'Transportation': { costOverrun: 0.03, scheduleOverrun: 0.01 },
                'Utilities': { costOverrun: 0.01, scheduleOverrun: 0.01 },
                'IT': { costOverrun: 0.73, scheduleOverrun: 0.37 },
                'Nonhydroelectric dams': { costOverrun: 0.07, scheduleOverrun: 0.18 },
                'Buildings': { costOverrun: 0.62, scheduleOverrun: 0.20 },
                'Aerospace': { costOverrun: 0.60, scheduleOverrun: 0.57 },
                'Defense': { costOverrun: 0.53, scheduleOverrun: 0.22 },
                'Bus rapid transit': { costOverrun: 0.40, scheduleOverrun: 0.1 },
                'Rail': { costOverrun: 0.39, scheduleOverrun: 0.43 },
                'Airports': { costOverrun: 0.39, scheduleOverrun: 0.62 },
                'Tunnels': { costOverrun: 0.37, scheduleOverrun: 0.34 },
                'Oil and gas': { costOverrun: 0.34, scheduleOverrun: 0.37 },
                'Ports': { costOverrun: 0.32, scheduleOverrun: 0.67 },
                'Hospitals, health': { costOverrun: 0.29, scheduleOverrun: 0.41 },
                'Mining': { costOverrun: 0.27, scheduleOverrun: 0 },
                'Bridges': { costOverrun: 0.26, scheduleOverrun: 0 },
                'Water': { costOverrun: 0.20, scheduleOverrun: 0.32 },
                'Fossil thermal power': { costOverrun: 0.16, scheduleOverrun: 0.62 },
                'Roads': { costOverrun: 0.16, scheduleOverrun: 0.63 },
                'Pipelines': { costOverrun: 0.14, scheduleOverrun: 0.37 },
                'Wind power': { costOverrun: 0.13, scheduleOverrun: 0.10 },
                'Energy transmission': { costOverrun: 0.08, scheduleOverrun: 0.08 },
                'Solar power': { costOverrun: 0.01, scheduleOverrun: 0.01 }
            };

            const selectedSegment = document.getElementById("projectSegment").value;
            const defaultOverrunData = projectData[selectedSegment];
            console.log("defaultOverrunData");
            console.log("defaultOverrunData", defaultOverrunData, defaultOverrunData.costOverrun, defaultOverrunData.scheduleOverrun);

            // Find the start and end nodes
            const startN = nodes.find(node => node.ID === "0");
            const endN = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);

            // Calculate distances to the end node for each node
            findDistancesToEnd(startN, endN, links, nodes);


            //console.log("defaultOverrunData2", defaultOverrunData, defaultOverrunData.costOverrun, defaultOverrunData.scheduleOverrun);

            // Compute PageRank
            console.log("Entered computeNetworkMetrics1 ", nodes, links, dampingFactor, maxIterations);
            let pageRankValues = await computePageRank(nodes, links, dampingFactor, maxIterations);
            console.log("Entered computeNetworkMetrics2");
            // Compute Betweenness Centrality
            let betweennessValues = computeBetweennessCentrality(nodes, links);
            console.log("Entered computeNetworkMetrics3");
            // Compute Clustering Coefficient
            let clusteringCoefficientValues = computeClusteringCoefficient(nodes, links);
            console.log("Entered computeNetworkMetrics4");
            // Compute Eigenvector Centrality
            let eigenvectorCentralityValues = computeEigenvectorCentrality(nodes, links, maxIterations);
            console.log("Entered computeNetworkMetrics5");
            // Compute Network Density
            let networkDensityValue = computeNetworkDensity(nodes, links);
            console.log("Entered computeNetworkMetrics6");
            // Find start and end nodes
            var startNode = nodes.find(node => node.ID === "0"); // Assuming ID is a string
            var endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);

            // Find all paths from startNode to endNode
            var paths = findAllPaths(startNode, endNode, links, nodes);
            let criticalPathResult = findCriticalPath(paths, links);
            // Assuming you have paths and links available
            //const criticalPathData = findCriticalPath(paths, links);
            //const outlierPathsData = findOutlierPaths(paths, links);

            // Compute slacks for each node
            const nodeSlacks = calculateSlack(nodes, links);

            let criticalPath = criticalPathResult.path;  // Extract the path array
            let outlierPathsResult = findOutlierPaths(paths, links);
            let outlierPaths = outlierPathsResult.paths;  // Extract the paths array of arrays

            //populatePathsTable(criticalPathResult, outlierPathsResult);

            // Append metrics and labels to each node
            for (let node of nodes) {
                node.pageRank = pageRankValues.get(node.ID);
                node.betweenness = betweennessValues.get(node.ID);
                node.clusteringCoefficient = clusteringCoefficientValues.get(node.ID);
                node.eigenvectorCentrality = eigenvectorCentralityValues.get(node.ID);
                node.isOnCriticalPath = criticalPath.some(n => n.ID === node.ID); // Indicate if node is on critical path
                node.isOnOutlierPath = outlierPaths.some(path => path.includes(node));  // Indicate if node is on any outlier path
                // Append slack to the node
                node.slack = nodeSlacks[node.ID];
            }


            // Before the nodes.forEach loop, initialize arrays to collect raw values
            let taskInfluenceScores = [];
            let bufferRequirements = [];
            let flowDisruptionPotentials = [];
            let riskExposures = [];

            // Compute the scores for each node
            nodes.forEach(node => {
                // Extract metrics
                const CRITICAL_PATH_MULTIPLIER = 1.5;  // for nodes on the critical path
                const OUTLIER_PATH_MULTIPLIER = 1.25; // for nodes on the outlier paths
                const inDegree = node.inDegree;
                const outDegree = node.outDegree;
                const betweennessCentrality = node.betweenness;
                const pageRank = node.pageRank;
                // Duration will be taken from the link duration associated with the node,
                // but if not available, a default value of 1 will be taken.
                //const duration = links.find(link => link.source.ID === node.ID || link.target.ID === node.ID)?.duration || 1;
                const duration = node.Duration;
                console.log("computeNetworkMetrics Duration", node.ID)

                // Calculate raw metrics for each node
                const taskInfluenceScore = pageRank + betweennessCentrality;
                const bufferRequirement = 1 / (1 + Math.max(node.clusteringCoefficient, 0.001));
                const flowDisruptionPotential = 1 - node.clusteringCoefficient;
                const riskExposure = duration * betweennessCentrality;

                // Local normalization
                const normalize = (value, min, max) => {
                    if (max === min) {
                        console.warn("Normalization warning: max is equal to min for value:", value, ". Defaulting to 0.");
                        return 0;  // Default value
                    }
                    return (value - min) / (max - min);
                };

                const handleNaN = (value, metricName, nodeId) => {
                    if (isNaN(value)) {
                        console.warn(`Warning: ${metricName} is NaN for node: ${nodeId}. Defaulting to 0.`);
                        return 0; // Default value
                    }
                    return value;
                }

                const maxInDegree = Math.max(...nodes.map(n => n.inDegree));
                const minInDegree = Math.min(...nodes.map(n => n.inDegree));
                const inDegreeNorm = handleNaN(normalize(node.inDegree, minInDegree, maxInDegree), "inDegreeNorm", node.ID);

                const maxOutDegree = Math.max(...nodes.map(n => n.outDegree));
                const minOutDegree = Math.min(...nodes.map(n => n.outDegree));
                const outDegreeNorm = handleNaN(normalize(node.outDegree, minOutDegree, maxOutDegree), "outDegreeNorm", node.ID);

                const maxBetweenness = Math.max(...nodes.map(n => n.betweenness));
                const minBetweenness = Math.min(...nodes.map(n => n.betweenness));
                const betweennessCentralityNorm = handleNaN(normalize(node.betweenness, minBetweenness, maxBetweenness), "betweennessCentralityNorm", node.ID);

                const maxPageRank = Math.max(...nodes.map(n => n.pageRank));
                const minPageRank = Math.min(...nodes.map(n => n.pageRank));
                const pageRankNorm = handleNaN(normalize(node.pageRank, minPageRank, maxPageRank), "pageRankNorm", node.ID);

                const maxDuration = Math.max(...nodes.map(n => n.Duration));
                const minDuration = Math.min(...nodes.map(n => n.Duration));
                const durationNorm = normalize(node.Duration, minDuration, maxDuration);

                const maxClusteringCoefficient = Math.max(...nodes.map(n => n.clusteringCoefficient));
                const minClusteringCoefficient = Math.min(...nodes.map(n => n.clusteringCoefficient));
                const clusteringCoefficientNorm = normalize(node.clusteringCoefficient, minClusteringCoefficient, maxClusteringCoefficient);

                const minTaskInfluenceScore = Math.min(...taskInfluenceScores);
                const maxTaskInfluenceScore = Math.max(...taskInfluenceScores);
                const minBufferRequirement = Math.min(...bufferRequirements);
                const maxBufferRequirement = Math.max(...bufferRequirements);
                const minFlowDisruptionPotential = Math.min(...flowDisruptionPotentials);
                const maxFlowDisruptionPotential = Math.max(...flowDisruptionPotentials);
                const minRiskExposure = Math.min(...riskExposures);
                const maxRiskExposure = Math.max(...riskExposures);

                // Compute the max and min values for longestDistanceToEnd across all nodes
                const maxLongestDistanceToEnd = Math.max(...nodes.map(n => n.longestDistanceToEnd));
                const minLongestDistanceToEnd = Math.min(...nodes.map(n => n.longestDistanceToEnd));


                const taskInfluenceScoreNorm = normalize(taskInfluenceScore, minTaskInfluenceScore, maxTaskInfluenceScore);
                const bufferRequirementNorm = normalize(bufferRequirement, minBufferRequirement, maxBufferRequirement);
                const flowDisruptionPotentialNorm = normalize(flowDisruptionPotential, minFlowDisruptionPotential, maxFlowDisruptionPotential);
                //const riskExposureNorm = normalize(riskExposure, minRiskExposure, maxRiskExposure);
                const riskExposureNorm = handleNaN(normalize(riskExposure, minRiskExposure, maxRiskExposure), "riskExposureNorm", node.ID);

                // Normalize longestDistanceToEnd for the current node
                const longestDistanceToEndNorm = normalize(node.longestDistanceToEnd, minLongestDistanceToEnd, maxLongestDistanceToEnd);


                const dependencyRatio = (inDegree + outDegree) !== 0 ? inDegree / (inDegree + outDegree) : 0;
                const maxDependencyRatio = Math.max(...nodes.map(n => {
                    const inD = n.inDegree;
                    const outD = n.outDegree;
                    return (inD + outD) !== 0 ? inD / (inD + outD) : 0;
                }));
                const minDependencyRatio = Math.min(...nodes.map(n => {
                    const inD = n.inDegree;
                    const outD = n.outDegree;
                    return (inD + outD) !== 0 ? inD / (inD + outD) : 0;
                }));
                const dependencyRatioNorm = normalize(dependencyRatio, minDependencyRatio, maxDependencyRatio);

                const bottleneckScore = (inDegree + outDegree) / (duration);
                const maxBottleneckScore = Math.max(...nodes.map(n => {
                    const dur = n.Duration !== 0 ? n.Duration : 1; // prevent division by zero
                    return (n.inDegree + n.outDegree) / dur;
                }));
                const minBottleneckScore = Math.min(...nodes.map(n => {
                    const dur = n.Duration !== 0 ? n.Duration : 1; // prevent division by zero
                    return (n.inDegree + n.outDegree) / dur;
                }));
                const bottleneckScoreNorm = normalize(bottleneckScore, minBottleneckScore, maxBottleneckScore);


                // Calculate other metrics
                //const riskExposure = duration * betweennessCentrality;
                const EPSILON = 0.001; // a small value to avoid division by zero or near-zero values
                const adjustedClusteringCoefficient = Math.max(node.clusteringCoefficient, -1 + EPSILON);

                // Compute the distance from the start node for each node
                //let distanceFromStart = findShortestDistance(startNode, node, links, nodes);  // You'll need to implement this function
                //const maxDistance = Math.max(...nodes.map(n => findShortestDistance(startNode, n, links, nodes)));
                //const minDistance = Math.min(...nodes.map(n => findShortestDistance(startNode, n, links, nodes)));
                //const distanceFactor = 1 - normalize(distanceFromStart, minDistance, maxDistance);  // Closer to start means higher importance

                // Compute Risk Score (New formula)


                // Compute Importance Score (New formula)


                // Compute Risk Score
                const riskScore = (0.25 * betweennessCentralityNorm) +
                    (0.2 * pageRankNorm) +
                    (0.2 * durationNorm) +
                    (0.15 * riskExposureNorm) +
                    (0.2 * inDegreeNorm);  // New factor for in-degree

                // Compute Importance Score
                //const taskInfluenceScore = pageRank + betweennessCentrality; // Simplified for the example
                //const bufferRequirement = 1 / (1 + adjustedClusteringCoefficient);
                //const flowDisruptionPotential = 1 - node.clusteringCoefficient; // A simplified approach

                const importanceScore = (0.15 * dependencyRatioNorm) +
                    (0.25 * taskInfluenceScore) +
                    (0.15 * bufferRequirement) +
                    (0.15 * longestDistanceToEndNorm) +
                    (0.15 * flowDisruptionPotential) +
                    (0.15 * bottleneckScoreNorm) +
                    (0.15 * pageRank);//reduce to 0.1 if distanceFactor is used

                console.log("computeNetworkMetrics Final Importance Score for node", node.ID, ":", importanceScore);

                // Adjust multipliers based on node's presence on critical or outlier paths
                let riskMultiplier = 1;
                let importanceMultiplier = 1;

                if (node.isOnCriticalPath && node.isOnOutlierPath) {
                    riskMultiplier = Math.max(CRITICAL_PATH_MULTIPLIER, OUTLIER_PATH_MULTIPLIER);
                    importanceMultiplier = CRITICAL_PATH_MULTIPLIER; // We only apply the critical path multiplier for importance
                } else if (node.isOnCriticalPath) {
                    riskMultiplier = CRITICAL_PATH_MULTIPLIER;
                    importanceMultiplier = CRITICAL_PATH_MULTIPLIER;
                } else if (node.isOnOutlierPath) {
                    riskMultiplier = OUTLIER_PATH_MULTIPLIER;
                }

                // Compute Risk and Importance Score with the adjusted multipliers
                node.riskScore = riskScore * riskMultiplier;
                node.importanceScore = importanceScore * importanceMultiplier;

                // Check if riskScore or importanceScore are NaN and set them to 0
                if (isNaN(node.riskScore)) {
                    console.error("NaN detected for riskScore on node:", node.ID);
                    node.riskScore = 0.0001;
                }
                if (isNaN(node.importanceScore)) {
                    console.error("NaN detected for importanceScore on node:", node.ID);
                    node.importanceScore = 0.0001;
                }
            });
            // Dummy totalProjectOverrunProbability
            //const totalProjectOverrunProbability = 0.2;  // Example value
            const totalProjectOverrunProbability = defaultOverrunData.scheduleOverrun;
            console.log("totalProjectOverrunProbability", totalProjectOverrunProbability)
            // Call the function
            const updatedNodes = distributeOverrunProbability(nodes, links, totalProjectOverrunProbability);
            console.log("computeNetworkMetrics7, updatedNodes", nodes);

            console.log("Exiting computeNetworkMetrics nodes", nodes, networkDensityValue);

            // Return updated nodes and network density value
            return {
                updatedNodes: nodes,
                networkDensity: networkDensityValue
            };
        }

        function computePageRank(nodes, links, dampingFactor, maxIterations) {
            let pageRankValues = new Map();
            let newPageRankValues = new Map();

            for (let node of nodes) {
                pageRankValues.set(String(node.ID), 1 / nodes.length);
            }

            console.log("Initial PageRank values:", pageRankValues);

            for (let iteration = 1; iteration <= maxIterations; iteration++) {
                let totalDifference = 0;

                // Identify dangling nodes
                let danglingNodes = [...pageRankValues.keys()].filter(key =>
                    !links.some(link => key === String(link.source.ID) || key === String(link.target.ID))
                );
                console.log(`Number of Dangling Nodes: ${danglingNodes.length}`);

                for (let node of nodes) {
                    let nodeID = String(node.ID);
                    newPageRankValues.set(nodeID, (1 - dampingFactor) / nodes.length);

                    for (let link of links) {
                        if (nodeID === String(link.target.ID)) {
                            let outgoingLinks = links.filter(l => String(l.source.ID) === String(link.source.ID));
                            let totalWeight = outgoingLinks.reduce((acc, l) => acc + l.duration, 0);

                            // Diagnostic: Average Link Weight
                            let avgWeight = totalWeight / outgoingLinks.length;
                            console.log(`Average Link Weight for Node ${nodeID}: ${avgWeight}`);

                            newPageRankValues.set(nodeID, newPageRankValues.get(nodeID) + dampingFactor * (pageRankValues.get(String(link.source.ID)) * link.duration / totalWeight));
                        }
                    }
                }

                // Calculate total difference
                for (let [nodeID, value] of newPageRankValues) {
                    totalDifference += Math.abs(value - pageRankValues.get(nodeID));
                }

                console.log(`Total Difference for Iteration ${iteration}: ${totalDifference}`);

                // Swap the new values into the old PageRank values for the next iteration
                [pageRankValues, newPageRankValues] = [newPageRankValues, pageRankValues];
            }

            console.log("Final PageRank values:", pageRankValues);
            return pageRankValues;
        }


        function enhanceWeightsWithCriticalPathAndOutliers(links, criticalPathSet, outlierTasksSet, criticalPathMultiplier, outlierMultiplier) {
            for (let link of links) {
                if (criticalPathSet.has(link.source.ID)) {
                    link.duration *= criticalPathMultiplier;
                } else if (outlierTasksSet.has(link.source.ID)) {
                    link.duration *= outlierMultiplier;
                }
            }
        }

        function adjustTaskTimesWithDependencies(nodes, links) {
            const nodeById = {};
            nodes.forEach(node => {
                nodeById[node.ID] = node;
            });

            function adjustStartTime(node) {
                if (node.adjusted) return;
                const predecessors = links.filter(link => link.target.ID === node.ID).map(link => link.source);
                let maxFinishTime = new Date(node.Start);
                predecessors.forEach(predecessor => {
                    adjustStartTime(predecessor);
                    const overrunFactor = 1 + parseFloat(predecessor.overrun_probability);
                    const adjustedFinish = new Date(predecessor.Finish);
                    adjustedFinish.setTime(adjustedFinish.getTime() + (parseFloat(predecessor.Duration) * 60 * 60 * 1000 * (overrunFactor - 1)));
                    if (adjustedFinish > maxFinishTime) {
                        maxFinishTime = adjustedFinish;
                    }
                });
                node.Start = maxFinishTime.toISOString();
                const taskDurationMillis = parseFloat(node.Duration) * 60 * 60 * 1000;
                const taskEndTime = new Date(maxFinishTime.getTime() + taskDurationMillis);
                node.Finish = taskEndTime.toISOString();
                node.adjusted = true;
            }

            nodes.forEach(node => {
                if (!node.adjusted) {
                    adjustStartTime(node);
                }
            });
        }

        function distributeOverrunForPath(path, nodes, links, A, B) {
            path.forEach(node => {
                let risk = parseFloat(node.riskScore);
                if (isNaN(risk)) {
                    console.warn(`Node ID ${node.ID} has invalid risk: ${node.riskScore}`);
                    node.overrun_probability = 0;
                    return;
                }
                node.overrun_probability = A + B * risk;
                //console.log("distributeOverrunProbability: Risk:", node, node.overrun_probability);
                if (isNaN(node.overrun_probability) || !isFinite(node.overrun_probability)) {
                    console.warn(`Invalid overrun_probability for Node ID ${node.ID}. Setting to 0.`);
                    node.overrun_probability = 0;
                }
            });
        }

        function findLongestAdjustedPathDuration(allPaths) {
            let longestDuration = 0;
            allPaths.forEach(path => {
                let adjustedDuration = path.reduce((sum, node) => sum + parseFloat(node.Duration) * (1 + node.overrun_probability), 0);
                if (adjustedDuration > longestDuration) {
                    longestDuration = adjustedDuration;
                }
            });
            return longestDuration;
        }

        function distributeOverrunProbability(nodes, links, totalProjectOverrunProbability) {

            console.log("distributeOverrunProbability: Entry");
            if (!nodes || !links) {
                console.error("distributeOverrunProbability: Missing nodes or links.");
                return;
            }

            nodes.forEach(node => {
                node.overrun_probability = 0;
                if (node.Duration <= 0) {
                    console.warn(`Node ID ${node.ID} has invalid Duration: ${node.Duration}. Setting to a default value of 1.`);
                    node.Duration = 1; // Set to a default value of 1 or any other suitable value
                }
            });

            const MAX_ITERATIONS = 1000;
            const TOLERANCE = 1e-4;
            const CAP_A_AT = 0.20 * totalProjectOverrunProbability; // Capping A at 10% of totalProjectOverrunProbability
            let A = 0.05 * totalProjectOverrunProbability;
            let B = totalProjectOverrunProbability - A;
            let iterationCount = 0;
            console.log("distributeOverrunProbability: initial:", totalProjectOverrunProbability, iterationCount, A, B);


            const startNode = nodes.find(node => node.ID === "0");
            const endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);

            console.log("distributeOverrunProbability: Start & End Nodes:", startNode, endNode);

            let allPaths = findAllPaths(startNode, endNode, links, nodes);
            let targetDuration = findLongestAdjustedPathDuration(allPaths) * (1 + totalProjectOverrunProbability);
            console.log("distributeOverrunProbability: targetDuration:", targetDuration, targetDuration / (1 + totalProjectOverrunProbability));

            while (iterationCount < MAX_ITERATIONS) {
                allPaths.forEach(path => {
                    distributeOverrunForPath(path, nodes, links, A, B);
                });

                let longestAdjustedPathDuration = findLongestAdjustedPathDuration(allPaths);
                let difference = Math.abs(targetDuration - longestAdjustedPathDuration);
                console.log("distributeOverrunProbability: targetDuration, longestAdjustedPathDuration:", targetDuration, longestAdjustedPathDuration);


                if (difference <= TOLERANCE) {
                    break;
                }

                let adjustmentFactor = (targetDuration - longestAdjustedPathDuration) / longestAdjustedPathDuration;
                A += 0.05 * adjustmentFactor * A;
                B += adjustmentFactor * B;
                // Capping A
                if (A > CAP_A_AT) {
                    A = CAP_A_AT;
                }
                console.log("distributeOverrunProbability: targetDuration:", iterationCount, A, B, difference);

                iterationCount++;

            }

            return nodes;
        }

        function populateInternalMilestones(nodes) {
            // Select the block-content element for KEY INTERNAL MILESTONES
            const milestonesContainer = document.querySelector('.block-content.block-content-full.overflow-hidden');

            // Clear existing content
            milestonesContainer.innerHTML = '';

            let timeout = 100; // Initial timeout for animations

            nodes.forEach(node => {
                if (node.Milestone === 1) { // Ensure only milestones are processed
                    // Milestone title
                    const milestoneTitleDiv = document.createElement('div');
                    milestoneTitleDiv.className = 'font-w600 text-white-op push-5 visibility-hidden';
                    milestoneTitleDiv.setAttribute('data-toggle', 'appear');
                    milestoneTitleDiv.setAttribute('data-class', 'animated fadeInRight');
                    milestoneTitleDiv.setAttribute('data-timeout', timeout);
                    milestoneTitleDiv.textContent = `${node.Name}: ${node.PercentComplete}%`;

                    // Progress bar
                    const progressBarDiv = document.createElement('div');
                    progressBarDiv.className = 'progress visibility-hidden';
                    progressBarDiv.setAttribute('data-toggle', 'appear');
                    progressBarDiv.setAttribute('data-class', 'animated fadeInLeft');
                    progressBarDiv.setAttribute('data-timeout', timeout + 200); // Slight delay for the bar animation

                    const progressBarInnerDiv = document.createElement('div');
                    progressBarInnerDiv.className = 'progress-bar progress-bar-sf progress-bar-striped active';
                    progressBarInnerDiv.setAttribute('role', 'progressbar');
                    progressBarInnerDiv.setAttribute('aria-valuenow', node.PercentComplete);
                    progressBarInnerDiv.setAttribute('aria-valuemin', 0);
                    progressBarInnerDiv.setAttribute('aria-valuemax', 100);
                    progressBarInnerDiv.style.width = `${node.PercentComplete}%`;
                    progressBarInnerDiv.style.height = '30px'; // Default height

                    progressBarDiv.appendChild(progressBarInnerDiv);

                    milestonesContainer.appendChild(milestoneTitleDiv);
                    milestonesContainer.appendChild(progressBarDiv);

                    timeout += 200; // Increase the timeout for the next milestone animation
                }
            });
        }

        function drawMilestoneTable(nodes, links) {
            console.log("Drawing Milestone Table");
            const startNode = nodes.find(node => node.ID === "0"); // Assuming start node has ID 0
            const milestones = nodes.filter(node => node.Milestone === 1);

            // Extract TimeUnits from the nodes
            const timeUnits = nodes[0].TimeUnits;

            // Set the column header dynamically
            const columnHeader = document.querySelector('#milestoneTable thead th:last-child');
            if (columnHeader) {
                columnHeader.textContent = 'Path';
            }

            // Check if there are any milestones. If not, exit the function early.
            if (milestones.length === 0) {
                console.log("No milestones found. Exiting...");
                return;
            }

            const tableBody = document.getElementById('milestoneTableBody');
            tableBody.innerHTML = ''; // Clear any previous rows

            // Step 1: Determine min and max averageOverrunProbability across all milestones
            let minOverrunProbability = Infinity;
            let maxOverrunProbability = -Infinity;

            milestones.forEach(milestone => {
                const allPathsToMilestone = findAllPaths(startNode, milestone, links, nodes);
                allPathsToMilestone.forEach(path => {
                    const averageOverrunProbability = path.reduce((sum, node) => sum + node.overrun_probability, 0) / path.length;
                    minOverrunProbability = Math.min(minOverrunProbability, averageOverrunProbability);
                    maxOverrunProbability = Math.max(maxOverrunProbability, averageOverrunProbability);
                });
            });

            // Calculate the maximum path length among all milestones
            let maxPathLength = 0;
            milestones.forEach(milestone => {
                const allPathsToMilestone = findAllPaths(startNode, milestone, links, nodes);
                const longestDuration = allPathsToMilestone.reduce((max, path) => {
                    const pathDuration = path.reduce((sum, node) => sum + node.Duration, 0);
                    return Math.max(max, pathDuration);
                }, 0);
                maxPathLength = Math.max(maxPathLength, longestDuration);
            });

            milestones.forEach(milestone => {
                const allPathsToMilestone = findAllPaths(startNode, milestone, links, nodes);
                console.log(`drawMilestoneTable Checking paths to milestone ID ${milestone.ID}`);

                // Finding the longest path by summing up durations of each path
                let longestPath = [];
                let longestDuration = 0;
                allPathsToMilestone.forEach(path => {
                    //const pathDuration = path.reduce((sum, node) => sum + node.AdjustedDuration, 0);
                    const pathDuration = path.reduce((sum, node) => sum + node.Duration, 0);

                    console.log(`Path: [${path.map(p => p.ID).join(", ")}] - Duration: ${pathDuration}`);
                    if (pathDuration > longestDuration) {
                        longestDuration = pathDuration;
                        longestPath = path;
                    }
                });

                // Calculate risk-adjusted duration for the longest path
                const riskAdjustedDuration = calculateExpectedOverrunDurationForPath(longestPath);
                console.log(`drawMilestoneTable Longest path to milestone ID ${milestone.ID}: [${longestPath.map(p => p.ID).join(", ")}] - Duration: ${longestDuration}`);

                // Calculate averageOverrunProbability for this milestone
                const averageOverrunProbability = longestPath.reduce((sum, node) => sum + node.overrun_probability, 0) / longestPath.length;

                // Calculate the bar color based on averageOverrunProbability
                const scaledProbability = (averageOverrunProbability - minOverrunProbability) / (maxOverrunProbability - minOverrunProbability);
                const greenValue = Math.floor((1 - scaledProbability) * 255);
                const barColor = `rgb(255, ${greenValue}, 0)`;

                // Initialize sums for duration-weighted risk and importance
                let sumWeightedRisk = 0;
                let sumWeightedImportance = 0;
                let totalPathDuration = 0;

                // Log durations and risk-adjusted durations of each activity along the path for debugging purposes
                console.log("drawMilestoneTable Activity Durations and Risk-adjusted Durations for the Longest Path:");
                longestPath.forEach(node => {
                    const nodeRiskAdjustedDuration = node.Duration + (node.Duration * node.overrun_probability);
                    console.log(` drawMilestoneTable Node ID: ${node.ID}, Duration: ${node.Duration}, Risk-adjusted Duration: ${nodeRiskAdjustedDuration}`);

                    const weightedRisk = node.Duration * node.riskScore;
                    const weightedImportance = node.Duration * node.importanceScore;

                    //Sum up weighted risk and importance
                    sumWeightedRisk += weightedRisk;
                    sumWeightedImportance += weightedImportance;
                    totalPathDuration += node.Duration;

                });

                // Calculate duration-weighted average risk and importance
                const avgWeightedRisk = sumWeightedRisk / totalPathDuration;
                const avgWeightedImportance = sumWeightedImportance / totalPathDuration;


                // Creating a row for each milestone
                const row = document.createElement('tr');

                // Add cells to the row
                ['ID', 'Name', 'avgWeightedRisk', 'avgWeightedImportance', 'Start', 'Finish', 'riskAdjustedEnd', 'slack', 'path_overrun_probability'].forEach(key => {
                    const cell = document.createElement('td');
                    if (key === 'slack') {
                        cell.textContent = Math.round(milestone[key]);
                    } else if (key === 'avgWeightedRisk') {
                        cell.textContent = avgWeightedRisk.toFixed(2);  // Updated to show the duration-weighted average risk
                    } else if (key === 'avgWeightedImportance') {
                        cell.textContent = avgWeightedImportance.toFixed(2);  // Updated to show the duration-weighted average importance
                    } else if (key === 'Start') {
                        cell.textContent = formatDate(startNode.Start);
                    } else if (key === 'Finish') {
                        cell.textContent = formatDate(milestone.Finish);
                    } else if (key === 'riskAdjustedEnd') {
                        cell.textContent = formatDate(milestone.riskAdjustedEnd);
                    } else if (key === 'path_overrun_probability') {
                        cell.textContent = (averageOverrunProbability * 100).toFixed(2) + '%';
                        // Calculate the text color based on averageOverrunProbability
                        const scaledProbability = (averageOverrunProbability - minOverrunProbability) / (maxOverrunProbability - minOverrunProbability);
                        const greenValue = Math.floor((1 - scaledProbability) * 255);
                        const textColor = `rgb(255, ${greenValue}, 0)`;
                        // Set the text color
                        cell.style.color = textColor;
                    } else {
                        cell.textContent = milestone[key];
                    }
                    row.appendChild(cell);
                });



                const MIN_BAR_WIDTH = 15; // Minimum width in pixels

                // Adding a cell for the path
                const pathCell = document.createElement('td');
                pathCell.textContent = longestPath.map(node => node.ID).join(' -> ');
                pathCell.style.width = '400px';  // Set the width of the path column to 300 pixels or any desired value
                row.appendChild(pathCell);

                // Adding a cell for the length of the path
                //const lengthCell = document.createElement('td');
                //lengthCell.textContent = Math.round(longestDuration); // Rounding off the decimal
                //row.appendChild(lengthCell);

                // Add progress bar for PercentComplete
                //const progressCell = document.createElement('td');
                //const progressBar = document.createElement('div');
                // progressBar.style.width = milestone.PercentComplete + '%';
                //progressBar.style.backgroundColor = 'green';
                //progressBar.style.height = '20px';
                //progressCell.appendChild(progressBar);
                //row.appendChild(progressCell);

                tableBody.appendChild(row);

                // Calculate overall progress for the milestone
                const totalCompletedDuration = longestPath.reduce((sum, node) => {
                    let percentComplete = parseFloat(node.PercentComplete);
                    if (isNaN(percentComplete)) { // If conversion to number fails
                        percentComplete = 0; // Default to 0
                    }
                    return sum + node.AdjustedDuration * (percentComplete / 100);
                }, 0);

                const totalProgress = (totalCompletedDuration / longestDuration) * 100; // As a percentage

                // Calculate the planned completion percentage
                const plannedCompletion = longestDuration / nodes.reduce((sum, node) => sum + node.AdjustedDuration, 0);

                // Add progress bars
                const progressBarRow = document.createElement('tr');
                const progressBarCell = document.createElement('td');
                progressBarCell.setAttribute('colspan', '10'); // Span across all columns

                const progressBarWrapper = document.createElement('div');
                progressBarWrapper.style.display = 'flex';
                progressBarWrapper.style.flexDirection = 'column';
                progressBarWrapper.style.alignItems = 'flex-start'; // Align to the start

                // Assuming progressBarCell is already attached to the DOM
                const singleCellWidth = progressBarCell.offsetWidth / 10;
                const availableSpace = singleCellWidth * 10;

                // Adjust the width of the bars to fit within the available space
                //durationDiv.style.maxWidth = availableSpace + 'px';
                //riskAdjustedDurationDiv.style.maxWidth = availableSpace + 'px';

                // Overall Duration Bar (Background Bar)
                const durationDiv = document.createElement('div');
                //durationDiv.style.width = '100%'; // Full width to represent the entire duration
                // Set the width of the durationDiv proportional to its longestDuration
                //durationDiv.style.width = ((longestDuration / maxPathLength) * 100) + MIN_BAR_WIDTH + '%';
                durationDiv.style.width = Math.min(((longestDuration / maxPathLength) * 100) + MIN_BAR_WIDTH, 100) + '%';
                durationDiv.style.background = '#287dc8';
                durationDiv.style.height = '20px';
                durationDiv.style.borderRadius = '10px';
                durationDiv.style.position = 'relative';
                durationDiv.title = `Path Duration: ${longestDuration.toFixed(0)} ${timeUnits}`;

                // Actual ProgresAdds Bar (Foreground Bar)
                const progressDiv = document.createElement('div');
                progressDiv.style.width = totalProgress * 100 + '%';
                //progressDiv.style.background = 'linear-gradient(to right, #5ac8fa, #1e69aa)';
                progressDiv.style.background = barColor;  // <-- New Code
                progressDiv.style.height = '20px';
                progressDiv.style.borderRadius = '10px';
                progressDiv.style.boxShadow = '0 0 10px #5ac8fa';
                //progressDiv.title = 'Overall Progress: ' + (totalProgress * 100).toFixed(2) + '%';
                progressDiv.title = `Overall Progress: ${totalProgress.toFixed(2)}% of the path completed`;


                // Text Displaying the Path Length and Completion
                const pathLengthDiv = document.createElement('div');
                pathLengthDiv.textContent = longestDuration.toFixed(0) + ' ' + timeUnits;
                pathLengthDiv.style.position = 'absolute';
                pathLengthDiv.style.left = '10px';
                pathLengthDiv.style.top = '50%';
                pathLengthDiv.style.transform = 'translateY(-50%)';
                pathLengthDiv.style.color = '#cdfaff';

                const completionDiv = document.createElement('div');
                completionDiv.textContent = (totalProgress * 100).toFixed(0) + '% Completed';
                completionDiv.style.position = 'absolute';
                completionDiv.style.right = '10px';
                completionDiv.style.top = '50%';
                completionDiv.style.transform = 'translateY(-50%)';
                completionDiv.style.color = '#cdfaff';


                // Risk-Adjusted Duration Bar (Background Bar)
                const riskAdjustedDurationDiv = document.createElement('div');
                //riskAdjustedDurationDiv.style.width = ((riskAdjustedDuration / maxPathLength) * 100) + MIN_BAR_WIDTH + '%';
                riskAdjustedDurationDiv.style.width = Math.min(((riskAdjustedDuration / maxPathLength) * 100) + MIN_BAR_WIDTH, 100) + '%';
                //riskAdjustedDurationDiv.style.background = '#113464';  // Darker color
                riskAdjustedDurationDiv.style.background = barColor;  // Darker color
                riskAdjustedDurationDiv.style.height = '20px';
                riskAdjustedDurationDiv.style.borderRadius = '10px';
                riskAdjustedDurationDiv.style.position = 'relative';
                riskAdjustedDurationDiv.style.marginTop = '10px';
                riskAdjustedDurationDiv.title = `Risk-Adjusted Path Duration: ${riskAdjustedDuration.toFixed(0)} ${timeUnits}`;

                // Text Displaying the Risk-Adjusted Path Length
                const riskAdjustedPathLengthDiv = document.createElement('div');
                riskAdjustedPathLengthDiv.textContent = riskAdjustedDuration.toFixed(0) + ' ' + timeUnits;
                riskAdjustedPathLengthDiv.style.position = 'absolute';
                riskAdjustedPathLengthDiv.style.left = '10px';
                riskAdjustedPathLengthDiv.style.top = '50%';
                riskAdjustedPathLengthDiv.style.transform = 'translateY(-50%)';
                riskAdjustedPathLengthDiv.style.color = '#cdfaff';

                durationDiv.appendChild(progressDiv);
                durationDiv.appendChild(pathLengthDiv);
                durationDiv.appendChild(completionDiv);
                riskAdjustedDurationDiv.appendChild(riskAdjustedPathLengthDiv);
                progressBarWrapper.appendChild(riskAdjustedDurationDiv);
                progressBarWrapper.appendChild(durationDiv);
                progressBarCell.appendChild(progressBarWrapper);
                progressBarRow.appendChild(progressBarCell);
                tableBody.appendChild(progressBarRow);
            });
        }
        function initializeTaskCompletionChart(nodes) {
            function computeTaskCompletionCounts() {
                let completed = 0;
                let inProgress = 0;
                let notStarted = 0;

                nodes.forEach(node => {
                    const percentComplete = parseFloat(node.PercentComplete);
                    if (percentComplete === 100) {
                        completed++;
                    } else if (percentComplete > 0) {
                        inProgress++;
                    } else {
                        notStarted++;
                    }
                });

                return [completed, inProgress, notStarted];
            }

            var ctx = document.getElementById('taskCompletion').getContext('2d');

            // Calculate task counts
            const taskCounts = computeTaskCompletionCounts();

            var chart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Completed', 'In Progress', 'Not Started'],
                    datasets: [{
                        data: taskCounts,
                        backgroundColor: ['#1cc88a', '#f6c23e', '#e74a3b']
                    }]
                },
                options: {
                    responsive: true,
                    legend: {
                        labels: {
                            fontColor: "white",
                            boxWidth: 15
                        }
                    }
                }
            });
        }

        function updateKeyDeliverables(nodes, initialNumTasks) {
            const slider = document.getElementById('numTasksSlider');
            const numTasksLabel = document.getElementById('numTasksLabel');

            function renderTasks(numTasks) {
                // Get current date
                const today = new Date();
                const twoWeeksFromNow = new Date(today);
                twoWeeksFromNow.setDate(today.getDate() + 14);
                const twoMonthsFromNow = new Date(today);
                twoMonthsFromNow.setMonth(today.getMonth() + 2);

                // Identify nodes/tasks that fall within the next 2 weeks to 2 months
                let upcomingTasks = nodes.filter(node => {
                    const taskEndDate = new Date(node.Finish);
                    return taskEndDate >= today && taskEndDate <= twoMonthsFromNow;
                });

                // Sort the tasks based on their risk and importance scores
                upcomingTasks.sort((a, b) => {
                    return (b.riskScore + b.importanceScore) - (a.riskScore + a.importanceScore);
                });

                // Take top 'numTasks' tasks
                upcomingTasks = upcomingTasks.slice(0, numTasks);

                if (upcomingTasks.length === 0) {
                    document.getElementById('keyDeliverablesTasksContainer').innerHTML = '<div>No upcoming tasks within the timeframe.</div>';
                    return;
                }

                let html = '';
                upcomingTasks.forEach((task, index) => {
                    const daysToDue = Math.ceil((new Date(task.Finish) - today) / (1000 * 60 * 60 * 24));

                    let dueText;
                    let textColor;
                    if (daysToDue === 1) {
                        dueText = 'Due Tomorrow';
                        textColor = 'text-danger';
                    } else if (daysToDue <= 7) {
                        dueText = `Due in ${daysToDue} days`;
                        textColor = 'text-warning';
                    } else if (daysToDue <= 30) {
                        dueText = `Due in ${daysToDue} days`;
                        textColor = 'text-success';
                    } else {
                        dueText = `Due in ${daysToDue} days`;
                        textColor = 'text-primary';
                    }

                    html += `
                        <div class="row items-push overflow-hidden">
                            <div class="col-xs-2 text-center visibility-hidden" data-toggle="appear" data-class="animated fadeInRight" data-timeout="${(index + 1) * 300}">
                                <canvas id="pieChart${index + 1}" style="max-height: 50px;" class="chart-size"></canvas>
                            </div>
                            <div class="col-xs-10 visibility-hidden" data-toggle="appear" data-class="animated fadeInLeft" data-timeout="${(index + 1) * 100}">
                                <div class="text-uppercase font-w600 text-white-op"><i class="fas fa-tasks"></i> ${task.Name}</div>
                                <div class="font-s36 font-w300 ${textColor}">${dueText}</div>
                            </div>
                        </div>
                        <div class="col-xs-12" style="height: 1px; background-color: #ddd; margin: 10px 0;"></div>`;
                });

                document.getElementById('keyDeliverablesTasksContainer').innerHTML = html;

                // Render pie charts for each task
                upcomingTasks.forEach((task, index) => {
                    const ctx = document.getElementById(`pieChart${index + 1}`).getContext('2d');
                    new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: ['Completed', 'Remaining'],
                            datasets: [{
                                data: [parseInt(task.PercentComplete), 100 - parseInt(task.PercentComplete)],
                                backgroundColor: ['#1cc88a', '#e74a3b']
                            }]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: true,
                            legend: {
                                display: false
                            },
                            tooltips: {
                                enabled: false
                            },
                            cutoutPercentage: 70
                        }
                    });
                });
            }

            // Attach an event listener to the slider to update the tasks when it changes
            slider.addEventListener('input', function () {
                numTasksLabel.textContent = this.value;
                renderTasks(parseInt(this.value));
            });

            // Initial rendering
            renderTasks(initialNumTasks);
        }

        function generatePathsTable(nodes, links) {
            // Assuming paths and links are available
            console.log("generatePathsTable", nodes, links)
            const startNode = nodes.find(node => node.ID === "0");
            const endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);
            const allPaths = findAllPaths(startNode, endNode, links, nodes);
            const criticalPathData = findCriticalPath(allPaths, links);
            const outlierPathsData = findOutlierPaths(allPaths, links);

            // Adjust duration based on time units
            function adjustDuration(duration, timeUnits) {
                switch (timeUnits) {
                    case 'Hours':
                        return duration / 8; // assuming 8-hour workdays
                    case 'Days':
                        return duration;
                    default:
                        return duration;
                }
            }
            // Adjust the duration of each node based on its time units
            nodes.forEach(node => {
                node.AdjustedDuration = adjustDuration(node.Duration, node.TimeUnits);
            });

            // Start generating table
            let tableHTML = '<table border="1">';

            // Table header
            tableHTML += '<tr>';
            tableHTML += '<th>Path Name</th>';
            tableHTML += '<th>Original Duration</th>';
            tableHTML += '<th>Risk Adjusted Duration</th>';

            const maxActivities = Math.max(criticalPathData.path.length, ...outlierPathsData.paths.map(p => p.length));
            for (let i = 1; i <= maxActivities; i++) {
                tableHTML += `<th>Activity ${i}</th>`;
            }

            tableHTML += '</tr>';

            // Critical path data row
            tableHTML += '<tr>';
            tableHTML += '<td>Critical Path</td>';
            tableHTML += `<td>${criticalPathData.duration}</td>`;
            tableHTML += `<td>${Math.round(calculateExpectedOverrunDurationForPath(criticalPathData.path))}</td>`;
            criticalPathData.path.forEach(node => {
                tableHTML += `<td style="color:red;">${node.ID}</td>`;
            });
            for (let i = criticalPathData.path.length; i < maxActivities; i++) {
                tableHTML += '<td style="color:#41afeb;">N/A</td>';
            }
            tableHTML += '</tr>';

            // Sort the outlier paths by their duration
            const sortedOutlierPaths = outlierPathsData.paths.map((path, index) => ({
                path,
                duration: outlierPathsData.durations[index]
            })).sort((a, b) => a.duration - b.duration);

            // Outlier paths data rows
            sortedOutlierPaths.forEach(({ path, duration }, index) => {
                // Scale the color based on index
                const color = d3.scaleLinear()
                    .domain([0, sortedOutlierPaths.length - 1])
                    .range(['orange', 'red'])(index);
                console.log("colorissue", color, duration, criticalPathData.duration);
                tableHTML += '<tr>';
                tableHTML += `<td>Outlier Path ${index + 1}</td>`;
                tableHTML += `<td>${duration}</td>`;
                tableHTML += `<td>${Math.round(calculateExpectedOverrunDurationForPath(path))}</td>`;
                path.forEach(node => {
                    tableHTML += `<td style="color:${color} !important;">${node.ID}</td>`;
                });
                for (let i = path.length; i < maxActivities; i++) {
                    tableHTML += '<td style="color:#41afeb;">N/A</td>';
                }
                tableHTML += '</tr>';
            });

            tableHTML += '</table>';

            // Calculate the longest risk-adjusted duration
            const longestRiskAdjustedDuration = sortedOutlierPaths.reduce((max, curr) => {
                return Math.max(max, Math.round(calculateExpectedOverrunDurationForPath(curr.path)));
            }, 0);

            // Create the bar chart
            function createBarChart() {
                const tooltipDate = d3.select("body").append("div")
                    .attr("class", "tooltip-date")
                    .style("opacity", 0)
                    .style("position", "absolute")
                    .style("background-color", "#f9f9f9")
                    .style("border", "solid")
                    .style("border-width", "1px")
                    .style("border-radius", "5px")
                    .style("padding", "10px")
                    

                const tooltipHour = d3.select("body").append("div")
                    .attr("class", "tooltip-hour")
                    .style("opacity", 0)
                    .style("position", "absolute")
                    .style("background-color", "#f9f9f9")
                    .style("border", "solid")
                    .style("border-width", "1px")
                    .style("border-radius", "5px")
                    .style("padding", "10px")
                    


                // Clear existing SVGs
                d3.select("#progressBars").html("");
                // Retrieve the start date from the Start Milestone
                const startDate = new Date(nodes.find(node => node.ID === "0").Start);
                const endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);
                //const endNode = new Date(nodes.find(node => node.ID === "0").Start);

                // Calculate the planned completion date
                const plannedCompletionDate = new Date(criticalPathData.path[criticalPathData.path.length - 1].Finish);
                const riskAdjustedEndDate = new Date(endNode.riskAdjustedEnd);

                const minDate = d3.min([startDate, plannedCompletionDate, riskAdjustedEndDate]);
                const maxDate = d3.max([startDate, plannedCompletionDate, riskAdjustedEndDate]);


                // Retrieve the planned and risk-adjusted end dates from the End Milestone
               //const plannedCompletionDate = new Date(endNode.Finish); // Using endNode found dynamically
                //const riskAdjustedEndDate = new Date(endNode.riskAdjustedEnd); // Using endNode found dynamically

                // Calculate the total original hours and the total risk-adjusted duration for all activities
                const totalOriginalHours = nodes.reduce((sum, node) => sum + (node.Duration || 0), 0);
                const totalRiskAdjustedDuration = nodes.reduce((sum, node) => sum + (node.riskAdjustedDuration || 0), 0);

                const timeUnits = nodes[0].TimeUnits;

                // Calculate the probable end date
                const probableEndDate = new Date(startDate);
                probableEndDate.setDate(startDate.getDate() + Math.round(longestRiskAdjustedDuration));

                const dateData = [
                    {
                        label: 'Planned Completion',
                        value: adjustDuration(criticalPathData.duration, 'Days'),
                        units: 'Days',
                        startDate: startDate,
                        fontSize: '16px',
                        endDate: plannedCompletionDate
                    },
                    {
                        label: 'Risk Adjusted',
                        value: adjustDuration(longestRiskAdjustedDuration, 'Days'),
                        units: 'Days',
                        startDate: startDate,
                        fontSize: '16px',
                        endDate: riskAdjustedEndDate
                    }
                ];
                // Data for hours
                const hourData = [
                    {
                        label: 'Total Original Hours',
                        value: totalOriginalHours,
                        units: 'Hours',
                        startDate: startDate,
                        fontSize: '16px',
                        endDate: plannedCompletionDate
                    },
                    {
                        label: 'Total Risk-Adjusted Duration',
                        value: totalRiskAdjustedDuration,
                        units: 'Hours',
                        startDate: startDate,
                        fontSize: '16px',
                        endDate: riskAdjustedEndDate
                    }
                ];
                //console.log(data);
                console.log("createBarChart", startDate);
                // Common properties
                const margin = { top: 20, right: 60, bottom: 100, left: 180 };
                const width = 700 - margin.left - margin.right;
                const height = 250 - margin.top - margin.bottom;

                function getRiskAdjustedColor(duration) {
                    if (duration <= 30) {
                        return "green";
                    } else if (duration <= 60) {
                        return "yellow";
                    } else {
                        return "red";
                    }
                }

                // Create SVG for dates
                const svgDates = d3.select("#progressBars").append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const xDates = d3.scaleTime()
                    .domain([startDate, d3.max(dateData, d => d.endDate)])
                    .range([0, width]);

                const yDates = d3.scaleBand()
                    .domain(dateData.map(d => d.label))
                    .range([height, 0])
                    .padding(0.1);

                // Drawing the date bars on svgDates
                svgDates.selectAll(".date-bar")
                    .data(dateData)
                    .enter().append("rect")
                    .attr("class", "date-bar")
                    .attr("y", d => yDates(d.label))
                    .attr("height", yDates.bandwidth())
                    .attr("x", d => xDates(d.startDate))
                    .attr("width", d => xDates(d.endDate) - xDates(d.startDate))
                    //.attr("fill", "blue");  // Choose your color
                    .attr("fill", d => d.label === 'Risk Adjusted' ? getRiskAdjustedColor(d.value) : '#b4f5ff')  // Corrected the label and used the color function
                    .on("mouseover", function (event, d) {
                        tooltipDate.transition()
                            .duration(200)
                            .style("opacity", 1);
                        tooltipDate.html(d.label + "<br/>" + d.value + " " + d.units)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function () {
                        tooltipDate.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });




                // Adding Y-Axis for Date Bars
                svgDates.append("g")
                    .call(d3.axisLeft(yDates))
                    .selectAll("text")
                    .style("font-size", "12px");  // Increased font-size

                // Adding X-Axis for Date Bars
                // Calculate how many days are between the minimum and maximum date
                const numDays = (maxDate - minDate) / (1000 * 60 * 60 * 24);

                // Determine tick interval based on the range of dates
                let tickInterval;
                if (numDays <= 30) {
                    tickInterval = d3.timeDay.every(1);
                } else if (numDays <= 90) {
                    tickInterval = d3.timeWeek.every(1);
                } else if (numDays <= 365) {
                    tickInterval = d3.timeMonth.every(1);
                } else {
                    tickInterval = d3.timeMonth.every(3);
                }
                svgDates.append("g")
                    .attr("transform", `translate(0, ${height})`)
                    .call(d3.axisBottom(xDates).ticks(d3.timeDay.every(tickInterval)).tickFormat(d3.timeFormat('%Y-%m-%d')))
                    .selectAll("text")
                    .attr("transform", "rotate(45)")
                    .style("text-anchor", "start")
                    .style("font-size", "14px"); 

                // Create SVG for hours
                const svgHours = d3.select("#progressBars").append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left},${margin.top})`);

                const xHours = d3.scaleLinear()
                    .domain([0, d3.max(hourData, d => d.value)])
                    .range([0, width]);

                const yHours = d3.scaleBand()
                    .domain(hourData.map(d => d.label))
                    .range([height, 0])
                    .padding(0.1);

                // Drawing the hour bars on svgHours
                svgHours.selectAll(".hour-bar")
                    .data(hourData)
                    .enter().append("rect")
                    .attr("class", "hour-bar")
                    .attr("y", d => yHours(d.label))
                    .attr("height", yHours.bandwidth())
                    .attr("x", 0)  // Starting from zero
                    .attr("width", d => xHours(d.value))  
                    //.attr("fill", "green");  // Choose your color
                    .attr("fill", d => d.label === 'Total Risk-Adjusted Duration' ? getRiskAdjustedColor(d.value) : '#b4f5ff')  // Used the color function
                    .on("mouseover", function (event, d) {
                        tooltipHour.transition()
                            .duration(200)
                            .style("opacity", 1);
                        tooltipHour.html(d.label + "<br/>" + d.value + " " + d.units)
                            .style("left", (event.pageX + 10) + "px")
                            .style("top", (event.pageY - 28) + "px");
                    })
                    .on("mouseout", function () {
                        tooltipHour.transition()
                            .duration(500)
                            .style("opacity", 0);
                    });



                // Adding Y-Axis for Hour Bars
                svgHours.append("g")
                    .call(d3.axisLeft(yHours))
                    .selectAll("text")
                    .style("font-size", "12px");

                // Adding X-Axis for Hour Bars
                svgHours.append("g")
                    .attr("transform", `translate(0, ${height})`)
                    .call(d3.axisBottom(xHours).ticks(10).tickFormat(d => `${d} Hours`))
                    .selectAll("text")
                    .attr("dy", ".35em")
                    .attr("transform", "rotate(45)")
                    .style("text-anchor", "start")
                    .style("font-size", "14px");

            }

            // Call the createBarChart function to insert the chart
            createBarChart();

            // Insert the table into the DOM
            document.getElementById("pathsDistributionTableBody").innerHTML = tableHTML;

            // Make the table sortable
            makeTableSortable(document.getElementById("pathsDistributionTableBody").closest('table'));
        }

        function makeTableSortable(table) {
            // Simple function to sort table rows based on a column
            // This is a basic implementation and might need adjustments based on the table structure
            const headers = table.querySelectorAll('th');
            headers.forEach((header, idx) => {
                header.addEventListener('click', () => {
                    const sortedRows = Array.from(table.rows)
                        .slice(1)  // Skip the header row
                        .sort((rowA, rowB) => {
                            const cellA = rowA.cells[idx].textContent;
                            const cellB = rowB.cells[idx].textContent;
                            return cellA.localeCompare(cellB, undefined, { numeric: true });
                        });
                    table.tBodies[0].append(...sortedRows);
                });
            });
        }

        // Example usage
        // const sortedNodes = topologicalSort(nodes, links);
        // console.log("Topologically sorted nodes:", sortedNodes);
        function topologicalSort(nodes, links) {
            const inDegree = {};  // Initialize in-degree count for each node
            const neighbors = {}; // Neighbors for each node
            const sortedNodes = []; // Final sorted array of nodes
            const queue = []; // Queue to keep track of nodes with in-degree 0

            // Initialize inDegree and neighbors
            nodes.forEach(node => {
                inDegree[node.ID] = 0;
                neighbors[node.ID] = [];
            });

            // Populate inDegree and neighbors from links
            links.forEach(link => {
                const sourceId = link.source.ID || link.source;
                const targetId = link.target.ID || link.target;
                inDegree[targetId]++;
                neighbors[sourceId].push(targetId);
            });

            // Enqueue nodes with in-degree of 0
            for (const nodeId in inDegree) {
                if (inDegree[nodeId] === 0) {
                    queue.push(nodeId);
                }
            }

            while (queue.length > 0) {
                const current = queue.shift();
                sortedNodes.push(current);

                // Decrease in-degree of neighbors by 1
                neighbors[current].forEach(neighbor => {
                    inDegree[neighbor]--;
                    if (inDegree[neighbor] === 0) {
                        queue.push(neighbor);
                    }
                });
            }

            // Check if graph had cycles
            if (sortedNodes.length !== nodes.length) {
                console.error("The graph contains a cycle, so topological sort is not possible.");
                return null;
            }

            // Map sorted node IDs back to node objects
            const sortedNodeObjects = sortedNodes.map(id => nodes.find(node => node.ID === id));

            return sortedNodeObjects;
        }

        function calculateExpectedOverrunDurationForPath(path) {
            return path.reduce((sum, node) => {
                const overrun = node.overrun_probability > 0 ? node.Duration * node.overrun_probability : 0;
                const adjustedDuration = node.Duration + overrun;
                return sum + adjustedDuration;
            }, 0);
        }

        function getDurationInHours(node) {
            return node.TimeUnits === "Hours" ? parseFloat(node.Duration) : parseFloat(node.Duration) * 24;
        }

        function getAdjustedDurationInHours(node) {
            const overrunFactor = 1 + parseFloat(node.overrun_probability);
            return getDurationInHours(node) * overrunFactor;
        }

        // Adjust the Start and Finish times of tasks based on their dependencies and the overrun in their predecessor tasks.
        function adjustTaskTimesWithDependencies(nodes, links) {
            const nodeById = {};
            nodes.forEach(node => {
                nodeById[node.ID] = node;
            });

            function adjustStartTime(node) {
                if (node.adjusted) return;
                const predecessors = links.filter(link => link.target.ID === node.ID).map(link => link.source);
                let maxFinishTime = new Date(node.Start);

                predecessors.forEach(predecessor => {
                    adjustStartTime(predecessor);
                    const adjustedFinish = new Date(predecessor.Finish);
                    adjustedFinish.setTime(adjustedFinish.getTime() + getAdjustedDurationInHours(predecessor) * 3600000 - getDurationInHours(predecessor) * 3600000);
                    if (adjustedFinish > maxFinishTime) {
                        maxFinishTime = adjustedFinish;
                    }
                });

                node.Start = maxFinishTime.toISOString();
                const taskEndTime = new Date(maxFinishTime.getTime() + getDurationInHours(node) * 3600000);
                node.Finish = taskEndTime.toISOString();
                node.adjusted = true;
            }

            nodes.forEach(node => {
                if (!node.adjusted) {
                    adjustStartTime(node);
                }
            });
        }

        function adjustTaskTimesForOverrun(nodes) {
            nodes.forEach(node => {
                const difference = getAdjustedDurationInHours(node) - getDurationInHours(node);
                const taskEnd = new Date(node.Finish);
                taskEnd.setTime(taskEnd.getTime() + difference * 3600000);
                node.AdjustedFinish = taskEnd.toISOString();
            });
        }

        //cumulativeHoursChart
        function getCumulativeDistribution(nodes, links) {
            console.log("CHART_DEBUG: Entering function");

            // Sort nodes by ID to get the start and end dates
            nodes.sort((a, b) => parseInt(a.ID) - parseInt(b.ID));
            const startDate = new Date(nodes[0].Start);
            const endDate = new Date(nodes[nodes.length - 1].riskAdjustedEnd);  // Using riskAdjustedEnd for the final date

            let currentDate = startDate;
            const distribution = [];
            let cumulativeHours = 0;
            let cumulativeHoursWithOverrun = 0;

            let evCumulativeHours = 0;
            let evCurrentDate = startDate

            const distributionWithoutOverrun = [];
            const distributionWithOverrun = [];

            const evDistribution = [];

            const originalEndDate = new Date(Math.max.apply(null, nodes.map(node => new Date(node.Finish))));

            while (currentDate <= endDate) {
                let dailyHours = 0;  // To track how much is added on this date
                let dailyHoursWithOverrun = 0;  // To track how much overrun is added on this date
                let evDailyHours = 0;  // To track how much planned hours is added on this risk-adjusted date
                let maxResourcesForTheDay = 1;  // Initialize with default 1 resource


                nodes.forEach(node => {
                    const taskStart = new Date(node.Start);
                    const taskEnd = new Date(node.Finish);
                    const riskAdjustedEnd = new Date(node.riskAdjustedEnd);
                    // Check for resources required and if it's not there or less than 1, default to 1
                    //const Resources = node.resourcesRequired && node.resourcesRequired > 1 ? node.resourcesRequired : 1;
                    const Resources = node.isOnCriticalPath ? node.resourcesRequired : (node.resourcesRequired && node.resourcesRequired > 1 ? node.resourcesRequired : 1);


                    // Track the maximum number of resources required for all tasks occurring on this date
                    if (taskStart <= currentDate && currentDate <= riskAdjustedEnd) {
                        maxResourcesForTheDay = Math.max(maxResourcesForTheDay, Resources);
                    }

                    if (taskStart <= currentDate && currentDate <= taskEnd) {
                        const daysDuration = differenceInCalendarDays(taskEnd, taskStart) + 1;
                        const dailyDuration = convertToHours(node.Duration, node.TimeUnits || "Hours") / daysDuration;

                        dailyHours += dailyDuration;
                    }

                    if (taskStart <= currentDate && currentDate <= riskAdjustedEnd) {
                        const daysDurationRisk = differenceInCalendarDays(riskAdjustedEnd, taskStart) + 1;
                        const dailyDurationRisk = convertToHours(node.Duration, node.TimeUnits || "Hours") / daysDurationRisk;
                        const overrunDuration = dailyDurationRisk * parseFloat(node.overrun_probability);

                        dailyHoursWithOverrun += dailyDurationRisk + overrunDuration;

                    }

                });

                cumulativeHoursWithOverrun += dailyHoursWithOverrun;
                if (currentDate <= originalEndDate) {
                    cumulativeHours += dailyHours;
                    distributionWithoutOverrun.push({
                        date: currentDate.toISOString().split('T')[0],
                        hours: cumulativeHours
                    });
                }

                distribution.push({
                    date: currentDate.toISOString().split('T')[0],
                    hours: cumulativeHours,
                    hoursWithOverrun: cumulativeHoursWithOverrun
                });

                distributionWithOverrun.push({
                    date: currentDate.toISOString().split('T')[0],
                    hoursWithOverrun: cumulativeHoursWithOverrun
                });
  
                //currentDate = addDurationToDate(currentDate, 24, 8, 5, "Hours");
                currentDate = addDurationToDate(currentDate, 24, 8 * maxResourcesForTheDay, 5, "Hours");
                //currentDate = addDurationToDate(currentDate, 24, 8 * Resources || 1), 5, "Hours");

            }
            // Separate loop for calculating EV
            let evDate = startDate;
            while (evDate <= endDate) {
                let evDailyHours = 0;  // To track how much planned hours is added on this risk-adjusted date
                let maxResourcesForTheDay = 1;  // Initialize with default 1 resource

                nodes.forEach(node => {
                    const taskStart = new Date(node.Start);
                    const taskEnd = new Date(node.Finish);
                    const riskAdjustedEnd = new Date(node.riskAdjustedEnd);

                    // Check for resources required and if it's not there or less than 1, default to 1
                    //const Resources = node.resourcesRequired && node.resourcesRequired > 1 ? node.resourcesRequired : 1;
                    const Resources = node.isOnCriticalPath ? node.resourcesRequired : (node.resourcesRequired && node.resourcesRequired > 1 ? node.resourcesRequired : 1);

                    // Track the maximum number of resources required for all tasks occurring on this date
                    if (taskStart <= evDate && evDate <= riskAdjustedEnd) {
                        maxResourcesForTheDay = Math.max(maxResourcesForTheDay, Resources);
                    }

                    if (taskStart <= evDate && evDate <= riskAdjustedEnd && evDate <= taskEnd) {
                        // Calculate hours based on the original duration but allocate to the risk-adjusted date
                        const daysDuration = differenceInCalendarDays(taskEnd, taskStart) + 1;
                        const evDuration = convertToHours(node.Duration, node.TimeUnits || "Hours") / daysDuration;
                        evDailyHours += evDuration;
                    }
                });

                evCumulativeHours += evDailyHours;
                evDistribution.push({
                    date: evDate.toISOString().split('T')[0],
                    hours: evCumulativeHours
                });

                evDate = addDurationToDate(evDate, 24, 8 * maxResourcesForTheDay, 5, "Hours");
            }


            const yUnits = nodes[0].TimeUnits === "Hours" ? "Cumulative Hours" : "Cumulative Days";

            console.log("CHART_DEBUG: Distribution array created");
            console.log("CHART_DEBUG: Distribution Data", distribution);
            const ctx = document.getElementById('cumulativeHoursChart').getContext('2d');
            const allDates = [...new Set([...distributionWithoutOverrun.map(d => d.date), ...distributionWithOverrun.map(d => d.date)])].sort();

            new Chart(ctx, {
                type: 'line',
                data: {
                    labels: allDates,
                    datasets: [{
                        label: 'Cumulative Hours',
                        data: allDates.map(date => {
                            const entry = distributionWithoutOverrun.find(d => d.date === date);
                            return entry ? entry.hours : null;
                        }),
                        borderColor: '#FF5733',
                        backgroundColor: 'rgba(255, 87, 51, 0.1)',
                        fill: false
                    },
                    {
                        label: 'Cumulative Hours with Overrun',
                        data: allDates.map(date => {
                            const entry = distributionWithOverrun.find(d => d.date === date);
                            return entry ? entry.hoursWithOverrun : null;
                        }),
                        borderColor: '#00AA55',
                        backgroundColor: 'rgba(0, 170, 85, 0.1)',
                        fill: false
                    },
                    {
                        label: 'EV',
                        data: allDates.map(date => {
                            const entry = evDistribution.find(d => d.date === date);
                            return entry ? entry.hours : null;
                            
                        }),
                        borderColor: '#0000FF',  // Use blue color for the EV curve
                        backgroundColor: 'rgba(0, 0, 255, 0.1)',
                        fill: false
                    }]
                },

                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: '#b4f5ff'
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                color: '#5ac8fa'
                            },
                            grid: {
                                color: '#41afeb'
                            },
                            title: {
                                display: true,
                                text: 'Date',
                                color: '#5ac8fa'
                            }
                        },
                        y: {
                            ticks: {
                                color: '#5ac8fa',
                                callback: function (value, index, values) {
                                    //return value + " hrs";
                                    if (nodes[0].TimeUnits === "Hours") {
                                        return value + " hrs";
                                    } else {
                                        // Convert hours to days for display
                                        return (value / 24).toFixed(2) + " days";
                                    }
                                }
                            },
                            grid: {
                                color: '#41afeb'
                            },
                            title: {
                                display: true,
                                text: 'Cumulative Hours', // Always display as hours
                                color: '#5ac8fa'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const value = context.parsed.y;
                                    return (nodes[0].TimeUnits === "Hours") ? value + " hrs" : value + " days";
                                }
                            }
                        }
                    }
                }
            });
            console.log("CHART_DEBUG: Chart should be rendered");
            return distribution;
        }

        function differenceInCalendarDays(date1, date2) {
            const msPerDay = 24 * 60 * 60 * 1000; // number of milliseconds in a day
            return (date1 - date2) / msPerDay;
        }

        function convertToHours(duration, unit) {
            switch (unit) {
                case "Hours":
                    return duration;
                case "Days":
                    return duration * 24;
                default:
                    throw new Error(`Unsupported time unit: ${unit}`);
            }
        }

        function durationToMilliseconds(duration, timeUnits) {
            switch (timeUnits) {
                case 'Hours':
                    return duration * 60 * 60 * 1000;
                case 'Minutes':
                    return duration * 60 * 1000;
                case 'Seconds':
                    return duration * 1000;
                case 'Days':
                    return duration * 24 * 60 * 60 * 1000;
                default:
                    return duration;  // Return the original value if the unit isn't recognized
            }
        }

        function calculateResources(start, end, duration, hoursPerDay = 8, workDaysPerWeek = 5) {
            const startDate = new Date(start);
            const endDate = new Date(end);
            const totalDays = Math.floor((endDate - startDate) / (24 * 60 * 60 * 1000)) + 1;

            let workDays = 0;
            let currentDay = new Date(startDate);
            while (currentDay <= endDate) {
                if (currentDay.getDay() >= 1 && currentDay.getDay() <= workDaysPerWeek) {
                    workDays++;
                }
                currentDay.setDate(currentDay.getDate() + 1);
            }

            // Calculate total available hours for a resource
            const totalAvailableHours = workDays * hoursPerDay;
            // Calculate the number of resources required
            const resourcesRequired = duration / totalAvailableHours;
            // Debug logs
            console.log(`calculateResources Task Start: ${start}, Task End: ${end}, Duration: ${duration}`);
            console.log(`calculateResources Total Days: ${totalDays}, Work Days: ${workDays}`);
            console.log(`calculateResources Total Available Hours: ${totalAvailableHours}, Resources Required: ${resourcesRequired}`);

            return Math.ceil(resourcesRequired); // Round up to ensure all work can be done
        }


        function computeRiskAdjustedDurationsAndDates(nodes, links) {
            const workingHoursPerDay = 8;
            const workingDaysPerWeek = 5;

            const startNode = nodes.find(node => node.ID === "0");
            const endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);
            const paths = findAllPaths(startNode, endNode, links, nodes);

            nodes.forEach(node => {
                const riskAdjustedDuration = node.Duration * (1 + node.overrun_probability);
                node.riskAdjustedDuration = riskAdjustedDuration;
                node.riskAdjustedStart = new Date(node.Start);
                // Check and assign a default value if TimeUnits is undefined
                const timeUnit = node.TimeUnits || "Hours";
                // Calculate resources required for the task
                node.resourcesRequired = calculateResources(node.Start, node.Finish, node.Duration, workingHoursPerDay, workingDaysPerWeek);
                //node.riskAdjustedEnd = addDurationToDate(node.riskAdjustedStart, riskAdjustedDuration, workingHoursPerDay, workingDaysPerWeek, timeUnit);
                //node.riskAdjustedEnd = addDurationToDate(node.riskAdjustedStart, riskAdjustedDuration, workingHoursPerDay * (node.resourcesRequired || 1), workingDaysPerWeek, timeUnit);
                //node.riskAdjustedEnd = addDurationToDate(node.riskAdjustedStart, riskAdjustedDuration, workingHoursPerDay * (node.resourcesRequired && node.resourcesRequired > 1 ? node.resourcesRequired : 1), workingDaysPerWeek, timeUnit);
                if (node.isOnCriticalPath) {
                    node.riskAdjustedEnd = addDurationToDate(node.riskAdjustedStart, riskAdjustedDuration, workingHoursPerDay * node.resourcesRequired, workingDaysPerWeek, timeUnit);
                } else {
                    node.riskAdjustedEnd = addDurationToDate(node.riskAdjustedStart, riskAdjustedDuration, workingHoursPerDay * (node.resourcesRequired && node.resourcesRequired > 1 ? node.resourcesRequired : 1), workingDaysPerWeek, timeUnit);
                }


            });

            paths.forEach(path => {
                path.forEach((node, index) => {
                    if (index === 0) return; // Skip the first node as its risk-adjusted dates are set already

                    const prevNode = path[index - 1];
                    const potentialStartDate = prevNode.riskAdjustedEnd;

                    if (potentialStartDate > node.riskAdjustedStart) {
                        node.riskAdjustedStart = potentialStartDate;
                        const timeUnit = node.TimeUnits || "Hours";
                        //node.riskAdjustedEnd = addDurationToDate(node.riskAdjustedStart, node.riskAdjustedDuration, workingHoursPerDay * (node.resourcesRequired && node.resourcesRequired > 1 ? node.resourcesRequired : 1), workingDaysPerWeek, timeUnit);
                        if (node.isOnCriticalPath) {
                            node.riskAdjustedEnd = addDurationToDate(node.riskAdjustedStart, node.riskAdjustedDuration, workingHoursPerDay * node.resourcesRequired, workingDaysPerWeek, timeUnit);
                        } else {
                            node.riskAdjustedEnd = addDurationToDate(node.riskAdjustedStart, node.riskAdjustedDuration, workingHoursPerDay * (node.resourcesRequired && node.resourcesRequired > 1 ? node.resourcesRequired : 1), workingDaysPerWeek, timeUnit);
                        }

                    }
                });
            });
        }

        // compute the difference between two dates in terms of the given TimeUnits.
        function computeDateDifference(startDate, endDate, workingHoursPerDay, workingDaysPerWeek, timeUnits) {
            const diff = endDate - startDate; // Difference in milliseconds
            switch (timeUnits) {
                case 'Hours':
                    const hours = diff / (1000 * 60 * 60);
                    return hours / workingHoursPerDay;
                case 'Days':
                    return diff / (1000 * 60 * 60 * 24);
                case 'Weeks':
                    return diff / (1000 * 60 * 60 * 24 * 7);
                default:
                    throw new Error(`Unsupported time unit: ${timeUnits}`);
            }
        }
        function addWorkDays(startDate, daysToAdd, workingDaysPerWeek = 5) {
            let endDate = new Date(startDate);
            while (daysToAdd > 0) {
                endDate.setDate(endDate.getDate() + 1);
                // If it's a weekend, don't count it as a day added
                if (endDate.getDay() !== 0 && endDate.getDay() !== 6) {
                    daysToAdd--;
                }
            }
            return endDate;
        }
        //add the given duration (in terms of the given TimeUnits) to a given start date.
        function addDurationToDate(startDate, duration, workingHoursPerDay, workingDaysPerWeek, timeUnits) {
            switch (timeUnits) {
                case 'Hours':
                    let totalHours = duration;
                    let fullDaysFromHours = Math.floor(totalHours / workingHoursPerDay);
                    let remainingHours = totalHours % workingHoursPerDay;
                    let intermediateDate = addWorkDays(startDate, fullDaysFromHours, workingDaysPerWeek);

                    // Adding remaining hours without considering working hours
                    intermediateDate.setHours(intermediateDate.getHours() + remainingHours);
                    return intermediateDate;

                case 'Days':
                    // Add full working days, excluding weekends
                    return addWorkDays(startDate, duration, workingDaysPerWeek);

                case 'Weeks':
                    // Convert weeks to days, then add
                    let daysFromWeeks = duration * workingDaysPerWeek;
                    return addWorkDays(startDate, daysFromWeeks, workingDaysPerWeek);

                default:
                    throw new Error(`Unsupported time unit: ${timeUnits}`);
            }
        }


        //subtract the given duration (in terms of the given TimeUnits) from a given start date.
        function subtractDurationFromDate(startDate, duration, workingHoursPerDay, workingDaysPerWeek, timeUnits) {
            let newDate = new Date(startDate);
            switch (timeUnits) {
                case 'Hours':
                    newDate.setHours(newDate.getHours() - duration * workingHoursPerDay);
                    return newDate;
                case 'Days':
                    newDate.setDate(newDate.getDate() - duration);
                    return newDate;
                case 'Weeks':
                    newDate.setDate(newDate.getDate() - duration * workingDaysPerWeek);
                    return newDate;
                default:
                    throw new Error(`Unsupported time unit: ${timeUnits}`);
            }
        }

        function updateProgressBars(nodes) {
            function renderProgressBar(elementId, progress, gradient) {
                let progressBar = document.getElementById(elementId);
                progressBar.style.transition = 'width 1s ease-in-out, background 1s ease-in-out'; // Animation
                progressBar.style.width = progress + '%';
                if (gradient) {
                    progressBar.style.background = gradient;
                }
            }

            function updateProgressLabel(labelId, progress) {
                let label = document.getElementById(labelId);
                label.textContent = progress.toFixed(2) + '%';
            }

            // Calculate schedule progress
            let startDate = new Date(nodes[0].Start);
            let endDate = new Date(nodes[nodes.length - 1].Finish);
            let currentDate = new Date();
            let scheduleDuration = endDate - startDate;
            let elapsedDuration = currentDate - startDate;
            let scheduleProgress = (elapsedDuration / scheduleDuration) * 100;

            // Cap scheduleProgress at 100%
            if (scheduleProgress > 100) scheduleProgress = 100;

            // Calculate scope progress
            let totalScope = nodes.reduce((sum, node) => sum + parseFloat(node.Duration), 0);
            let completedScope = nodes.reduce((sum, node) => {
                let percentComplete = parseFloat(node.PercentComplete);
                if (isNaN(percentComplete)) percentComplete = 0; // Handle NaN cases
                return sum + parseFloat(node.Duration) * percentComplete / 100;
            }, 0);
            let scopeProgress = (completedScope / totalScope) * 100;

            // Handle NaN in scopeProgress
            if (isNaN(scopeProgress)) scopeProgress = 0;

            // Calculate total budget (proxy for cost)
            let totalBudget = nodes.reduce((sum, node) => sum + parseFloat(node.Duration), 0);

            // Calculate spent budget
            let spentBudget = nodes.reduce((sum, node) => {
                let percentComplete = parseFloat(node.PercentComplete);
                if (isNaN(percentComplete)) percentComplete = 0; // Handle NaN cases
                return sum + parseFloat(node.Duration) * percentComplete / 100;
            }, 0);

            // Calculate budget progress
            let budgetProgress = (spentBudget / totalBudget) * 100;

            // Handle NaN in budgetProgress
            if (isNaN(budgetProgress)) budgetProgress = 0;

            // Dynamic Gradient coding for scope progress bar
            let deviationPercentage = (scopeProgress - scheduleProgress) / scheduleProgress;
            let scopeGradient;
            if (deviationPercentage < -0.1) {
                scopeGradient = 'red';
            } else if (deviationPercentage > 0.1) {
                scopeGradient = 'green';
            } else {
                scopeGradient = `linear-gradient(90deg, yellow, ${deviationPercentage >= 0 ? 'green' : 'red'} ${Math.abs(deviationPercentage * 1000)}%)`;
            }

            // Update the progress bars
            renderProgressBar('budgetProgressBar', budgetProgress);
            updateProgressLabel('budgetProgressLabel', budgetProgress);
            renderProgressBar('scheduleProgressBar', scheduleProgress);
            updateProgressLabel('scheduleProgressLabel', scheduleProgress);
            renderProgressBar('scopeProgressBar', scopeProgress, scopeGradient); // Pass the gradient here
            updateProgressLabel('scopeProgressLabel', scopeProgress);

            // Log for debugging
            console.log("Total Budget:", totalBudget);
            console.log("Spent Budget:", spentBudget);
            console.log("Budget Progress:", budgetProgress);
            console.log("Start Date:", startDate);
            console.log("End Date:", endDate);
            console.log("Current Date:", currentDate);
            console.log("Total Duration:", scheduleDuration);
            console.log("Elapsed Duration:", elapsedDuration);
            console.log("Schedule Progress:", scheduleProgress);
            console.log("Scope Progress:", scopeProgress);
        }



        function constructNetworkUsingPageRankWithDurationsCriticalPathAndOutliers(nodes, links) {
            const dampingFactor = 0.85;
            const convergenceThreshold = 1e-6;
            const maxIterations = 100;
            const criticalPathMultiplier = 2;
            const outlierMultiplier = 1.5;  // Adjust as needed

            let criticalPathSet = new Set(nodes.filter(node => node.isOnCriticalPath).map(node => node.ID));
            let outlierTasksSet = new Set(nodes.filter(node => node.isOnOutlierPath).map(node => node.ID));

            let pageRankValues = {};
            nodes.forEach(node => pageRankValues[node.ID] = 1 / nodes.length);

            // Adjust weighting based on whether a node is part of an outlier path
            for (let link of links) {
                if (outlierTasksSet.has(link.source.ID)) {
                    link.weight = link.weight ? link.weight * outlierMultiplier : outlierMultiplier;
                }
            }

            for (let i = 0; i < maxIterations; i++) {
                let newPageRankValues = {};
                for (let node of nodes) {
                    newPageRankValues[node.ID] = (1 - dampingFactor) / nodes.length;
                    for (let link of links) {
                        if (link.target === node.ID) {
                            let totalWeight = links.filter(l => l.source === link.source).reduce((acc, l) => acc + l.duration, 0);
                            let weight = link.duration;

                            if (criticalPathSet.has(link.source.ID)) {
                                weight *= criticalPathMultiplier;
                            } else if (outlierTasksSet.has(link.source.ID)) {
                                weight *= outlierMultiplier;
                            }

                            newPageRankValues[node.ID] += dampingFactor * (pageRankValues[link.source] * weight / totalWeight);
                        }
                    }
                }

                let diff = 0;
                for (let node of nodes) {
                    diff += Math.abs(newPageRankValues[node.ID] - pageRankValues[node.ID]);
                }
                if (diff < convergenceThreshold) {
                    break;
                }

                pageRankValues = newPageRankValues;
            }

            nodes.sort((a, b) => pageRankValues[b.ID] - pageRankValues[a.ID]);
            let topNodesCount = Math.floor(0.1 * nodes.length);
            let topNodes = nodes.slice(0, topNodesCount);

            // Ensure Start Milestone and End Milestone are present
            const startMilestone = nodes.find(node => node.ID === '0');
            const endMilestone = nodes.find(node => node.ID === nodes[nodes.length - 1].ID);

            if (!topNodes.includes(startMilestone)) {
                topNodes.push(startMilestone);
            }
            if (!topNodes.includes(endMilestone)) {
                topNodes.push(endMilestone);
            }

            // Ensure all nodes (except Start and End Milestone) have at least one predecessor and one successor
            let filteredLinks = links.filter(link => {
                if (link.source === startMilestone || link.target === endMilestone) return true;
                return links.some(l => l.target === link.source) && links.some(l => l.source === link.target);
            });

            let newLinks = links.filter(link => topNodes.includes(link.source) || topNodes.includes(link.target));
            let newNodes = [...new Set(newLinks.map(link => link.source).concat(newLinks.map(link => link.target)))];

            console.log("startMilestone: ", startMilestone, "endMilestone: ", endMilestone)

            console.log("The function constructNetworkUsingPageRankWithDurationsCriticalPathAndOutliers returns", "nodes1: ", newNodes, "links: ", newLinks, "criticalPathSet: ", criticalPathSet, "outlierTasksSet: ", outlierTasksSet)
            return {
                nodes: newNodes,
                links: newLinks,
                criticalPathSet: criticalPathSet,
                outlierTasksSet: outlierTasksSet
            };
        }

        function drawReducedGraphWithVis(nodes, links) {
            console.log("drawReducedGraphWithVis", "nodes: ", nodes, "links: ", links);

            const container = document.getElementById('dependency_chart');
            const configContainer = document.getElementById('configuration-container');


            // Side panel for node information
            const infoPanel = document.getElementById('info-panel');

            // Pan and Centering Controls
            const controlsDiv = document.createElement('div');
            controlsDiv.style.textAlign = 'center';
            controlsDiv.style.padding = '10px';
            controlsDiv.style.backgroundColor = '#f5f5f5'; // Light gray background for better visibility

            const btnLeft = document.createElement('button');
            btnLeft.textContent = '←';
            controlsDiv.appendChild(btnLeft);

            const btnUp = document.createElement('button');
            btnUp.textContent = '↑';
            controlsDiv.appendChild(btnUp);

            const btnDown = document.createElement('button');
            btnDown.textContent = '↓';
            controlsDiv.appendChild(btnDown);

            const btnRight = document.createElement('button');
            btnRight.textContent = '→';
            controlsDiv.appendChild(btnRight);

            const btnCenter = document.createElement('button');
            btnCenter.textContent = 'Center';
            controlsDiv.appendChild(btnCenter);

            container.appendChild(controlsDiv);

            const clusterByHubSizeButton = document.createElement('button');
            clusterByHubSizeButton.textContent = 'Cluster by Hub Size';
            controlsDiv.appendChild(clusterByHubSizeButton);

            const clusterByAttributeButton = document.createElement('button');
            clusterByAttributeButton.textContent = 'Cluster by Attribute';
            controlsDiv.appendChild(clusterByAttributeButton);

            const declusterButton = document.createElement('button');
            declusterButton.textContent = 'De-cluster';
            controlsDiv.appendChild(declusterButton);

            // Search functionality
            const searchInput = document.createElement('input');
            searchInput.setAttribute('placeholder', 'Search for a node...');
            searchInput.addEventListener('input', function () {
                const query = this.value;
                const nodeToFocus = nodes.find(node => node.ID === query || node.Name.includes(query));
                if (nodeToFocus) {
                    network.focus(nodeToFocus.ID, {
                        scale: 1.5,
                        animation: {
                            duration: 500,
                            easingFunction: "easeInOutQuad"
                        }
                    });
                }
            });
            container.appendChild(searchInput);

            console.log("drawReducedGraphWithVis2");

            // Modify nodes based on their degree
            nodes.forEach(node => {
                if (node.degree > 4) {
                    node.color = { background: 'red' };
                } else {
                    node.color = { background: 'blue' };
                }
            });

            // Modify edges based on their length
            links.forEach(edge => {
                edge.label = `Duration: ${edge.length / 20}`;
            });
            console.log("drawReducedGraphWithVis3");
            // Prepare the data
            const data = {
                nodes: new vis.DataSet(nodes.map(node => ({
                    id: node.ID,
                    label: node.ID,
                    title: `<strong>ID:</strong> ${node.ID}<br><strong>Name:</strong> ${node.Name}`,  // enhanced tooltip
                    value: node.degree, // use degree for node size
                    color: node.degree > 2 ? "#46b9fa" : "#8ce6ff",  // dynamic coloring based on degree
                    font: {
                        color: "#ffffff",
                        size: 24
                    }
                }))),
                edges: new vis.DataSet(links.map(link => ({
                    from: link.source.ID,  // use the ID attribute of the source node
                    to: link.target.ID,    // use the ID attribute of the target node
                    arrows: {
                        to: {
                            enabled: true,
                            scaleFactor: 1.5
                        }
                    },
                    color: {
                        color: "#a3d1ff",
                        opacity: 0.8,
                        inherit: 'from'
                    },
                    length: link.duration * 20,
                    hiddenLabel: `Duration: ${isNaN(link.duration) ? 0 : link.duration}`,
                    font: { color: 'transparent' }  // hide the label initially
                })))

            };
            console.log("drawReducedGraphWithVis4", data);
            // Configure the options
            const options = {
                nodes: {
                    shape: "circle",
                    borderWidth: 3,
                    borderWidthSelected: 5,
                    scaling: {
                        min: 20,
                        max: 100
                    },
                    chosen: {
                        node: function (values, id, selected, hovering) {
                            if (hovering) {
                                values.color = '#ffa3a3';  // Color when hovering over the node
                            } else if (selected) {
                                values.color = '#ff0000';  // Color when the node is selected
                            } else {
                                values.color = values.originalColor || "#5ac8fa";  // Default color
                            }
                        }
                    },
                },
                edges: {
                    width: 2.5,
                    smooth: {
                        type: "dynamic"
                    },
                    font: {
                        size: 12,
                        align: 'middle'
                    },
                    chosen: {
                        edge: function (values, id, selected, hovering) {
                            values.color = selected ? '#ff0000' : '#a3d1ff';
                            values.font.color = hovering ? '#000000' : 'transparent'; // Show label on hover
                        }
                    }
                },
                interaction: {
                    hover: true,
                    hoverConnectedEdges: true,
                    selectConnectedEdges: true
                },
                // Physics tweaking options
                physics: {
                    maxVelocity: 50,
                    minVelocity: 0.1,
                    solver: 'barnesHut',
                    barnesHut: {
                        gravitationalConstant: -3000,
                        centralGravity: 0.5
                    },
                    stabilization: {
                        iterations: 2500
                    }
                },
                configure: {
                    enabled: true,              // Enable or disable the panel
                    filter: true,               // The filter function or boolean to determine which options are shown
                    container: configContainer,       // The DOM element where the configuration UI will be created; if not provided, it will be next to the network.
                    showButton: true            // Show or hide the generate options button
                }
            };


            // Initialize the network
            const network = new vis.Network(container, data, options);

            // Cluster by hub size
            clusterByHubSizeButton.addEventListener('click', function () {
                network.clusterByHubsize(undefined, {
                    clusterNodeProperties: {
                        shape: 'box',
                        size: 30,
                        color: '#FF9999',
                        borderWidth: 3,
                        borderWidthSelected: 5,
                        label: 'Cluster'
                    }
                });
            });

            // Cluster by attribute (for this example, we're clustering nodes with similar degrees)
            clusterByAttributeButton.addEventListener('click', function () {
                const clusterOptionsByData = {
                    joinCondition: function (childOptions) {
                        return childOptions.degree > 2;
                    },
                    clusterNodeProperties: {
                        id: 'degreeCluster',
                        borderWidth: 3,
                        shape: 'star',
                        size: 40,
                        color: '#FFFF00',
                        label: 'Nodes with high degree'
                    }
                };
                network.cluster(clusterOptionsByData);
            });

            // De-cluster
            declusterButton.addEventListener('click', function () {
                network.openCluster('degreeCluster');
            });

            // Attach event listeners for the controls
            btnLeft.addEventListener('click', function () {
                const currentPosition = network.getViewPosition();
                network.moveTo({
                    position: { x: currentPosition.x + 100, y: currentPosition.y },
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            });

            btnUp.addEventListener('click', function () {
                const currentPosition = network.getViewPosition();
                network.moveTo({
                    position: { x: currentPosition.x, y: currentPosition.y + 100 },
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            });

            btnRight.addEventListener('click', function () {
                const currentPosition = network.getViewPosition();
                network.moveTo({
                    position: { x: currentPosition.x - 100, y: currentPosition.y },
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            });

            btnDown.addEventListener('click', function () {
                const currentPosition = network.getViewPosition();
                network.moveTo({
                    position: { x: currentPosition.x, y: currentPosition.y - 100 },
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            });

            btnCenter.addEventListener('click', function () {
                network.fit({
                    animation: {
                        duration: 500,
                        easingFunction: 'easeInOutQuad'
                    }
                });
            });

            // Focus on a node and its direct neighbors when the node is clicked
            network.on("click", function (properties) {
                const selectedNodeId = properties.nodes[0];
                if (selectedNodeId) {
                    const selectedNode = nodes.find(node => node.ID === selectedNodeId);
                    infoPanel.innerHTML = `
                        <h3>Node Details</h3>
                        <p><strong>ID:</strong> ${selectedNode.ID}</p>
                        <p><strong>Name:</strong> ${selectedNode.Name}</p>
                        <p><strong>Degree:</strong> ${selectedNode.degree}</p>
                    `;
                } else {
                    infoPanel.innerHTML = '';
                }
            });
            // Node Dragging Enhancements
            network.on("dragEnd", function (params) {
                if (params.nodes.length) {
                    const draggedNode = data.nodes.get(params.nodes[0]);
                    draggedNode.fixed = {
                        x: true,
                        y: true
                    };
                    data.nodes.update(draggedNode);
                }
            });

            // List activities sorted by ID
            const sortedNodes = nodes.sort((a, b) => a.ID - b.ID);
            const activityList = document.createElement("ul");
            sortedNodes.forEach(node => {
                const listItem = document.createElement("li");
                listItem.textContent = node.ID + ": " + node.Name;
                activityList.appendChild(listItem);
            });

            // Append the list to the path-list container
            document.getElementById("path-list").appendChild(activityList);

            // Hover enhancements
            network.on("hoverNode", function (properties) {
                const hoveredNode = nodes.find(node => node.ID === properties.node);
                const tooltipContent = `
                    <strong>ID:</strong> ${hoveredNode.ID}<br>
                    <strong>Name:</strong> ${hoveredNode.Name}
                `;
                // Display this content in a tooltip. (Implementation depends on your tooltip library)
            });

            // Legend (this is a simple example, you'll want to make it more dynamic)
            const legend = document.createElement('div');
            legend.style.marginTop = "20px";
            legend.innerHTML = `
                        <strong>Legend:</strong><br>
                        <span style="display:inline-block; width:12px; height:12px; background-color:red;"></span> High Degree Node<br>
                        <span style="display:inline-block; width:12px; height:12px; background-color:blue;"></span> Low Degree Node<br>
                        <span style="display:inline-block; width:20px; height:2px; background-color:#a3d1ff;"></span> Link (Hover for duration)
                    `;
            container.appendChild(legend);
        }

        function drawArrow(source, target, container) {
            var line = container.append("line")
                .attr("class", "hover-arrow")
                .attr("x1", source.x)
                .attr("y1", source.y)
                .attr("x2", target.x)
                .attr("y2", target.y)
                .attr("stroke", "#0f0") // Sci-fi green color
                .attr("stroke-width", 2)
                .attr("marker-end", "url(#arrow2)");
            return line;
        }

        function removeArrow(container) {
            container.selectAll(".hover-arrow").remove();
        }

        function correctCycle(links, cycleNode, startNode) {
            // Find the link involving the cycleNode and modify the source to the startNode (ID 0)
            let linkToModify = links.find(link => link.target === cycleNode);
            if (linkToModify) {
                linkToModify.source = startNode;
                console.log("Cycle corrected by setting the predecessor of node", cycleNode, "to the start node", startNode);
            } else {
                console.error("Could not correct the cycle for node", cycleNode);
            }
        }

        function displayPaths(paths, title, targetDivID) {
            // Generate the HTML content
            let htmlContent = `<h3>${title}</h3>`;
            paths.forEach((path, index) => {
                htmlContent += `<p>Path ${index + 1}:</p><ul>`;
                path.forEach(node => {
                    htmlContent += `<li>Node ID: ${node.ID}, Name: ${node.Name}</li>`;
                });
                htmlContent += '</ul>';
            });

            // Set the HTML content of the <div> element
            document.getElementById(targetDivID).innerHTML = htmlContent;
        }

        function findCriticalPath(paths, links) {
            console.log("findCriticalPath: Entry, Initial Paths:", paths, links);
            let criticalPath = [];
            let maxDuration = 0;

            paths.forEach(path => {
                let pathDuration = 0;

                console.log(`Evaluating path: ${path.map(node => node.ID).join(" -> ")}`); // Debugging line to display current path

                for (let i = 0; i < path.length - 1; i++) {
                    let link = links.find(l => l.source === path[i] && l.target === path[i + 1]);
                    if (!link) {
                        console.warn(`No link found between ${path[i].ID} and ${path[i + 1].ID}`);  // Warning if link is not found
                        continue;
                    }

                    let linkDuration = Number(link.duration);  // Ensure the duration is a number
                    if (isNaN(linkDuration)) {
                        console.warn(`Invalid duration for link between ${link.source.ID} and ${link.target.ID}`);
                        continue;
                    }

                    pathDuration += linkDuration;

                    console.log(`Duration of link between ${link.source.ID} and ${link.target.ID}: ${linkDuration}`);  // Debugging line
                    console.log(`Cumulative path duration: ${pathDuration}`);  // Debugging line
                }

                if (pathDuration > maxDuration) {
                    maxDuration = pathDuration;
                    criticalPath = path;
                }
            });
            // Label nodes on the critical path
            criticalPath.forEach(node => {
                node.isOnCriticalPath = true;
            });
            console.log("Critical path:", criticalPath.map(node => node.ID).join(" -> "), "Max Duration: ", maxDuration); // Debugging line
            return { path: criticalPath, duration: maxDuration };
        }

        function findOutlierPaths(paths, links) {
            const MIN_OUTLIER_PATHS = 5;  // Adjust this as needed

            console.log("findOutlierPaths: Entry, Initial Paths:", paths, links);

            // Calculate the total duration for each path
            const pathDurations = paths.map(path => {
                return {
                    path,
                    duration: path.reduce((total, node, index, array) => {
                        if (index < array.length - 1) {
                            const link = links.find(l => l.source.ID === node.ID && l.target.ID === array[index + 1].ID);
                            return link ? total + Number(link.duration) : total;
                        }
                        return total;
                    }, 0)
                };
            });

            // Remove duplicate paths
            const uniquePathDurations = [];
            pathDurations.forEach(pathDuration => {
                const pathString = JSON.stringify(pathDuration.path.map(node => node.ID));
                if (!uniquePathDurations.some(unique => JSON.stringify(unique.path.map(node => node.ID)) === pathString)) {
                    uniquePathDurations.push(pathDuration);
                }
            });

            // Sort the unique pathDurations based on duration
            uniquePathDurations.sort((a, b) => a.duration - b.duration);

            // Calculate the first and third quartiles (Q1 and Q3)
            const q1 = uniquePathDurations[Math.floor(uniquePathDurations.length / 4)].duration;
            const q3 = uniquePathDurations[Math.floor(3 * uniquePathDurations.length / 4)].duration;

            // Calculate the interquartile range (IQR)
            const iqr = q3 - q1;

            let adjustmentFactor = 1.5;  // Starting factor for IQR
            let outlierPathDurations;

            do {
                // Set the lower and upper thresholds
                const lowerThreshold = q1 - adjustmentFactor * iqr;
                const upperThreshold = q3 + adjustmentFactor * iqr;

                // Filter the outlier paths based on the thresholds
                outlierPathDurations = uniquePathDurations.filter(pathDuration => pathDuration.duration < lowerThreshold || pathDuration.duration > upperThreshold);

                // Reduce the adjustment factor to lax the bounds and find more outliers
                adjustmentFactor -= 0.1;
            } while (outlierPathDurations.length < MIN_OUTLIER_PATHS && adjustmentFactor >= 0);

            // Log information
            outlierPathDurations.forEach(pathDuration => {
                console.log(`Outlier Path:`);
                pathDuration.path.forEach((node, nodeIndex) => {
                    let linkDuration = 0;
                    if (nodeIndex < pathDuration.path.length - 1) {
                        let link = links.find(l => l.source === node && l.target === pathDuration.path[nodeIndex + 1]);
                        linkDuration = link ? Number(link.duration) : 0;
                    }
                    console.log(`Node ID: ${node.ID}, Node Duration: ${node.Duration}, Link Duration to next node: ${linkDuration}`);
                });
                console.log(`Total Duration for Path:`, pathDuration.duration);
            });

            // Label nodes on the outlier paths
            outlierPathDurations.forEach(pathDuration => {
                pathDuration.path.forEach(node => {
                    node.isOnOutlierPath = true;
                });
            });

            return {
                paths: outlierPathDurations.map(pd => pd.path),
                durations: outlierPathDurations.map(pd => pd.duration)
            };
        }


        // Displaying all paths
        displayPaths(paths, 'All Paths:', 'pathsDisplay');
        // Displaying the longest path and outlier paths
        displayPaths([longestPath], 'Longest Path:', 'longestPathDisplay');
        displayPaths(outlierPaths, 'Outlier Paths:', 'outlierPathsDisplay');

        document.getElementById("highlightCriticalPath").addEventListener("change", updatePathsDisplay);
        document.getElementById("highlightOutliers").addEventListener("change", updatePathsDisplay);

        function updatePathsDisplay() {
            // Clear previous highlights
            clearHighlights();

            // Update critical path, outlier paths, and all paths based on checkboxes
            updateCriticalPathDisplay();
            updateOutlierPathsDisplay();
            updateAllPathsDisplay();
        }

        var acc = document.getElementsByClassName("accordion-button");
        var i;

        for (i = 0; i < acc.length; i++) {
            acc[i].addEventListener("click", function () {
                this.classList.toggle("active");
                var panel = this.nextElementSibling;
                if (panel.style.maxHeight) {
                    panel.style.maxHeight = null;
                } else {
                    panel.style.maxHeight = panel.scrollHeight + "px";
                }
            });
        }

        function highlightPath(path, color, link, node, duration) {
            link.style("stroke", function (l) {
                if (path.includes(l.source) && path.includes(l.target)) {
                    return color;
                }
                // Keep the existing color if not in the path
                return d3.select(this).style("stroke");
            }).attr("stroke-width", function (l) {
                if (path.includes(l.source) && path.includes(l.target)) {
                    return 4;
                }
                // Keep the existing stroke-width if not in the path
                return d3.select(this).attr("stroke-width");
            });

            node.select("circle").style("fill", function (n) {
                if (path.includes(n)) {
                    return color;
                }
                // Keep the existing fill color if not in the path
                return d3.select(this).style("fill");
            }).attr("r", function (n) {
                if (path.includes(n)) {
                    return 30;
                }
                // Keep the existing radius if not in the path
                return d3.select(this).attr("r");
            });

            var tooltip = d3.select(".tooltip");
            tooltip.html(`Path Duration: ${duration} units`).style("background-color", 'color');
        }

        function findDistancesToEnd(startNode, endNode, links, nodes) {
            const neighborsMap = {};
            nodes.forEach(node => {
                neighborsMap[node.ID] = links
                    .filter(link => (link.source.ID || link.source) === node.ID)
                    .map(link => nodes.find(n => n.ID === (link.target.ID || link.target)));
            });

            console.log('findDistancesToEnd Neighbors Map:', neighborsMap);

            const shortestDistances = {};  // for memoization of shortest distances
            const longestDistances = {};  // for memoization of longest distances

            function dfs(currentNode, visited) {
                console.log('Visiting node:', currentNode.ID);

                if (currentNode.ID === endNode.ID) {
                    console.log('Reached end node:', currentNode.ID);
                    return [0, 0];
                }

                if (shortestDistances[currentNode.ID] !== undefined && longestDistances[currentNode.ID] !== undefined) {
                    console.log('findDistancesToEnd Distances already computed for node:', currentNode.ID);
                    return [shortestDistances[currentNode.ID], longestDistances[currentNode.ID]];
                }

                visited.add(currentNode.ID);

                let minDistance = Infinity;
                let maxDistance = -Infinity;
                for (let neighbor of neighborsMap[currentNode.ID]) {
                    if (!visited.has(neighbor.ID)) {

                        // Use Duration from the neighbor node
                        const nodeDuration = Number(neighbor.Duration) || 0;  // convert to number, use 0 if NaN or missing

                        const [minDistThroughNeighbor, maxDistThroughNeighbor] = dfs(neighbor, visited);
                        const distanceThroughNeighbor = nodeDuration + minDistThroughNeighbor;
                        const distanceThroughNeighborMax = nodeDuration + maxDistThroughNeighbor;

                        minDistance = Math.min(minDistance, distanceThroughNeighbor);
                        maxDistance = Math.max(maxDistance, distanceThroughNeighborMax);
                    }
                }

                visited.delete(currentNode.ID);

                shortestDistances[currentNode.ID] = isFinite(minDistance) ? minDistance : 0;
                longestDistances[currentNode.ID] = isFinite(maxDistance) ? maxDistance : 0;

                console.log('findDistancesToEnd Computed distances for node', currentNode.ID, ':', minDistance, maxDistance);

                return [minDistance, maxDistance];
            }

            dfs(startNode, new Set());

            // Store the distances as node properties
            nodes.forEach(node => {
                node.shortestDistanceToEnd = shortestDistances[node.ID] !== undefined ? shortestDistances[node.ID] : 0;
                node.longestDistanceToEnd = longestDistances[node.ID] !== undefined ? longestDistances[node.ID] : 0;
            });

            console.log('findDistancesToEnd Shortest Distances:', shortestDistances);
            console.log('findDistancesToEndLongest Distances:', longestDistances);

            return { shortestDistances, longestDistances };
        }

        const KMeans = require('shaman').KMeans;  // Use any k-means library

        function findActivityClusters(nodes, numClusters) {
            // Prepare data: Assuming nodes have attributes like 'duration', 'riskExposure' etc.
            const data = nodes.map(node => [node.duration, node.riskExposure, node.resourceCount]);

            // Run k-means clustering
            const kmeans = new KMeans(numClusters);
            kmeans.cluster(data, (err) => {
                if (err) throw new Error(err);

                // Assign each node to a cluster
                nodes.forEach((node, index) => {
                    node.activityCluster = kmeans.centroids[kmeans.assignments[index]];
                });
            });
        }

        function findPathClusters(paths, numClusters) {
            // Prepare data: Assuming each path is an array of nodes
            const data = paths.map(path => {
                const totalDuration = path.reduce((sum, node) => sum + node.duration, 0);
                const totalRisk = path.reduce((sum, node) => sum + node.riskExposure, 0);
                const resourceOverlap = calculateResourceOverlap(path);  // Implement this function as needed
                return [totalDuration, totalRisk, resourceOverlap];
            });

            // Run k-means clustering
            const kmeans = new KMeans(numClusters);
            kmeans.cluster(data, (err) => {
                if (err) throw new Error(err);

                // Assign each path to a cluster
                paths.forEach((path, index) => {
                    path.pathCluster = kmeans.centroids[kmeans.assignments[index]];
                });
            });
        }


        function clearHighlights(link, node) {
            link.style("stroke", null)
                .attr("stroke-width", 2);

            node.select("circle").style("fill", function (d) {
                var selectedMetric = document.querySelector('input[name="colorMetric"]:checked').value;
                var metricValue;

                console.log("Colors", "Selected Metric: ", selectedMetric);

                switch (selectedMetric) {
                    case "inDegree":
                        metricValue = d.inDegree;
                        break;
                    case "outDegree":
                        metricValue = d.outDegree;
                        break;
                    case "degree":
                        metricValue = d.degree;
                        break;
                    case "risk":
                        metricValue = d.riskScore;
                        break;
                    case "importance":
                        metricValue = d.importanceScore;
                        break;
                    default:
                        metricValue = d.inDegree; // default to in-degree if something goes wrong
                }

                console.log("Colors", "Metric Value: ", metricValue);

                if (selectedMetric === "risk") {
                    console.log("Colors", "Color: risk importance");
                    switch (true) {
                        case metricValue > 0.2: return "red";
                        case metricValue > 0.1: return "orange";
                        case metricValue > 0.05: return "yellow"; // Adjusted based on logical progression
                        case metricValue > 0.025: return "yellowgreen";
                        default: return "green";
                    }
                } else if (selectedMetric === "importance") {
                    console.log("Colors", "Color: risk importance");
                    switch (true) {
                        case metricValue > 0.5: return "red";
                        case metricValue > 0.3: return "orange";
                        case metricValue > 0.2: return "yellow";
                        case metricValue > 0.1: return "yellowgreen";
                        default: return "green";
                    }
                } else {
                    console.log("Colors", "Color: degree");
                    switch (true) {
                        case metricValue > 4: return "#41afeb";
                        case metricValue > 3: return "#46b9fa";
                        case metricValue > 2: return "#5ac8fa";
                        case metricValue > 1: return "#8ce6ff";
                        default: return "#b4f5ff";
                    }
                }
            });
        }

        function updateCriticalPathDisplay() {
            if (document.getElementById("highlightCriticalPath").checked) {
                const criticalPath = findCriticalPath(paths, links);
                highlightPath(criticalPath.path, 'red'); // Highlight the critical path in red
            }
        }

        function updateOutlierPathsDisplay() {
            if (document.getElementById("highlightOutliers").checked) {
                const outlierPaths = findOutlierPaths(paths, links);
                outlierPaths.paths.forEach(outlierPath => {
                    highlightPath(outlierPath, 'orange'); // Highlight outlier paths in orange
                });
                const criticalPath = findCriticalPath(paths, links);
                highlightPath(criticalPath.path, 'red'); // Highlight the critical path in red
            }
        }

        function updateAllPathsDisplay() {
            // If you want to highlight all paths in a specific color, you can do so here
            paths.forEach(path => {
                highlightPath(path, 'blue'); // Highlight all paths in blue
            });
        }

        function updateLegend() {
            var selectedMetric = document.querySelector('input[name="colorMetric"]:checked').value;
            var metricText;

            switch (selectedMetric) {
                case "inDegree":
                    metricText = "In-degree";
                    break;
                case "outDegree":
                    metricText = "Out-degree";
                    break;
                case "degree":
                    metricText = "Degree";
                    break;
                default:
                    metricText = "In-degree"; // default to in-degree if something goes wrong
            }

            document.getElementById("legendMetric").textContent = metricText;
        }
        function showTooltip(content, color) {
            const tooltip = d3.select("#tooltip");
            tooltip.transition()
                .duration(200)
                .style("visibility", "visible");
            tooltip.html(content)
                .style("top", "10px")
                .style("right", "10px")
                .style("color", color);
        }

        function hideTooltip() {
            console.log("highlight hideTooltip called");
            const tooltip = d3.select("#tooltip");
            tooltip.transition()
                .duration(500)
                .style("visibility", "hidden");
        }

        // Add event listener to the radio buttons to update the legend when the metric changes
        var radios = document.querySelectorAll('input[name="colorMetric"]');
        radios.forEach(radio => {
            radio.addEventListener("change", updateLegend);
        });

        // Call this once at the start to set the initial state of the legend:
        updateLegend();

        function drawCharts(nodes, links) {
            let dampingFactor = 0.85;  // Example damping factor for PageRank, adjust as needed
            let maxIterations = 100;   // Example max iterations for both PageRank and Eigenvector centrality

            computeNetworkMetrics(nodes, links, dampingFactor, maxIterations).then(result => {
                console.log("Updated Nodes with Metrics:", result.updatedNodes);
                console.log("Network Density:", result.networkDensity);
                computeRiskAdjustedDurationsAndDates(nodes, links);
                // Move all your drawing functions inside this .then() block
                drawScatterPlotWithD3(result.updatedNodes, links);  // Use the updated nodes
                console.log("Drawing S-Curve...");
                drawSCurve(result.updatedNodes, links);  // Use the updated nodes
                console.log("Drawing Histogram...");
                drawHistogramChartJS(result.updatedNodes, links);  // Use the updated nodes
                console.log("Drawing Pie Chart...");
                drawPieChart(result.updatedNodes, links);  // Use the updated nodes
                drawPathsDistributionCurve(result.updatedNodes, links);  // Use the updated nodes
                drawRadialChart(result.updatedNodes, links);  // Use the updated nodes
                drawPathDistributionStackedBarChart(nodes, links)
                drawReferenceTable(nodes);
                // Assuming you have paths and links available
                //const criticalPathData = findCriticalPath(paths, links);
                //const outlierPathsData = findOutlierPaths(paths, links);
                //populatePathsTable(criticalPathData, outlierPathsData);
                // Call the function to render the Risk Matrix chart
                drawRiskMatrix(result.updatedNodes, links);  // Use the updated nodes
                // Generate the paths table
                generatePathsTable(result.updatedNodes, links);
                generateKanbanCards(nodes, links);
                drawMilestoneTable(nodes, links);
                populateInternalMilestones(nodes)
                initializeTaskCompletionChart(nodes);
                getCumulativeDistribution(nodes, links);
                updateKeyDeliverables(nodes, 5);  // initially show 5 tasks
                updateProgressBars(nodes);
                // Generate reduced graph using PageRank with durations, critical path, and outliers
                console.log("About to Enter drawReducedGraphWithVis");
                const result1 = constructNetworkUsingPageRankWithDurationsCriticalPathAndOutliers(result.updatedNodes, links);
                const resultReduced = constructNetworkUsingPageRankWithDurationsCriticalPathAndOutliers(result1.nodes, result1.links);
                //console.log("About to Enter drawReducedGraphWithVis2", resultReduced.nodes, resultReduced.links, resultReduced.criticalPathSet, resultReduced.outlierTasksSet);
                //drawReducedGraphWithVis(resultReduced.nodes, resultReduced.links, resultReduced.criticalPathSet, resultReduced.outlierTasksSet);
                drawReducedGraphWithVis(resultReduced.nodes, resultReduced.links);

            });
        }

        google.charts.load('current', { 'packages': ['corechart'] });
        google.charts.setOnLoadCallback(initializeDataAndDrawCharts);

        function drawSCurve(nodes, links) {
            links.forEach(link => {
                link.duration = +link.duration;
            });
            console.log("Drawing S-Curve with nodes data:", nodes);
            console.log("Drawing S-Curve with links data:", links);
            // Convert all durations to numbers

            //let tasksSortedByDuration = links.slice().sort((a, b) => a.duration - b.duration);
            let nonZeroDurationTasks = links.filter(link => link.duration > 0); // filtering out tasks with a duration of 0
            let tasksSortedByDuration = nonZeroDurationTasks.slice().sort((a, b) => a.duration - b.duration);

            let cumulativeData = [["Duration", "Cumulative Count"]];
            let cumulativeCount = 0;

            for (let link of tasksSortedByDuration) {
                cumulativeCount++;
                cumulativeData.push([link.duration, cumulativeCount]);
            }

            var maxDuration = Math.max(...cumulativeData.map(d => d[0]));
            var data = google.visualization.arrayToDataTable(cumulativeData);
            var options = {
                title: 'S-Curve of Task Completion',
                titleTextStyle: { color: '#ffffff' },  // Setting the title text color to white
                hAxis: { title: 'Duration', textStyle: { color: '#b4f5ff' }, gridlines: { color: '#195a8c' }, baselineColor: '#3292cd' },
                vAxis: { title: 'Cumulative Count', textStyle: { color: '#b4f5ff' }, gridlines: { color: '#195a8c' }, baselineColor: '#3292cd' },
                legend: {
                    position: 'bottom',
                    textStyle: { color: '#ffffff' } // Setting the legend text color to white
                },
                backgroundColor: '#113464',
                colors: ['#46b9fa'] // Color for the line
            };
            options.hAxis.viewWindow = { min: 0, max: maxDuration };
            var chart = new google.visualization.LineChart(document.getElementById('scurve_chart'));
            chart.draw(data, options);
        }

        function drawHistogramChartJS(nodes, links) {
            console.log("Drawing Histogram with links data:", links);

            let durations = links.map(link => link.duration);
            let histogramData = {};
            let taskNamesForDuration = {}; // Store task names for each duration

            durations.forEach((duration, index) => {
                if (histogramData[duration]) {
                    histogramData[duration]++;
                    taskNamesForDuration[duration].push(links[index].source.Name + " to " + links[index].target.Name); // Assuming source and target have a 'Name' property
                } else {
                    histogramData[duration] = 1;
                    taskNamesForDuration[duration] = [links[index].source.Name + " to " + links[index].target.Name];
                }
            });

            let maxDuration = Math.max(...durations);

            var xTicks = [];
            for (let i = 0; i <= maxDuration; i++) {
                xTicks.push(i);
            }

            new Chart(document.getElementById('histogramChart').getContext('2d'), {
                type: 'bar',
                data: {
                    labels: Object.keys(histogramData),
                    datasets: [{
                        label: 'Task Durations',
                        data: Object.values(histogramData),
                        backgroundColor: 'rgba(70, 185, 250, 0.5)',
                        borderColor: 'rgba(70, 185, 250, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Tasks',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#b4f5ff'
                            },
                            grid: {
                                color: '#195a8c'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Task Duration',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#b4f5ff',
                                autoSkip: false,
                                maxRotation: 90,
                                minRotation: 90
                            },
                            grid: {
                                color: '#195a8c'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    let duration = context.label;
                                    let taskNames = taskNamesForDuration[duration];
                                    return [
                                        'Duration: ' + duration,
                                        'Number of Tasks: ' + histogramData[duration],
                                        'Tasks: ' + taskNames.join(', ')
                                    ];
                                }
                            }
                        }
                    }
                }
            });
        }


        function drawPieChart(nodes, links) {
            console.log("Drawing Pie Chart with links data:", links);

            const sliceCount = 5; // Number of slices we want on our pie chart
            let durations = links.map(link => link.duration).sort((a, b) => a - b);
            let maxDuration = durations[durations.length - 1];
            let minDuration = durations[0];
            let rangeSize = Math.ceil((maxDuration - minDuration + 1) / sliceCount);
            let durationRanges = {};

            // Initialize the ranges
            for (let i = 0; i < sliceCount; i++) {
                let start = minDuration + i * rangeSize;
                let end = start + rangeSize - 1;
                if (i === sliceCount - 1) {
                    end = maxDuration; // For the last slice, ensure the end is the actual max duration
                }
                let key = start === end ? `${start}` : `${start}-${end}`;
                durationRanges[key] = 0;
            }

            // Categorize durations
            for (let link of links) {
                let category = Object.keys(durationRanges).find(range => {
                    let [start, end] = range.split('-').map(Number);
                    if (!end) end = start; // For ranges representing a single value
                    return link.duration >= start && link.duration <= end;
                });
                durationRanges[category]++;
            }

            // Generate the pie data with counts appended to the labels
            let pieData = [["Duration Range", "Count"]];
            for (let range in durationRanges) {
                pieData.push([`${range} days (${durationRanges[range]} tasks)`, durationRanges[range]]);
            }

            var data = google.visualization.arrayToDataTable(pieData);
            var options = {
                title: 'Distribution of Task Durations with Task Counts',
                titleTextStyle: { color: '#ffffff' },
                backgroundColor: '#113464',
                legend: {
                    position: 'bottom',
                    textStyle: { color: '#ffffff' }
                },
                tooltip: {
                    text: 'percentage',  // Display percentage in the tooltip
                    textStyle: { color: '#000000' }  // Set tooltip text color to black
                }
            };

            var chart = new google.visualization.PieChart(document.getElementById('pie_chart'));
            chart.draw(data, options);
        }


        function drawPathsDistributionCurve(nodes, links) {
            // Find start and end nodes
            var startNode = nodes.find(node => node.ID === "0"); // Assuming ID is a string
            var endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);

            // Find all paths from startNode to endNode
            var paths = findAllPaths(startNode, endNode, links, nodes);

            // Calculate the total duration for each path
            const pathDurations = paths.map(path => {
                return path.reduce((total, node, index, array) => {
                    if (index < array.length - 1) {
                        let link = links.find(l => l.source === node && l.target === array[index + 1]);
                        if (!link) {
                            return total;
                        }
                        return total + link.duration;
                    }
                    return total;
                }, 0);
            });

            // Group paths by their duration to get counts
            const durationCounts = {};
            pathDurations.forEach(duration => {
                durationCounts[duration] = (durationCounts[duration] || 0) + 1;
            });

            // Convert the durationCounts object to an array suitable for Google Charts
            const dataForChart = [["Path Length", "Number of Paths"]];
            for (let duration in durationCounts) {
                dataForChart.push([+duration, durationCounts[duration]]);
            }

            var data = google.visualization.arrayToDataTable(dataForChart);
            var options = {
                title: 'Distribution of Path Lengths',
                titleTextStyle: { color: '#ffffff' },
                hAxis: {
                    title: 'Path Length',
                    titleTextStyle: { color: '#ffffff' }, // Set title text color to white
                    textStyle: { color: '#b4f5ff' },
                    gridlines: { color: '#195a8c' },
                    baselineColor: '#3292cd'
                },
                vAxis: {
                    title: 'Number of Paths',
                    titleTextStyle: { color: '#ffffff' }, // Set title text color to white
                    textStyle: { color: '#b4f5ff' },
                    gridlines: { color: '#195a8c' },
                    baselineColor: '#3292cd'
                },
                legend: {
                    position: 'bottom',
                    textStyle: { color: '#ffffff' }
                },
                backgroundColor: '#113464',
               
                colors: ['#46b9fa'],
                chartArea: {
                    width: '90%',  // Adjust based on your needs
                    // height: '100%'  
                }
            };

            var chart = new google.visualization.LineChart(document.getElementById('path_distribution_chart'));
            chart.draw(data, options);
        }

        function formatDate(dateString) {
            let date = new Date(dateString);
            let day = String(date.getUTCDate()).padStart(2, '0');
            let month = String(date.getUTCMonth() + 1).padStart(2, '0'); // Months are 0-indexed in JS
            let year = date.getUTCFullYear();
            return `${day}-${month}-${year}`;
        }


        function drawRiskMatrix(nodes, links) {
            console.log("Entered drawRiskMatrix", nodes, links);

            // Check nodes and links length
            console.log("drawRiskMatrix Number of nodes:", nodes.length);
            console.log("drawRiskMatrix Number of links:", links.length);

            var scores = nodes.map(node => ({
                id: node.ID,
                riskScore: node.riskScore,
                importanceScore: node.importanceScore,
                combinedScore: (node.riskScore + node.importanceScore) / 2,
                name: node.Name,
                start: node.Start,
                finish: node.Finish,
                riskAdjustedStart: node.riskAdjustedStart,
                riskAdjustedEnd: node.riskAdjustedEnd,
                pageRank: node.pageRank,
                slack: node.slack,
                path: node.isOnCriticalPath ? 'Critical Path' :
                    node.isOnOutlierPath ? 'Outlier Path' : 'Regular Path',
                overrunProbability: node.overrun_probability || 0  // Added this line
            }));

            // First, find the min and max combined scores
            // Log the combined scores for validation
            console.log("drawRiskMatrix Combined scores:", scores.map(s => s.combinedScore));

            const minCombinedScore = Math.min(...scores.map(s => s.combinedScore));
            const maxCombinedScore = Math.max(...scores.map(s => s.combinedScore));

            // Define the getColorForCombinedScore function within the drawRiskMatrix function
            function getColorForCombinedScore(combinedScore) {
                // If the combinedScore is NaN, return a distinct color
                if (isNaN(combinedScore)) {
                    return `rgb(128, 128, 128)`;  // Return a neutral gray color
                }

                // If max and min combined scores are essentially the same, normalize to 0.5 (middle value)
                if (maxCombinedScore - minCombinedScore < 0.0001) {
                    combinedScore = (maxCombinedScore + minCombinedScore) / 2;
                }

                const normalizedScore = (combinedScore - minCombinedScore) / (maxCombinedScore - minCombinedScore);

                const red = Math.floor(255 * normalizedScore);
                const green = Math.floor(255 * (1 - normalizedScore));

                const color = `rgb(${red}, ${green}, 0)`;
                console.log("Returning color:", color);  // Debug log
                return color;
            }

            // Function to calculate IQR and identify outliers
            const MIN_OUTLIERS = 5;  // Adjust this as needed

            function identifyOutliers(data) {
                const values = data.slice().sort((a, b) => a - b);
                const q1 = values[Math.floor((values.length / 4))];
                const q3 = values[Math.floor((values.length * 3) / 4)];
                const iqr = q3 - q1;

                let adjustmentFactor = 5; // Start with 5 as the adjustment factor for IQR
                let outliers;

                do {
                    const lowerBound = q1 - adjustmentFactor * iqr;
                    const upperBound = q3 + adjustmentFactor * iqr;
                    outliers = data.map(score => score < lowerBound || score > upperBound);

                    // Decrease the adjustment factor to lax the bounds and find more outliers
                    adjustmentFactor -= 0.5;
                } while (outliers.filter(Boolean).length < MIN_OUTLIERS && adjustmentFactor >= 0);

                return outliers;
            }

            const riskOutliers = identifyOutliers(scores.map(s => s.riskScore));
            const importanceOutliers = identifyOutliers(scores.map(s => s.importanceScore));

            nodes.forEach((node, idx) => {
                node.isRiskOutlier = riskOutliers[idx];
            });
            nodes.forEach((node, idx) => {
                node.isImportanceOutlier = importanceOutliers[idx];
            });


            // Filter nodes to only include outliers based on risk or importance
            const outlierScores = scores.filter((_, idx) => riskOutliers[idx] || importanceOutliers[idx]);

            const scatterData = outlierScores.map(score => ({
                x: score.riskScore,
                y: score.importanceScore,
                combinedScore: score.combinedScore,
                name: score.name,
                path: score.path
            }));

            const maxRisk = Math.max(...scores.map(s => s.riskScore));
            const minRisk = Math.min(...scores.map(s => s.riskScore));

            const maxImportance = Math.max(...scores.map(s => s.importanceScore));
            const minImportance = Math.min(...scores.map(s => s.importanceScore));

            const riskRange = maxRisk - minRisk;
            const importanceRange = maxImportance - minImportance;

            const adjustedMinRisk = minRisk - 0.05 * riskRange;
            const adjustedMaxRisk = maxRisk + 0.05 * riskRange;

            const adjustedMinImportance = minImportance - 0.05 * importanceRange;
            const adjustedMaxImportance = maxImportance + 0.05 * importanceRange;

            // Log min and max combined scores
            console.log("drawRiskMatrix Min combined score:", minCombinedScore);
            console.log("drawRiskMatrix Max combined score:", maxCombinedScore);

            // Check if there are any outliers
            console.log("drawRiskMatrix Number of risk outliers:", riskOutliers.filter(Boolean).length);
            console.log("drawRiskMatrix Number of importance outliers:", importanceOutliers.filter(Boolean).length);

            // Check the size of the scatter data
            console.log("drawRiskMatrix Scatter data length:", scatterData.length);

            var ctx = document.getElementById('riskMatrix').getContext('2d');
            var chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'Risks',
                        data: scatterData,
                        backgroundColor: context => {
                            const dataPoint = context.dataset.data[context.dataIndex];
                            return dataPoint && dataPoint.combinedScore ? getColorForCombinedScore(dataPoint.combinedScore) : 'rgba(0,0,0,0.1)';
                        },
                        borderColor: 'white',
                        borderWidth: 1,
                        pointStyle: 'circle',
                        pointRadius: 8,
                        hoverRadius: 12
                    }]
                },
                options: {
                    scales: {
                        y: {
                            min: adjustedMinImportance,
                            max: adjustedMaxImportance,
                            title: {
                                display: true,
                                text: 'Importance',
                                color: 'white',
                                font: {
                                    size: 16
                                }
                            },
                            ticks: {
                                color: 'white',
                                beginAtZero: true,
                                fontSize: 14
                            },
                            grid: {
                                color: '#b4f5ff',
                                lineWidth: 0.5
                            }
                        },
                        x: {
                            min: adjustedMinRisk,
                            max: adjustedMaxRisk,
                            title: {
                                display: true,
                                text: 'Risk',
                                color: 'white',
                                font: {
                                    size: 16
                                }
                            },
                            ticks: {
                                color: 'white',
                                beginAtZero: true,
                                fontSize: 14
                            },
                            grid: {
                                color: '#b4f5ff',
                                lineWidth: 0.5
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            enabled: true,
                            mode: 'point', // Ensure tooltips show for each individual data point
                            callbacks: {
                                label: context => {
                                    var score = context.dataset.data[context.dataIndex];
                                    return score.name + ' (Risk: ' + score.x.toFixed(2) + ', Importance: ' + score.y.toFixed(2) + ', Path: ' + score.path + ')';
                                }
                            }
                        }
                    }
                }
            });


            // Populate the risk table with only outlier nodes
            var riskTableBody = document.getElementById('riskTableBody');
            riskTableBody.innerHTML = '';
            outlierScores.forEach(function (score, index) {
                if (!score) {
                    console.error("Undefined score at index:", index);
                    return; // Skip this iteration
                }
                var row = document.createElement('tr');
                var idCell = document.createElement('td');
                var nameCell = document.createElement('td');
                var riskCell = document.createElement('td');
                var importanceCell = document.createElement('td');
                var pathCell = document.createElement('td');
                var startCell = document.createElement('td');
                var finishCell = document.createElement('td');
                var riskAdjustedStartCell = document.createElement('td');
                var riskAdjustedEndCell = document.createElement('td');
                var pageRankCell = document.createElement('td');
                //pageRankCell.textContent = score.pageRank.toFixed(5);
                pageRankCell.textContent = (score.pageRank || 0).toFixed(5);
                var slackCell = document.createElement('td');
                slackCell.textContent = score.slack.toFixed(2); // Assuming slack is a number
                var overrunProbabilityCell = document.createElement('td');
                overrunProbabilityCell.textContent = score.overrunProbability.toFixed(2);
                // Check if overrunProbability is a string and try to convert it to a number
                if (typeof score.overrunProbability === "string") {
                    let parsedValue = parseFloat(score.overrunProbability);
                    if (!isNaN(parsedValue)) {
                        overrunProbabilityCell.textContent = (parsedValue * 100).toFixed(2) + "%";
                    } else {
                        overrunProbabilityCell.textContent = score.overrunProbability;
                    }
                } else {
                    overrunProbabilityCell.textContent = (score.overrunProbability * 100).toFixed(2) + "%";
                }

                idCell.textContent = score.id;
                nameCell.textContent = score.name;
                riskCell.textContent = score.riskScore.toFixed(2);
                importanceCell.textContent = score.importanceScore.toFixed(2);
                pathCell.textContent = score.path;
                //startCell.textContent = score.start;
                //finishCell.textContent = score.finish;

                startCell.textContent = formatDate(score.start);
                finishCell.textContent = formatDate(score.finish);
                riskAdjustedStartCell.textContent = formatDate(score.riskAdjustedStart);
                riskAdjustedEndCell.textContent = formatDate(score.riskAdjustedEnd);


                // Adjust text color based on path type
                if (score.path === 'Critical Path') {
                    pathCell.style.color = 'red';
                } else if (score.path === 'Outlier Path') {
                    pathCell.style.color = 'orange';
                }

                row.appendChild(idCell);
                row.appendChild(nameCell);
                row.appendChild(riskCell);
                row.appendChild(importanceCell);
                row.appendChild(pathCell);
                row.appendChild(pageRankCell);
                row.appendChild(startCell);
                row.appendChild(finishCell);
                row.appendChild(riskAdjustedStartCell);  
                row.appendChild(riskAdjustedEndCell);
                row.appendChild(slackCell);
                row.appendChild(overrunProbabilityCell);

                riskTableBody.appendChild(row);
            });
        }

        function populatePathsTable(criticalPathData, outlierPathsData) {
            const tableBody = document.getElementById('pathTableBody');

            // Add critical path
            const criticalRow = document.createElement('tr');
            criticalRow.innerHTML = `
                                                <td class="critical">Critical Path</td>
                                                <td class="critical">${criticalPathData.duration}</td>
                                                ${criticalPathData.path.map(node => `<td class="critical">${node.ID}</td>`).join('')}
                                            `;
            tableBody.appendChild(criticalRow);

            // Add outlier paths
            outlierPathsData.paths.forEach((path, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                                                    <td class="outlier">Outlier Path</td>
                                                    <td class="outlier">${outlierPathsData.durations[index]}</td>
                                                    ${path.map(node => `<td class="outlier">${node.ID}</td>`).join('')}
                                                `;
                tableBody.appendChild(row);
            });
        }

        function drawReferenceTable(nodes) {
            var referenceTableBody = document.getElementById('referenceTableBody');
            referenceTableBody.innerHTML = '';
            nodes.forEach(function (node) {
                if (node.isOnCriticalPath || node.isOnOutlierPath) {
                    var row = document.createElement('tr');
                    var idCell = document.createElement('td');
                    var nameCell = document.createElement('td');
                    var pathCell = document.createElement('td');

                    idCell.textContent = node.ID;
                    nameCell.textContent = node.Name;

                    if (node.isOnCriticalPath) {
                        pathCell.textContent = 'Critical Path';
                        pathCell.style.color = 'red';
                    } else if (node.isOnOutlierPath) {
                        pathCell.textContent = 'Outlier Path';
                        pathCell.style.color = 'orange';
                    } else {
                        pathCell.textContent = 'Regular Path';
                    }

                    row.appendChild(idCell);
                    row.appendChild(nameCell);
                    row.appendChild(pathCell);

                    referenceTableBody.appendChild(row);
                }
            });
        }

        function drawRadialChart(nodes) {
            var ctx = document.getElementById('radialChart').getContext('2d');

            const themeColors = [
                "#cdfaff", "#b4f5ff", "#8ce6ff", "#5ac8fa",
                "#46b9fa", "#41afeb", "#3292cd", "#287dc8",
                "#1e69aa", "#195a8c"
            ];

            const supplementaryColors = [
                "#FFA500", // Orange (Used sparingly for differentiation)
                "#9400D3"  // Violet (Used sparingly for differentiation)
            ];

            function generateColor(index) {
                if (index < themeColors.length) {
                    return themeColors[index];
                } else {
                    return supplementaryColors[index - themeColors.length];
                }
            }

            nodes.sort((a, b) => b.Duration - a.Duration);
            const N = 8;
            nodes = nodes.slice(0, N);

            var myChart = new Chart(ctx, {
                type: 'polarArea',
                data: {
                    labels: nodes.map(node => node.Name),
                    datasets: [{
                        data: nodes.map(node => node.Duration),
                        backgroundColor: nodes.map((_, index) => generateColor(index)),
                        borderWidth: 1,
                        borderColor: ['#ffffff']
                    }]
                },
                options: {
                    responsive: true,
                    legend: {
                        position: 'top',
                        labels: {
                            fontColor: themeColors[5]
                        }
                    },
                    title: {
                        display: true,
                        text: 'Activity Duration Radial Chart',
                        fontColor: themeColors[6]
                    },
                    scale: {
                        ticks: {
                            beginAtZero: true,
                            fontColor: themeColors[7],
                            stepSize: Math.max(...nodes.map(node => node.Duration)) / 10
                        },
                        gridLines: {
                            color: themeColors[8]
                        }
                    },
                    plugins: {
                        tooltip: {
                            backgroundColor: 'rgba(17, 52, 100, 0.8)', // 80% transparency
                            titleFont: {
                                size: 14,  // Reduced font size for the title
                                weight: 'bold',
                                family: "'Orbitron', sans-serif"
                            },
                            bodyFont: {
                                size: 12,  // Reduced font size for the body
                                family: "'Orbitron', sans-serif"
                            },
                            callbacks: {
                                title: function (context) {
                                    return context[0].label;
                                },
                                label: function (context) {
                                    const node = nodes[context.dataIndex];
                                    return [
                                        `Duration: ${node.Duration} days`,
                                        `Risk: ${node.riskScore}`,
                                        `Importance: ${node.importanceScore}`
                                    ];
                                }
                            }
                        }
                    },
                    onHover: (event, chartElement) => {
                        if (event && event.target) {
                            event.target.style.cursor = chartElement[0] ? 'pointer' : 'default';
                        }
                    }
                }
            });

            ctx.canvas.onclick = function (event) {
                var activePoints = myChart.getElementsAtEventForMode(event, 'point', myChart.options);
                var firstPoint = activePoints[0];
                if (firstPoint) {
                    var node = nodes[firstPoint.index];
                    alert(`Clicked on: ${node.Name}`);
                }
            };
        }
        // Use the function as:
        // drawRadialChart(nodes);

        // Sample data
        var chartData = [
            { label: 'Supply Chain Disruption', value: 80 },
            { label: 'Budget Overrun', value: 90 },
            { label: 'Scope Creep', value: 70 },
            { label: 'Technical Failure', value: 50 },
            { label: 'Regulatory Changes', value: 30 },
            { label: 'Safety Incident', value: 20 },
            { label: 'Resource Shortage', value: 60 },
            { label: 'Schedule Delay', value: 40 }
        ];

        //redundannt function
        function drawScatterPlotWithD3(nodes, links) {
            let nonZeroDurationTasks = links.filter(link => link.duration > 0);
            let tasksSortedByDuration = nonZeroDurationTasks.slice().sort((a, b) => a.duration - b.duration);

            let cumulativeData = [];
            let cumulativeCount = 0;
            for (let link of tasksSortedByDuration) {
                cumulativeCount++;
                cumulativeData.push({ x: link.duration, y: cumulativeCount });
            }

            let svgWidth = 400, svgHeight = 300;
            let margin = { top: 20, right: 20, bottom: 30, left: 50 };
            let width = svgWidth - margin.left - margin.right;
            let height = svgHeight - margin.top - margin.bottom;

            let x = d3.scaleLinear().range([0, width]);
            let y = d3.scaleLinear().range([height, 0]);

            let svg = d3.select("#scurve_chart2").append("svg")
                .attr("width", svgWidth)
                .attr("height", svgHeight)
                .append("g")
                .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

            x.domain(d3.extent(cumulativeData, d => d.x));
            y.domain([0, d3.max(cumulativeData, d => d.y)]);

            svg.append("g")
                .attr("transform", "translate(0," + height + ")")
                .call(d3.axisBottom(x));

            svg.append("g")
                .call(d3.axisLeft(y));

            svg.selectAll(".dot")
                .data(cumulativeData)
                .enter().append("circle")
                .attr("class", "dot")
                .attr("r", 3.5)
                .attr("cx", d => x(d.x))
                .attr("cy", d => y(d.y))
                .style("fill", "#0077b6");
        }

        function drawPathDistributionStackedBarChart(nodes, links) {
            // Compute paths and their durations as before
            var startNode = nodes.find(node => node.ID === "0");
            var endNode = nodes.reduce((a, b) => (a.ID > b.ID) ? a : b);
            var paths = findAllPaths(startNode, endNode, links, nodes);
            const pathDurations = paths.map(path => {
                return path.reduce((total, node, index, array) => {
                    if (index < array.length - 1) {
                        let link = links.find(l => l.source === node && l.target === array[index + 1]);
                        if (!link) {
                            return total;
                        }
                        return total + link.duration;
                    }
                    return total;
                }, 0);
            });

            // Group paths by their duration to get counts
            const durationCounts = {};
            pathDurations.forEach(duration => {
                durationCounts[duration] = (durationCounts[duration] || 0) + 1;
            });

            // Prepare data for chart
            const dataForChart = {
                labels: Object.keys(durationCounts),
                datasets: [{
                    label: 'Number of Paths',
                    data: Object.values(durationCounts),
                    backgroundColor: 'rgba(70, 185, 250, 0.5)',
                    borderColor: 'rgba(70, 185, 250, 1)',
                    borderWidth: 1
                }]
            };

            // Calculate cumulative counts for overlay line graph
            let cumulativeCounts = [];
            let cumulativeCount = 0;
            Object.values(durationCounts).forEach(count => {
                cumulativeCount += count;
                cumulativeCounts.push(cumulativeCount);
            });

            // Update dataForChart to include cumulative count dataset
            dataForChart.datasets.push({
                label: 'Cumulative Count',
                data: cumulativeCounts,
                type: 'line',  // this will ensure dataset is drawn as a line
                borderColor: 'rgba(200, 50, 50, 0.8)',
                fill: false,
                pointBackgroundColor: 'rgba(200, 50, 50, 0.8)',
                pointBorderColor: 'rgba(200, 50, 50, 0.8)'
            });

            var ctx = document.getElementById('pathDistributionStackedBarChart').getContext('2d');
            new Chart(ctx, {
                type: 'bar',  // main type remains bar
                data: dataForChart,
                options: {
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Paths',
                                color: '#ffffff'
                            },
                            ticks: {
                                color: '#b4f5ff'
                            },
                            grid: {
                                color: '#195a8c'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Path Duration',
                                color: '#ffffff'
                            },
                            ticks: {
                                autoSkip: true,  // auto-skip overlapping labels
                                maxTicksLimit: 10,  // maximum 10 ticks on x-axis
                                color: '#b4f5ff',
                                maxRotation: 90,
                                minRotation: 90
                            },
                            grid: {
                                color: '#195a8c'
                            }
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return `Duration: ${context.label}, Number of Paths: ${context.dataset.data[context.dataIndex]}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        function generateKanbanCards(nodes, links) {
            const container = document.querySelector('.kanban-columns');

            // Clear existing columns
            container.innerHTML = "";

            const columns = {
                todo: [],
                inProgress: [],
                done: []
            };

            nodes.forEach(node => {
                const currentDate = new Date();
                const startDate = new Date(node.Start);
                const finishDate = new Date(node.Finish);

                // Calculate days left for deadline
                const daysLeft = Math.ceil((finishDate - currentDate) / (1000 * 60 * 60 * 24));
                const daysLeftText = daysLeft > 0 ? `${daysLeft} days left` : daysLeft === 0 ? `Due today` : `Overdue by ${Math.abs(daysLeft)} days`;

                let column = 'todo';
                if (currentDate >= startDate && currentDate <= finishDate) {
                    column = 'inProgress';
                } else if (currentDate > finishDate) {
                    column = 'done';
                }

                const pathType = node.isOnCriticalPath ? 'Critical Path' : node.isOnOutlierPath ? 'Outlier Path' : 'Regular Path';

                // Determine risk, importance, and path colors based on their values
                const riskColor = node.isRiskOutlier ? 'red' : '';
                const importanceColor = node.isImportanceOutlier ? 'red' : '';
                const pathColor = node.isOnCriticalPath ? 'red' : node.isOnOutlierPath ? 'orange' : '#8ce6ff';

                // Determine icons only if the task is an outlier
                const riskIcon = node.isRiskOutlier ? '<span class="icon"><i class="fas fa-bolt" style="color:orange;"></i> Risk Outlier</span>' : '';
                const importanceIcon = node.isImportanceOutlier ? '<span class="icon"><i class="fas fa-star" style="color:orange;"></i> Importance Outlier</span>' : '';
                const pathIcon = node.isOnCriticalPath || node.isOnOutlierPath ? `<span class="icon"><i class="fas fa-route" style="color:${pathColor};"></i> ${pathType}</span>` : '';


                // Count the number of outliers and generate the alarm icons
                const outlierCount = [node.isRiskOutlier, node.isImportanceOutlier, node.isOnCriticalPath || node.isOnOutlierPath].filter(Boolean).length;
                const alarms = '<i class="fas fa-bell" style="color:orange;"></i>'.repeat(outlierCount);

                const cardHTML = `
                    <div class="kanban-card sci-fi-card" data-start-date="${node.Start}" data-due-date="${node.Finish}" data-lateness="0">
                        <div class="alarm-indicators">${alarms}</div>
                        <h4>${node.Name} (ID: ${node.ID})</h4>
                        <ul class="futuristic-list">
                            <li style="color:${riskColor}">Risk: ${node.riskScore.toFixed(2)}</li>
                            <li style="color:${importanceColor}">Importance: ${node.importanceScore.toFixed(2)}</li>
                            <li style="color:${pathColor}">Path: ${pathType}</li>
                        </ul>
                        <p>Expected Start: ${startDate.toLocaleDateString()} | Duration: ${node.Duration} days</p>
                        <div class="card-icons">
                            <span class="due-date-icon"><i class="fas fa-calendar-alt"></i> Due: ${finishDate.toLocaleDateString()} (${daysLeftText})</span>
                            <span class="slack"><i class="fas fa-clock"></i> Slack: ${node.slack} hours</span>

                        </div>
                        <div class="outlier-indicators">
                            ${riskIcon}
                            ${importanceIcon}
                            ${pathIcon}
                        </div>
                    </div>
                `;

                columns[column].push(cardHTML);
            });

            // Create columns
            Object.keys(columns).forEach(key => {
                const columnDiv = document.createElement('div');
                columnDiv.className = 'kanban-column';
                const columnTitle = {
                    todo: 'To Do',
                    inProgress: 'In Progress',
                    done: 'Done'
                };

                columnDiv.innerHTML = `<h3 class="kanban-column-title">${columnTitle[key]}</h3>`;
                columns[key].forEach(cardHTML => {
                    columnDiv.insertAdjacentHTML('beforeend', cardHTML);
                });

                container.appendChild(columnDiv);
            });

            // Create date range picker input
            const dateRangePicker = document.createElement('input');
            dateRangePicker.id = 'dateRangePicker';
            document.body.appendChild(dateRangePicker);

            const dateRangeLabel = document.createElement('span');
            dateRangeLabel.id = 'dateRangeLabel';
            document.body.appendChild(dateRangeLabel);

            const dateRangeSlider = document.createElement('input');
            dateRangeSlider.id = 'dateRangeSlider';
            dateRangeSlider.type = 'range';
            dateRangeSlider.min = 0;
            dateRangeSlider.max = 365; // Assuming a max project duration of one year
            dateRangeSlider.step = 1;
            dateRangeSlider.value = 365; // Default to one year
            document.body.appendChild(dateRangeSlider);

            // Initialize the date range picker
            flatpickr("#dateRangePicker", {
                mode: "range",
                dateFormat: "Y-m-d",
                onChange: function (selectedDates, dateStr, instance) {
                    // When the date range changes, filter the Kanban cards
                    if (selectedDates.length === 2) {
                        const startDate = selectedDates[0];
                        const endDate = selectedDates[1];
                        filterKanbanCards(startDate, endDate);
                    }
                }
            });

            dateRangeSlider.addEventListener('input', function () {
                const days = parseInt(this.value, 10);
                const startDate = new Date();
                const endDate = new Date(startDate);
                endDate.setDate(startDate.getDate() + days);
                updateDateRangeLabel([startDate, endDate]);
                filterKanbanCards(startDate, endDate);
            });

            function updateDateRangeLabel(selectedDates) {
                if (selectedDates && selectedDates.length === 2) {
                    const diff = Math.abs(selectedDates[1] - selectedDates[0]);
                    const days = Math.ceil(diff / (1000 * 60 * 60 * 24));
                    if (days <= 30) {
                        dateRangeLabel.textContent = `${days} days`;
                    } else if (days <= 90) {
                        dateRangeLabel.textContent = `${Math.ceil(days / 7)} weeks`;
                    } else {
                        dateRangeLabel.textContent = `${Math.ceil(days / 30)} months`;
                    }
                }
            }

            // Function to filter the Kanban cards by date range
            function filterKanbanCards(startDate, endDate) {
                // Get all of the Kanban cards
                const cards = document.querySelectorAll('.kanban-card');

                // Hide or show each card based on its start date and due date
                cards.forEach(card => {
                    const start = new Date(card.getAttribute('data-start-date'));
                    const due = new Date(card.getAttribute('data-due-date'));
                    if (start >= startDate && due <= endDate) {
                        card.style.display = 'block';
                    } else {
                        card.style.display = 'none';
                    }

                    // Calculate days to completion
                    let daysToCompletion = 0;
                    if (start > currentDate) {
                        daysToCompletion = (start - currentDate) / (1000 * 60 * 60 * 24);
                    } else if (due > currentDate) {
                        daysToCompletion = (due - currentDate) / (1000 * 60 * 60 * 24);
                    }

                    if (daysToCompletion) {
                        const daysInfo = document.createElement('p');
                        daysInfo.innerText = `Days to completion: ${Math.ceil(daysToCompletion)}`;
                        card.appendChild(daysInfo);
                    }
                });
            }
        }

    </script>
   
    <style>
        /* Sidebar Styles */
        #sidebar {
            transition: width 0.5s; /* Smooth transition for width changes */
            overflow-x: hidden; /* Hide horizontal scrollbar */
        }

            /* Collapsed state styles for the sidebar */
            #sidebar.collapsed {
                width: 116px !important;  /* Width of the sidebar when collapsed */
            }

                #sidebar.collapsed ul {
                    display: none; /* Hide the list items when sidebar is collapsed */
                }

        /* Button styles for toggling sidebar */
        #sidebarToggleBtn {
            background-color: #113464; /* Dark color from the theme */
            color: #cdfaff; /* Light color from the theme */
            border: none;
            cursor: pointer;
            padding: 10px 15px;
            margin: 10px;
            border-radius: 5px;
            font-size: 24px; /* Size of the icon */
            transition: background-color 0.3s; /* Smooth transition for hover effect */
        }

            #sidebarToggleBtn:hover {
                background-color: #1e69aa; /* Lighter color from the theme for hover effect */
            }

        /* Toggle Button in collapsed state */
        #sidebar.collapsed #sidebarToggleBtn {
            background-color: #113464; /* Dark color from the theme */
            padding: 2px 29px; /* Reduced padding to make the button more compact */
            font-size: 27px; /* Size of the icon */
        }

        /* Adjusting the position and z-index of the toggle button */
        #sidebarToggleBtn {
            position: relative; /* Relative positioning */
            z-index: 9999; /* Ensuring the button stays above other elements but doesn't interfere */
        }
    </style>
    <style>
        /* New low-profile toggle button styles */
        #sidebarToggleBtn {
            background-color: #113464; /* Dark blue from the provided palette */
            border: none;
            cursor: pointer;
            padding: 10px;
            margin: 10px 0;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.3s, transform 0.3s;
        }

            #sidebarToggleBtn:hover {
                background-color: #0d2137; /* Slightly darker blue on hover */
            }

            #sidebarToggleBtn svg {
                fill: #b4f5ff; /* Light blue for the icon */
                width: 20px;
                height: 20px;
            }

        #sidebar.collapsed #sidebarToggleBtn {
            transform: scaleX(0.7); /* Squeeze the button horizontally when sidebar is collapsed */
        }

        /* SVG icon styles for the toggle button */
        .toggle-icon {
            transition: transform 0.3s; /* Smooth transition for icon rotation */
        }
    </style>
    <style>
        /* Distinct sci-fi theme for the container */
        .dashboard-section.introduction-section {
            background: linear-gradient(135deg, #113464, #287dc8);
            border-radius: 25px;
            padding: 30px;
            box-shadow: 0 0 25px #3292cd;
            font-family: 'Arial', sans-serif; /* Modern font */
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        /* Distinct styling for the dropdowns */
        .project-dropdown, .location-dropdown {
            width: 99%;
            background: linear-gradient(135deg, #287dc8, #113464);
            border: none;
            border-bottom: 3px solid #3292cd;
            border-radius: 0;
            color: #cdfaff;
            padding: 8px 15px;
            outline: none;
            box-shadow: none;
            cursor: pointer;
            transition: border-bottom 0.3s;
            font-weight: bold;
            appearance: none;
        }

            .project-dropdown:hover, .location-dropdown:hover {
                border-bottom: 3px solid #cdfaff;
            }

        /* Distinct styling for the custom file upload button */
        /* Hiding the traditional file input */
        #xmlFileInput {
            display: none;
        }

        /* Custom designed button for file selection */
        .custom-file-upload {
            display: inline-block;
            background: linear-gradient(45deg, #3292cd, #195a8c);
            border: 2px solid #3292cd;
            border-radius: 10px;
            color: #cdfaff;
            padding: 10px 20px;
            outline: none;
            cursor: pointer;
            transition: background 0.3s, transform 0.3s;
            text-align: center;
            font-size: 16px;
            box-shadow: 0 0 10px #3292cd;
            position: relative;
            width: 26%;
        }

            .custom-file-upload:hover {
                background: linear-gradient(45deg, #287dc8, #113464);
                transform: translateY(-2px);
            }

            .custom-file-upload:active {
                transform: translateY(0);
            }

        /* Icon for the custom file upload button */
        /* .custom-file-upload:before {
                content: '⬆';
                font-size: 20px;
                position: absolute;
                left: 15px;
                top: 50%;
                transform: translateY(-50%);
            } */

        /* Feedback after file selection */
        #xmlFileInput:after {
            content: attr(data-content);
            display: block;
            background: #113464;
            color: #cdfaff;
            border: 2px dashed #3292cd;
            margin-top: 20px;
            padding: 10px;
            border-radius: 15px;
            transition: all 0.3s;
            font-style: italic;
        }
    </style>
    <style>
        /* General body styling */
        body {
            font-family: 'Arial', sans-serif; /* Modern font */
            background: #113464;
            color: #cdfaff;
        }

        /* Links enhancement */
        a {
            color: #3292cd;
            text-decoration: none;
            transition: color 0.3s;
        }

            a:hover {
                color: #cdfaff;
            }

        /* Button enhancements */
        button {
            background: linear-gradient(135deg, #287dc8, #113464);
            border: 2px solid #3292cd;
            border-radius: 15px;
            color: #cdfaff;
            padding: 8px 16px;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            font-weight: bold;
            outline: none;
        }

            button:hover {
                background: linear-gradient(135deg, #3292cd, #195a8c);
                transform: translateY(-2px);
                box-shadow: 0 0 15px #cdfaff;
            }

            button:active {
                transform: translateY(0);
            }

        /* Enhancements for different containers and sections */
        .dashboard-section {
            margin: 20px;
            border-radius: 20px;
            padding: 25px;
            box-shadow: 0 0 20px #3292cd;
        }

        /* Enhancements for headers and titles */
        h2, h3, h4, h5, h6 {
            color: #cdfaff;
            border-bottom: 2px solid #3292cd;
            padding-bottom: 10px;
        }
    </style>
    <style>
        .dashboard-stat .zoom-in-icon,
        .dashboard-stat .zoom-out-icon,
        .dashboard-stat .reset-icon,
        .dashboard-stat .arrow-icon {
            font-size: 24px !important; /* Increase font size specifically for these icons */
        }
    </style>
    <style>
        /* Ensuring the progress bar content is visible */
        .dashboard-stat .progress-bar {
            background-color: #5ac8fa; /* Using a color from the provided theme */
            height: 20px; /* Increasing height for better visibility */
            border-radius: 10px; /* Rounded corners for aesthetic appeal */
        }

        /* Increasing width of the column containing the progress bar */
        .dashboard-stat .progress-column {
            width: 150px !important; /* Assigning a fixed width to ensure full visibility */
        }

       
    </style>
    <style>
        /* Typography */
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap');

        body {
            font-family: 'Orbitron', sans-serif;
        }

        /* Colors & Background */
        body {
            background: linear-gradient(to bottom right, #0e2446, #113464);
            color: #b4f5ff;
        }

        .dashboard-section {
            background: rgba(16, 45, 80, 0.8);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }

        /* Buttons */
        .btn, .icon-button {
            background: #5ac8fa;
            border: none;
            border-radius: 20px;
            padding: 10px 20px;
            font-size: 14px;
            color: #0d2137;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

            .btn:hover, .icon-button:hover {
                background: #3292cd;
                box-shadow: 0 3px 10px rgba(0, 0, 0, 0.5);
                transform: translateY(-2px);
            }

        /* Hover & Transition Effects */
        a:hover {
            text-decoration: underline;
            color: #cdfaff;
        }

        /* Additional Styling for Progress Bars */
        .progress-bar {
            background-color: #0d2137;
            border: 1px solid #287dc8;
        }

        .progress-bar-fill {
            background-color: #5ac8fa;
            height: 100%;
            transition: width 0.5s ease;
        }
    </style>

   
   

    >
</head></html>

<body>
    <script charset="utf-8" src="//js.hsforms.net/forms/embed/v2.js" type="text/javascript"></script>
    <div class="dashboard-card futuristic-card" style="background: rgba(255, 255, 255, 0.03); border: 2px solid rgba(255, 255, 255, 0.2); border-radius: 15px; margin: 20px 0; padding: 20px; box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);background-image: url('https://www.transparenttextures.com/patterns/space.png');background-color: rgba(0, 0, 0, 0.6);padding: 40px; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 20px; position: relative;">
        <div class="project-network-animation-enhanced" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: auto; z-index: 0;">
            <canvas id="networkCanvasEnhanced"></canvas>
        </div>
        <div class="border-graphic-container" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;"></div>
        <div class="introduction-logo-container" style="text-align: center; margin-bottom: 20px;position: relative; z-index: 2;">
            <img alt="Cybereum Logo" src="https://cybereum.io/wp-content/uploads/2022/12/cropped-circle6.png" style="max-width: 120px; border-radius: 50%; box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);box-shadow: 0 0 40px #5ac8fa;" />
        </div>
        <div id="networkAnimationTooltip" style="position: absolute; display: none; padding: 5px 10px; background-color: rgba(0, 0, 0, 0.8); border-radius: 5px; color: #cdfaff; pointer-events: none; font-size: 14px; transition: opacity 0.3s; z-index: 999;"></div>
        <div id="connectionLabel" style="position: absolute; display: none; max-width: 0px !important; padding: 5px 10px; background-color: rgba(0, 0, 0, 0.8); border-radius: 5px; color: #cdfaff; pointer-events: none; font-size: 14px; transition: opacity 0.3s; z-index: 1000;"></div>
        <div class="block-header futuristic-header" style="background: rgba(0, 0, 0, 0.2); border-top-left-radius: 15px; border-top-right-radius: 15px; padding: 10px 20px; box-shadow: 0 0 10px #5ac8fa;position: relative; z-index: 2;">
            <h1 class="block-title text-white" style="text-shadow: 0 0 10px #5ac8fa;"><i class="fas fa-rocket"></i> Welcome to Cybereum - the Future of Project Management</h1>
        </div>
        <p class="futuristic-introduction" style="color: #cdfaff; font-size: 18px; margin-top: 20px; line-height: 1.6; text-align: center; padding: 0 10%; margin-bottom: 30px;position: relative; z-index: 2;max-width: 900px; text-align: center;">
            Harness the unmatched power of Cybereum's futuristic project analysis platform, a harmonious blend of advanced algorithms
            and intuitive design. Every piece of project data tells a story, and our tools are crafted meticulously to bring those stories to life to redefine the boundaries of project management.

            The Cybereum platform offers not just ground-breaking tools; it  transcends traditional boundaries between companies and data,
            offering insights that are profound and ground breaking. Cybereum is here to revolutionize the way you
            perceive project management. So, are you ready to take a leap into the future?
        </p>
        <div class="introduction-graphic-container" style="text-align: center; margin-top: 30px;position: relative; z-index: 2;">
            <img alt="Futuristic Graphic" src="https://placeimg.com/500/500/tech" style="max-width: 100%; border-radius: 15px; box-shadow: 0 0 20px rgba(0, 0, 0, 0.4);" />
        </div>
        <style>
            .block-title.text-white:hover {
                color: #5ac8fa; /* Change to the desired "lit up" color */
                text-shadow: 0 0 15px #5ac8fa; /* Adds a glow effect */
            }

            .project-network-animation-enhanced {
                position: relative;
                width: 80%;
                height: 80%;
                overflow: hidden;
                background-color: rgba(0, 0, 0, 0.2);
                border-radius: 10px;
            }

            #networkCanvasEnhanced {
                width: 100%;
                height: 100%;
            }

            #connectionLabel {
                position: absolute;
                display: none; /* Initially hidden */
                padding: 5px 10px;
                background-color: rgba(0, 0, 0, 0.8);
                border-radius: 5px;
                color: #cdfaff;
                pointer-events: none;
                font-size: 14px;
                transition: opacity 0.3s;
                z-index: 1000;
                transform-origin: center;
                max-width: 0px !important;
            }
        </style>
        <script>
            const canvasEnhanced = document.getElementById('networkCanvasEnhanced');
            const ctxEnhanced = canvasEnhanced.getContext('2d');
            //const nodeLabel = document.getElementById('nodeLabel');
            //const tooltipDiv = document.getElementById('networkAnimationTooltip');
            canvasEnhanced.width = canvasEnhanced.parentElement.offsetWidth;
            canvasEnhanced.height = canvasEnhanced.parentElement.offsetHeight;

            const phrases = [
                "Empower your projects with Cybereum's cutting-edge platform.",
                "Dive deep into data-driven decision-making.",
                "Harness the power of Cybereum's futuristic platform.",
                "Blend of advanced algorithms and intuitive design.",
                "ML for forecasting, AI for intelligence, DLT for collaboration.",
                "Every piece of data tells a story with Cybereum.",
                "Redefine the boundaries of project management.",
                "We offer experiences, not just tools.",
                "Revolutionize the way you perceive project management.",
                "Take a leap into the future with Cybereum.",
                "Experience the next-gen project analytics.",
                "Where innovation meets intuition.",
                "Your project's success, our priority.",
                "Elevate project management norms through Cybereum",
                "Strategic choices through data-driven insights.",
                "Leapfrog into the future with Cybereum at your side.",
                "Predictive analytics, intelligent AI, and collaborative DLT - Cybereum's trifecta."
            ];

            const connectionLabel = document.getElementById('connectionLabel');
            const synergyPhrases = [
                "Synergistic combination of AI & DLT",
                "DLT for collaboration",
                "AI for intelligence and assistance",
                "ML for forecasting",
                "Connecting project teams into a symbiotic organization"
            ];
            let lastPhraseIndex = -1;  // to keep track of last shown phrase

            class NodeEnhanced {
                constructor(x, y, phrase) {
                    this.x = x;
                    this.y = y;
                    this.vx = (Math.random() - 0.5) * 2;
                    this.vy = (Math.random() - 0.5) * 2;
                    this.radius = Math.random() * 5 + 5;
                    this.color = 'rgba(205, 250, 255, 0.8)';
                    this.phrase = phrase;
                }

                draw() {
                    ctxEnhanced.beginPath();
                    ctxEnhanced.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctxEnhanced.fillStyle = this.color;
                    ctxEnhanced.fill();
                    ctxEnhanced.shadowColor = 'rgba(205, 250, 255, 1)';
                    ctxEnhanced.shadowBlur = 15;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x < 0 || this.x > canvasEnhanced.width) this.vx = -this.vx;
                    if (this.y < 0 || this.y > canvasEnhanced.height) this.vy = -this.vy;

                    this.draw();
                }
            }

            const nodesEnhanced = [];
            for (let i = 0; i < phrases.length; i++) {
                const x = Math.random() * canvasEnhanced.width;
                const y = Math.random() * canvasEnhanced.height;
                nodesEnhanced.push(new NodeEnhanced(x, y, phrases[i]));
            }

            canvasEnhanced.addEventListener('mousemove', (e) => {
                const tooltipDiv = document.getElementById('networkAnimationTooltip');
                const rect = canvasEnhanced.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                let closestNodes = [];
                nodesEnhanced.forEach(node => {
                    if (Math.pow(x - node.x, 2) + Math.pow(y - node.y, 2) < Math.pow(node.radius * 7, 2)) {
                        closestNodes.push(node);
                    }
                });

                if (closestNodes.length === 1) {
                    tooltipDiv.style.display = 'block';  // Make the tooltip visible
                    tooltipDiv.innerHTML = closestNodes[0].phrase;
                    tooltipDiv.style.left = `${closestNodes[0].x}px`;
                    tooltipDiv.style.top = `${closestNodes[0].y - 20}px`; // Above the node
                    tooltipDiv.style.transform = 'scale(1)';
                    tooltipDiv.style.opacity = '1';
                } else if (closestNodes.length >= 2) {
                    console.log('Two or more closest nodes found!');  // Debug line
                    const midX = (closestNodes[0].x + closestNodes[1].x) / 2;
                    const midY = (closestNodes[0].y + closestNodes[1].y) / 2;

                    lastPhraseIndex = (lastPhraseIndex + 1) % synergyPhrases.length;
                    connectionLabel.innerHTML = synergyPhrases[lastPhraseIndex];
                    connectionLabel.style.left = `${midX}px`;
                    connectionLabel.style.top = `${midY}px`;
                    connectionLabel.style.display = 'block';  // <-- Make sure you're setting display to block
                    connectionLabel.style.transform = 'scale(1)';
                    connectionLabel.style.opacity = '1';
                    connectionLabel.style.animation = 'fadeIn 0.5s ease-out';
                } else {
                    tooltipDiv.style.display = 'none';  // Hide the tooltip
                    connectionLabel.style.display = 'none';  // <-- Also hide the connectionLabel
                    connectionLabel.style.transform = 'scale(0)';
                    connectionLabel.style.opacity = '0';
                    tooltipDiv.style.transform = 'scale(0)';
                    tooltipDiv.style.opacity = '0';
                }
            });

            let connectionDivs = [];

            const maxConnections = nodesEnhanced.length * (nodesEnhanced.length - 1) / 2;
            const connectionPool = Array.from({ length: maxConnections }, (_, i) => {
                const div = document.createElement('div');
                div.style.position = 'absolute';
                div.style.padding = '5px 10px';
                div.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
                div.style.borderRadius = '5px';
                div.style.color = '#cdfaff';
                div.style.pointerEvents = 'none';
                div.style.fontSize = '14px';
                div.style.zIndex = '1000';
                div.style.display = 'none';
                document.querySelector('.project-network-animation-enhanced').appendChild(div);
                return div;
            });

            // Create a mapping to store a synergy phrase for each unique pair of nodes
            const nodePairToSynergyPhrase = new Map();

            function animateEnhanced() {
                ctxEnhanced.clearRect(0, 0, canvasEnhanced.width, canvasEnhanced.height);

                nodesEnhanced.forEach(node => {
                    node.update();
                });

                connectionLabel.style.display = 'none';  // Hide the connectionLabel by default

                for (let i = 0; i < nodesEnhanced.length; i++) {
                    for (let j = i + 1; j < nodesEnhanced.length; j++) {
                        const dx = nodesEnhanced[i].x - nodesEnhanced[j].x;
                        const dy = nodesEnhanced[i].y - nodesEnhanced[j].y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < 150) {
                            ctxEnhanced.beginPath();
                            ctxEnhanced.moveTo(nodesEnhanced[i].x, nodesEnhanced[i].y);
                            ctxEnhanced.lineTo(nodesEnhanced[j].x, nodesEnhanced[j].y);
                            ctxEnhanced.strokeStyle = 'rgba(205, 250, 255, ' + (1 - distance / 150) + ')';
                            ctxEnhanced.lineWidth = 0.5;
                            ctxEnhanced.stroke();

                            // Show the connectionLabel between the nodes
                            const midX = (nodesEnhanced[i].x + nodesEnhanced[j].x) / 2;
                            const midY = (nodesEnhanced[i].y + nodesEnhanced[j].y) / 2;

                            // Create a unique identifier for each pair of nodes
                            const nodePairIdentifier = `${i}-${j}`;

                            // Assign a synergy phrase to each unique pair of nodes, if not already done
                            if (!nodePairToSynergyPhrase.has(nodePairIdentifier)) {
                                nodePairToSynergyPhrase.set(nodePairIdentifier, synergyPhrases[lastPhraseIndex]);
                                lastPhraseIndex = (lastPhraseIndex + 1) % synergyPhrases.length;
                            }

                            connectionLabel.innerHTML = nodePairToSynergyPhrase.get(nodePairIdentifier);
                            connectionLabel.style.left = `${midX}px`;
                            connectionLabel.style.top = `${midY}px`;
                            connectionLabel.style.display = 'block';  // Make sure you're setting display to block
                        }
                    }
                }

                requestAnimationFrame(animateEnhanced);
            }


            animateEnhanced();

            document.querySelector('.block-title.text-white').addEventListener('mouseover', function () {
                this.style.color = '#5ac8fa';  // Change to the desired "lit up" color
                this.style.textShadow = '0 0 15px #5ac8fa';  // Adds a glow effect
            });

            document.querySelector('.block-title.text-white').addEventListener('mouseout', function () {
                this.style.color = 'white';  // Resets to the original color
                this.style.textShadow = '0 0 10px #5ac8fa';  // Resets to the original shadow
            });</script>
    </div>
    <script charset="utf-8" src="//js.hsforms.net/forms/embed/v2.js" type="text/javascript"></script>
    <script>
        hbspt.forms.create({
            region: "na1",
            portalId: "20558785",
            formId: "9535e8fc-88e8-43f6-b6e9-c06e15d584a2"
        });</script>
    <div id="hubspot-form-container">
        <script>
            hbspt.forms.create({
                region: "na1",
                portalId: "20558785",
                formId: "9535e8fc-88e8-43f6-b6e9-c06e15d584a2"
            });</script>
    </div>
    <section class="dashboard-section introduction-section" style="margin: 35px !important;">
        <div class="project-selection-container">
            <!--
                <div class="megaproject-icon-container">
                    <div class="megaproject-icon">
                        <img alt="Cybereum Logo" class="cybereum-logo" src="https://cybereum.io/wp-content/uploads/2022/12/cropped-circle6.png" />
                        <svg fill="none" height="100" viewbox="0 0 100 100" width="100" xmlns="http://www.w3.org/2000/svg"> -->
            <!-- Outer Circle
                    <circle cx="50" cy="50" fill="none" r="48" stroke="#5ac8fa" stroke-width="2"></circle>
                    <!-- Rotating Lines
                    <line class="rotating-line" stroke="#b4f5ff" stroke-width="2" x1="50" x2="50" y1="2" y2="20"></line>
                    <line class="rotating-line" stroke="#b4f5ff" stroke-width="2" x1="50" x2="50" y1="98" y2="80"></line>
                    <line class="rotating-line" stroke="#b4f5ff" stroke-width="2" x1="2" x2="20" y1="50" y2="50"></line>
                    <line class="rotating-line" stroke="#b4f5ff" stroke-width="2" x1="98" x2="80" y1="50" y2="50"></line>
                    <!-- Central Node
                    <circle cx="50" cy="50" fill="#5ac8fa" r="10"></circle>
                    <!-- Pulsing Effects
                    <circle class="pulsing-circle" cx="50" cy="50" fill="none" r="15" stroke="#5ac8fa" stroke-width="2"></circle>
                    <circle class="pulsing-circle" cx="50" cy="50" fill="none" r="20" stroke="#5ac8fa" stroke-width="2"></circle>
                    </svg>
                </div>
                    </div>
                        -->
            <div class="project-dropdown-container">
                <label for="projectSegment">Select Project Sector:</label>
                <select class="project-dropdown" id="projectSegment">
                    <option value="Nuclear storage">Nuclear storage</option>
                    <option value="Olympic Games">Olympic Games</option>
                    <option value="Nuclear power PWR">Nuclear power PWR</option>
                    <option value="Nuclear power BWR">Nuclear power BWR</option>
                    <option value="Nuclear power PHWR">Nuclear power PHWR</option>
                    <option value="Hydroelectric dams">Hydroelectric dams</option>
                    <option value="Flood control">Flood control</option>
                    <option value="Transportation">Transportation</option>
                    <option value="Utilities">Utilities</option>
                    <option value="IT">IT</option>
                    <option value="Nonhydroelectric dams">Nonhydroelectric dams</option>
                    <option value="Buildings">Buildings</option>
                    <option value="Aerospace">Aerospace</option>
                    <option value="Defense">Defense</option>
                    <option value="Bus rapid transit">Bus rapid transit</option>
                    <option value="Rail">Rail</option>
                    <option value="Airports">Airports</option>
                    <option value="Tunnels">Tunnels</option>
                    <option value="Oil and gas">Oil and gas</option>
                    <option value="Ports">Ports</option>
                    <option value="Hospitals, health">Hospitals, health</option>
                    <option value="Mining">Mining</option>
                    <option value="Bridges">Bridges</option>
                    <option value="Water">Water</option>
                    <option value="Fossil thermal power">Fossil thermal power</option>
                    <option value="Roads">Roads</option>
                    <option value="Pipelines">Pipelines</option>
                    <option value="Wind power">Wind power</option>
                    <option value="Energy transmission">Energy transmission</option>
                    <option value="Solar power">Solar power</option>
                </select>
            </div>
            <div class="location-dropdown-container">
                <label for="locationDropdown">Select Location:</label>
                <select class="location-dropdown" id="locationDropdown">
                    <!-- Adding a few countries for illustration. In the actual code, you'll have all countries listed. -->
                    <option value="USA">USA</option>
                    <option value="Canada">Canada</option>
                    <option value="UK">UK</option>
                    <option value="Australia">Australia</option>
                    <option value="India">India</option>
                    <!-- ... and so on for all countries -->
                </select>
            </div>
        </div>
        <label class="custom-file-upload">


            <label class="upload-label" for="xmlFileInput" style="font-weight: bold; font-size: 16px; padding: 12px 25px; box-shadow: inset 0 0 15px rgba(42, 125, 200, 0.6);">
                Upload File
            </label>
            <input accept=".xml" id="xmlFileInput" name="file" style="display: none;" type="file" />
            <div class="sci-fi-loading-bar-container" style="width: 100%; margin-top: 10px; background: rgba(40, 125, 200, 0.3); border-radius: 8px;">
                <div class="sci-fi-loading-bar" style="background: linear-gradient(90deg, #287dc8, #5ac8fa); height: 5px; border-radius: 5px; transition: width 0.5s;"></div>
                <div class="sci-fi-loading-text" style="color: #5ac8fa; font-size: 14px; margin-top: 5px; font-weight: bold; transition: opacity 0.5s; margin: 0px !important;">0%</div>
                <span class="uploading-text">Upload in progress...</span>
            </div>
        </label>
        <div id="data_div"></div>
    </section>

    <style>
        #networkViualization,
        #chart_div_wrapper,
        #riskTable,
        #referenceTable,
        #riskMatrix,
        #histogram,
        #pieChart,
        #pathsDistributionCurve,
        #radialChart,
        #sidebar,
        #dash1,
        #chart-container,
        #SCurve,
        #graph-container,
        #dash4,
        #RadialRisk,
        #Kanban,
        #Proj_Track,
        #reducedGraph {
            display: none; /* Initially hide the sections */
        }
    </style>


    <div class="dashboard-section dashboard-section-css" id="dash1">
        <div id="self-referencing-tasks-warning"><h1>Self Referencing Errors</h1></div>
    </div>
    <div class="dashboard-card dashboard-card-css" id="networkViualization" style="">
        <h1>Interactive Project Task Map</h1>
        <button onclick="openModal('modal0')" class="cus-more-button">More Information about Project Network Visualization</button>
        <div class="control-panel">
            <div class="dashboard-stat" style="width: 30%;">
                <label class="control-label">Zoom:</label>
                <button onclick="zoomIn()">+</button>
                <button onclick="zoomOut()" class="zoom-cus">-</button>
                <input class="slider" id="zoomSlider" max="100" min="1" type="range" value="50" />
                <button onclick="zoomExtents()">Extents</button>
                <label class="control-label">Rotate:</label>
                <button onclick="rotate(10)">Right</button>
                <button onclick="rotate(-10)" class="zoom-cus">Left</button>
            </div>
            <!-- Pan Controls -->
            <div class="dashboard-stat">
                <label class="control-label">Pan:</label>
                <div class="joystick">
                    <div class="arrow up" onclick="pan(0, -50)">↑</div>
                    <div class="arrow left" onclick="pan(-50, 0)">←</div>
                    <div class="center" onclick="center()">•</div>
                    <div class="arrow right" onclick="pan(50, 0)">→</div>
                    <div class="arrow down" onclick="pan(0, 50)">↓</div>
                </div>
            </div>
            <!-- Rotate Controls -->
            <!-- Node Color Legend -->
            <div class="dashboard-stat">
                <h2>Node Colors</h2>
                <div id="legend">
                    <h3><span id="legendMetric">In-degree</span>:</h3>
                    <label><input checked="" name="colorMetric" type="radio" value="degree" /> Degree</label>
                    <label><input name="colorMetric" type="radio" value="inDegree" /> In-degree</label>
                    <label><input name="colorMetric" type="radio" value="outDegree" /> Out-degree</label>
                    <div class="legend-item"><span class="color-box" style="background-color: #b4f5ff;"></span> &gt; 0</div>
                    <div class="legend-item"><span class="color-box" style="background-color: #8ce6ff;"></span> &gt; 1</div>
                    <div class="legend-item"><span class="color-box" style="background-color: #5ac8fa;"></span> &gt; 2</div>
                    <div class="legend-item"><span class="color-box" style="background-color: #46b9fa;"></span> &gt; 3</div>
                    <div class="legend-item"><span class="color-box" style="background-color: #41afeb;"></span> &gt; 4</div>
                </div>
                <div id="legend">
                    <h3><span id="riskImportanceLegendMetric">Risk/Importance</span>:</h3>
                    <label><input name="colorMetric" type="radio" value="risk" /> Risk</label>
                    <label><input name="colorMetric" type="radio" value="importance" /> Importance</label>
                    <div class="legend-item"><span class="color-box" style="background-color: green;"></span> Low</div>
                    <div class="legend-item"><span class="color-box" style="background-color: yellowgreen;"></span> Low-Medium</div>
                    <div class="legend-item"><span class="color-box" style="background-color: yellow;"></span> Medium</div>
                    <div class="legend-item"><span class="color-box" style="background-color: orange;"></span> Medium-High</div>
                    <div class="legend-item"><span class="color-box" style="background-color: red;"></span> High</div>
                </div>
            </div>

            <!-- Filter Controls -->
            <div class="dashboard-stat">
                <div class="= dashboard-card2">
                    <label class="control-label">Filter Nodes (in-degree):</label>
                    <div class="range" style="display: flex;">
                        <span id="filterValue" class="zero-css" >&gt; 0</span>
                        <input class="slider"  id="filterSlider" max="5" min="0" step="1" type="range" value="0" />
                    </div>
                </div>
                <div class="= dashboard-card2">
                    <div class="label-container">
                        <label class="control-label">Filter Nodes (out-degree):</label>
                        <div class="range" style="display: flex;">
                        <span id="outDegreeFilterValue" class="zero-css">&gt; 0</span>
                    
                    <input class="slider" id="outDegreeFilterSlider" max="5" min="0" step="1" type="range" value="0" />
                </div>
            </div>
            </div>
                <div class="= dashboard-card2">
                    <div class="label-container">
                        <!-- section for degree -->
                        <label class="control-label">Filter Nodes (degree):</label>
                        <div class="range" style="display: flex;">
                        <span id="degreeFilterValue" class="zero-css">&gt; 0</span>
                    
                    <input class="slider" id="degreeFilterSlider" max="10" min="0" step="1" type="range" value="0" />
                </div>
                </div>
                </div>

                <!-- section for risk -->
                <div class="= dashboard-card2">
                    <div class="label-container">
                        <label class="control-label">Filter Nodes (risk):</label>
                        <div class="range" style="display: flex;">
                        <span id="riskFilterValue" class="zero-css">&gt; 0</span>
                   
                    <input class="slider" id="riskFilterSlider" max="1" min="0" step="0.1" type="range" value="0" />
                </div>
                </div>
            </div>
                <!-- section for importance -->
                <div class="= dashboard-card2">
                    <div class="label-container">
                        <label class="control-label">Filter Nodes (importance):</label>
                        <div class="range" style="display: flex;">

                        <span id="importanceFilterValue" class="zero-css">&gt; 0</span>
                    
                    <input class="slider" id="importanceFilterSlider" max="1" min="0" step="0.1" type="range" value="0" />
                </div>
                </div>
            </div>
        </div>
             <!-- Accordion for Path Details -->
         <div class="accordion" style="display: flex; margin-left: 67px !important;">
           
            <div class="panel">
                <p id="criticalPathDetails">Critical path details go here...</p>
            </div>
           
            <div class="panel">
                <p id="outlierPathsDetails">Outlier paths details go here...</p>
            </div>
            
            <div class="panel">
                <p id="allPathsDetails">All paths details go here...</p>
            </div>
        </div>
        </div>

       
        <div class="control-panel">
            <!-- Search and Highlight Controls -->
            <div class="controls search-controls">
                <input id="searchInput" placeholder="Search by name or ID" type="text" />
            </div>
            <div class="highlight-controls">
                <label><input id="highlightAllConnected" type="checkbox" /> Highlight All Connected Nodes</label>
            </div>
            <!-- Path Details Display -->
            <div id="pathsDisplay"></div>
            <div id="longestPathDisplay"></div>
            <div id="outlierPathsDisplay"></div>
            <div class="highlight-controls">
                <label style="margin-left: -191px;"><input id="highlightCriticalPath" type="checkbox" /> Highlight Critical Path</label>
                <label style="padding-left: 40px;"><input id="highlightOutliers" type="checkbox" /> Highlight Outlier Paths</label>
            </div>
            <!-- Info Panel -->
            <div id="infoPanel"></div>
        </div>
    </div>
    <div id="graph-container">
        <!-- Your other graph-related content here -->
        <div id="tooltip" style="position: absolute;  background: #8ce6ff; padding: 8px; border: 2px solid #3292cd; border-radius: 3px; "></div>
        <svg>
           
            <defs>
                <marker id="arrow" markerheight="10" markerwidth="6" orient="auto" refx="9" refy="0" viewbox="0 -6 10 12">
                    <path d="M0,-5 L10,0 L0,5" fill="#cdfaff"></path>
                </marker>
                <marker id="arrow2" markerheight="10" markerunits="strokeWidth" markerwidth="10" orient="auto" refx="8" refy="3">
                    <path d="M0,0 L0,6 L9,3 z" fill="#0f0"></path>
                </marker>
            </defs>
            <g class="container"></g>
        </svg>



    </div>

    <div id="sidebar" style="z-index: 1000;">
        <button id="sidebarToggleBtn" onclick="toggleSidebar(event)">
            <svg viewbox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                <path class="toggle-icon" d="M4 6h16l-8 -8Z"></path>
            </svg>
        </button>
        <h3>Menu</h3>
        <ul>
            <li><a href="#networkViualization">Network Visualization </a></li>
            <li><a href="#chart_div_wrapper">GANTT Chart</a></li>
            <li><a href="#riskTable">Risk Table</a></li>
            <li><a href="#referenceTable">Path Metrics</a></li>
            <li><a href="#riskMatrix">Risk Matrix</a></li>
            <li><a href="#histogram">Histogram</a></li>
            <li><a href="#pieChart">Pie Chart</a></li>
            <li><a href="#pathsDistributionCurve">Paths Distribution Curve</a></li>
            <li><a href="#radialChart">Radial Chart</a></li>
            <li><a href="#Kanban">Kanban Project Flow</a></li>
            <li><a href="#Proj_Track">Project Tracker</a></li>
            <li><a href="#reducedGraph">Reduced Graph</a></li>
        </ul>
    </div>
    <div class="charts-container">
        <!-- Row for Risk Matrix -->
        <div class="charts-row">
            <div class="dashboard-card-full" id="dash4">

                <h2>Risk and Importance</h2>
               
                <div class="risk-content">
                    <div class="charts-row">
                        <div class="dashboard-card2" id="chart-container" style="margin-left: 0px !important;">
                            <h2>Risk Matrix</h2>

                            <div class="legend">
                                <h4>Risk Importance Scale:</h4>
                                <div class="scale low">Low</div>
                                <div class="scale medium">Medium</div>
                                <div class="scale high">High</div>
                            </div>
                            <canvas height="288" id="riskMatrix" width="300"></canvas>
                            </br>
                            <button class="learn-more-btn" onclick="openModal('riskMatrixModal')">Learn More</button>
                        </div>
                        <div class="dashboard-card2" id="RadialRisk" style="margin-right: 0px !important;">
                            <h2>Radial Risk Chart</h2>
                            <canvas height="280" id="radialChart" width="300"></canvas>
                            </br>
                            <button class="learn-more-btn learn-more-btn-css" onclick="openModal('radialChartModal')">Learn More</button>
                        </div>
                    </div>
                    <div class="table-container" id="pathMetrics" style="width: 100% !important;">
                        <!-- Risk Table -->
                        <h2>Risk Table</h2>
                        <table class="sortable" id="riskTable">
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>Name</th>
                                    <th>Risk</th>
                                    <th>Importance</th>
                                    <th>Path</th> <!-- Column for Path -->
                                    <th>PageRank Centrality</th>
                                    <th>Start Date</th> <!-- Start Date -->
                                    <th>End Date</th> <!--  End Date -->
                                    <th>Expected Start Date</th> <!-- Risk adjusted Start Date -->
                                    <th>Expected End Date</th> <!-- Risk adjusted End Date -->
                                    <th>Slack</th>  <!--  slack -->
                                    <th>Overrun</th>
                                </tr>
                            </thead>
                            <tbody id="riskTableBody"></tbody>
                        </table>
                    </div>

                    <div class="charts-row">
                        <div class="dashboard-card2" id="pathsDistributionCurve" style="margin-left: 0px !important;">
                            <h2>Paths Distribution Curve</h2>
                            <div id="path_distribution_chart" style="width: 90%;height: 85%;"></div>
                            <br>
                            <div style="">
                            <button class="learn-more-btn" onclick="openModal('pathsDistributionCurveModal')" >Learn More</button>
                           </div>
                        </div>
                        <div class="dashboard-card2" id="pathDistributionCard" style="margin-right: 0px !important;">
                            <h2>Path Distribution Bar Chart</h2>
                            <canvas height="280" id="pathDistributionStackedBarChart" width="300"></canvas>
                            <br>
                            <button class="learn-more-btn" onclick="openModal('pathDistributionModal')">Learn More</button>
                        </div>
                    </div>
                    <!-- Paths Distribution Table -->
                    <div class="table-container" id="pathsDistributionTableContainer">
                        <h2>Critical & Outlier Paths</h2>
                        <table class="sortable" id="pathsDistributionTable">
                            <thead>
                                <tr>
                                </tr>
                            </thead>
                            <tbody id="pathsDistributionTableBody"></tbody>
                        </table>
                    </div>

                    <!-- Reference Table for Critical & Outlier Paths -->
                    <div class="table-container" id="referenceTable">
                        <h2>Activities on the Critical & Outlier Paths</h2>
                        <table class="sortable">
                            <thead>
                                <tr>
                                    <th>ID</th>
                                    <th>Name</th>
                                    <th>Path</th>
                                </tr>
                            </thead>
                            <tbody id="referenceTableBody"></tbody>
                        </table>
                    </div>

                    <div class="dashboard-card2" id="pathDistributionCard" style="width: 100% !important;">
                        <h2>Expected Completion</h2>
                        <div id="progressBars" style="width: 100% !important;"></div>
                    </div>




                </div>
            </div>
        </div>
    </div>

    <div class="dashboard-card" id="Proj_Track" style="margin: 28px;
    padding: 40px; margin-top: 0px !important;">

        <div class="row">

            <!-- Left Side -->
            <div class="col-3">
                <!-- Schedule Completion Progress Bar -->
                <div class="block">
                    <div class="block-title text-white">
                        <h2 class="block-title text-white" data-toggle="appear" data-class="animated fadeInDown">PROJECT CORE KPIs</h2>
                    </div>
                    <label class="text-white">Scope</label>
                    <div class="progress-bar-container">
                        <div id="budgetProgressBar" class="progress-bar"></div>
                    </div>
                    <span id="budgetProgressLabel"></span>
                    <hr class="separator">
                    <label class="text-white">Schedule</label>
                    <div class="progress-bar-container">
                        <div id="scheduleProgressBar" class="progress-bar"></div>
                    </div>
                    <span id="scheduleProgressLabel"></span>
                    <hr class="separator">
                    <label class="text-white">Scope</label>
                    <div class="progress-bar-container">
                        <div id="scopeProgressBar" class="progress-bar"></div>
                    </div>
                    <span id="scopeProgressLabel"></span>
                </div>

                <!-- Key Deliverables Block -->
                <div class="block">
                    <div class="block-title text-white">
                        <h2 class="block-title text-white" data-toggle="appear" data-class="animated fadeInDown">Key Deliverables</h2>
                    </div>
                    <div class="block-content">
                        <!-- Slider for selecting the number of tasks -->
                        <div class="form-group">
                            <label for="numTasksSlider" class="text-white-op">Number of Tasks: <span id="numTasksLabel">5</span></label>
                            <input type="range" class="slider" id="numTasksSlider" min="2" max="10" value="5">
                        </div>

                        <!-- Placeholder for the tasks -->
                        <div id="keyDeliverablesTasksContainer">
                            <!-- The tasks will be dynamically populated here by the JavaScript function -->
                        </div>
                    </div>
                </div>
            </div>

            <div class="col-6">

                <!-- Cumulative Distribution of Project Hours -->
                <div class="block">
                    <div class="block-title text-white">
                        <h2 class="block-title text-white" data-toggle="appear" data-class="animated fadeInDown">Cumulative Distribution of Project Hours</h2>
                    </div>
                    <div class="block-content">
                        <div class="row">
                            <div class="col-12">
                                <canvas id="cumulativeHoursChart" style="max-width: 100%; height: 400px;"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Side -->
            <div class="col-3">
                <!-- Task Completion Status -->
                <div class="task-completion-container" id="taskCompletionContainer">
                    <!-- Task Completion Status -->
                    <div class="block">
                        <div class="block-header">
                            <h2 class="block-title text-white">Task Completion Status</h2>
                        </div>
                        <div class="block-content overflow-hidden">
                            <canvas id="taskCompletion"></canvas>
                        </div>
                    </div>
                </div>

                <!-- KEY INTERNAL MILESTONES -->
               
            </div>

            <div class="milestones-container" id="internalMilestones" style="padding-top: 35px;
            width: 100%;
            line-height: 3.5;">
                <!-- KEY INTERNAL MILESTONES -->
                <div class="block">
                    <h2 class="block-title text-white">Internal Milestones</h2>
                    <div class="block-content block-content-full overflow-hidden" id="milestonesContent">
                        <!-- This div will be dynamically populated using the JavaScript function provided earlier. -->
                    </div>
                </div>
            </div>
        </div>
        <div class="row">
            <!-- Center Milestone Table -->
            <div class="table-container" id="pathMetrics">
                <!-- Milestone Path Table -->
                <h2 style="padding-top: 50px !important;">Milestone Paths</h2>
                <table class="sortable" id="milestoneTable">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Name</th>
                            <th>Risk</th>
                            <th>Importance</th>
                            <th>Start Date</th>
                            <th>End Date</th>
                            <th>Expected End Date</th>
                            <th>Slack</th>
                            <th>Overrun</th>
                            <th>Path</th>
                        </tr>
                    </thead>
                    <tbody id="milestoneTableBody"></tbody>
                </table>
            </div>
        </div>
        </div>

        <div class="charts-row" style="padding-right: 11px;
        padding-left: 12px;">
            <div class="dashboard-card2" id="SCurve">
                <h2>S-Curve (Cumulative Distribution Chart)</h2>

                <div id="scurve_chart" style="width: 300px; height: 336px;"></div>
                </br>
                <button class="learn-more-btn" onclick="openModal('SCurveModal')" >Learn More</button>
            </div>
            <div class="dashboard-card2" id="histogram">
                <h2>Task Duration Histogram</h2>
                <canvas height="280" id="histogramChart" width="300"></canvas>
                </br>
                <button class="learn-more-btn" onclick="openModal('histogramModal')">Learn More</button>
            </div>
            <div class="dashboard-card2" id="pieChart">
                <h2>Distribution of Task Types (Pie Chart)</h2>
                <div id="pie_chart" style="width: 300px; height: 336px;"></div>
                </br>
                <button class="learn-more-btn" onclick="openModal('pieChartModal')" >Learn More</button>

            </div>
            <div class="dashboard-card2" id="pathsDistributionCurve">
                <h2>Paths Distribution Curve</h2>
                <div id="path_distribution_chart" style="width: 300px; height: 280px;"></div>
                </br>
                <button class="learn-more-btn" onclick="openModal('pathsDistributionCurveModal')">Learn More</button>
            </div>
            <div class="dashboard-card2" id="RadialRisk">
                <h2>Radial Risk Chart</h2>
                <canvas height="280" id="radialChart" width="300"></canvas>
                </br>
                <button class="learn-more-btn" onclick="openModal('radialChartModal')">Learn More</button>
            </div>
        </div>

        <section id="Kanban" style="margin: 31px !important;">
            <!-- Date Range Slider -->
            <div class="date-slider-container">
                <input type="text" id="dateRangePicker" placeholder="Select Date Range...">
            </div>

            <div class="kanban-columns">

                <!-- Column 1: Planned -->
                <div class="kanban-column" id="plannedColumn">
                    <h3 class="kanban-column-title">Planned</h3>
                    <!-- Cards will be dynamically added here -->
                </div>

                <!-- Column 2: In Progress -->
                <div class="kanban-column" id="inProgressColumn">
                    <h3 class="kanban-column-title">In Progress</h3>
                    <!-- Cards will be dynamically added here -->
                </div>

                <!-- Column 3: Completed -->
                <div class="kanban-column" id="completedColumn">
                    <h3 class="kanban-column-title">Completed</h3>
                    <!-- Cards will be dynamically added here -->
                </div>

            </div>
        </section>

        <div class="dashboard-section" id="chart_div_wrapper">
            <h2>GANTT Chart</h2>
            <div id="chart_div"></div>
        </div>
        <div id="error_div"></div>

        <div class="dashboard-section" id="reducedGraph">
            <h1>Reduced Graph</h1>
            <!--
    <button id="clusterBtn">Cluster</button>
    <button id="declusterBtn">De-cluster</button>
    -->         
            <div id="graph-container">
                <div id="tooltip" style="position: absolute; visibility: hidden; background: #8ce6ff; padding: 8px; border: 2px solid #3292cd; border-radius: 3px; "></div>
                <div id="path-list" style="position: absolute; top: 0; left: 0; max-height: 600px; overflow-y: auto;"></div>

                <div id="dependency_chart" style="width: 90%; height: 600px; margin-left: 10%;">Graph will be rendered here.</div>

            </div>
            <!--<div id="configuration-container"></div> -->
        </div>
    <section class="dashboard-section banner-section"><div class="ran-inspired-banner" style="background: linear-gradient(to bottom, #ffff00, #ff0000); padding: 50px 0; text-align: center; box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3); margin: 40px 0; border-radius: 20px; position: relative; overflow: hidden;"><canvas class="particle-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;"></canvas><img alt="Cybereum Logo" src="https://cybereum.io/wp-content/uploads/2023/05/Red_Logo.png" style="width: 120px; margin-bottom: 20px; filter: drop-shadow(0 0 15px #fdfd96);" /><h1 style="color: #ffff00; font-size: 28px; margin-bottom: 15px; font-weight: bold; text-shadow: 2px 2px 8px rgba(0, 0, 0, 0.5);">Cybereum: A Symphony of Data and Design</h1><p style="color: #ffff00; font-size: 20px; max-width: 900px; margin: 0 auto; text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.5);">Our platform combines traditional project management with cutting-edge innovation. Expereince and Manage your Projects.</p></div></section>
    <!-- Footer -->
            <div class="footer" style="background-color: rgba(0, 0, 0, 0.8); padding: 20px; color: #58a6ff; text-align: center;">
                <p>© 2023 Cybereum. All rights reserved.</p>
                <p>Powered by Advanced Algorithms, Intuitive Design, ML, AI, and DLT.</p>
            </div>
            <script>
                function toggleSidebar() {
                    var sidebar = document.getElementById('sidebar');
                    if (sidebar.classList.contains('collapsed')) {
                        sidebar.classList.remove('collapsed');
                    } else {
                        sidebar.classList.add('collapsed');
                    }
                }</script>
            <script>
                function toggleSidebar(event) {
                    event.stopPropagation();  // Prevent event from propagating further

                    var sidebar = document.getElementById('sidebar');
                    var toggleBtn = document.getElementById('sidebarToggleBtn');
                    if (sidebar.classList.contains('collapsed')) {
                        sidebar.classList.remove('collapsed');
                        toggleBtn.innerHTML = "≡";  /* Hamburger icon for expanded state */
                    } else {
                        sidebar.classList.add('collapsed');
                        toggleBtn.innerHTML = "←";  /* Arrow icon for collapsed state */
                    }
                }</script>
            <script>
                document.getElementById('xmlFileInput').addEventListener('change', function () {
                    var fileName = this.files[0].name;
                    this.setAttribute('data-content', 'Selected: ' + fileName);
                });</script>

            <script>
                document.getElementById("xmlFileInput").addEventListener("change", function () {
                    if (this.files.length > 0) {
                        // If a file is selected, show all the sections
                        document.getElementById('networkViualization').style.display = 'block';
                        document.getElementById('chart_div_wrapper').style.display = 'block';
                        document.getElementById('riskTable').style.display = 'block';
                        document.getElementById('referenceTable').style.display = 'block';
                        document.getElementById('riskMatrix').style.display = 'block';
                        document.getElementById('histogram').style.display = 'block';
                        document.getElementById('pieChart').style.display = 'block';
                        document.getElementById('pathsDistributionCurve').style.display = 'block';
                        document.getElementById('radialChart').style.display = 'block';
                        document.getElementById('reducedGraph').style.display = 'block';
                        document.getElementById('dash1').style.display = 'block';
                        document.getElementById('chart-container').style.display = 'block';
                        document.getElementById('sidebar').style.display = 'block';
                        document.getElementById('SCurve').style.display = 'block';
                        document.getElementById('graph-container').style.display = 'block';
                        document.getElementById('dash4').style.display = 'block';
                        document.getElementById('Kanban').style.display = 'block';
                        document.getElementById('RadialRisk').style.display = 'block';
                        document.getElementById('Proj_Track').style.display = 'block';
                    }
                    //document.querySelector(".sci-fi-loading-text").innerText = "Loading...";
                    // Simulate loading progression (this can be replaced with actual loading progression in the real environment)
                    let progress = 0;
                    document.querySelector('.uploading-text').style.display = 'inline-block';
                    const interval = setInterval(() => {
                        progress += 10;
                        if (progress > 100) {
                            progress = 100;
                            clearInterval(interval);
                            document.querySelector(".sci-fi-loading-text").innerText = "";
                            document.querySelector('.uploading-text').style.display = 'none';
                        }
                        document.querySelector(".sci-fi-loading-bar").style.width = progress + "%";
                    }, 500);
                });
            </script>
            <div id="modal0" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('modal0')">&times;</span>
                    <h2 class="modal-header">Introduction:</h2>
                    <div class="modal-body">
                        <b>Features & Navigation:</b>
                        <ul class="futuristic-list">
                            <li><b>Zoom & Pan:</b> Navigate across the expansive network with ease. Use the mouse wheel to zoom in or out and click-drag to pan.</li>
                            <li><b>Node Details:</b> Hover over nodes to see detailed insights. Click on them for a deeper dive.</li>
                            <li><b>Color-coded Paths:</b> Different paths, like 'Critical' or 'Outlier', are represented with distinct colors for better clarity.</li>
                            <li><b>Interactive Links:</b> The connections between nodes are as informative as the nodes themselves. Hover or click for more details.</li>
                            <li><b>Dynamic Layout:</b> Add, remove, or modify nodes and watch the network adjust in real-time.</li>
                        </ul>
                    </div>
                </div>
            </div>

            <div id="networkVisualizationModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('networkVisualizationModal')">&times;</span>
                    <h2>Introduction:</h2>
                    Dive deep into the interconnections of your project with Cybereum's Network Visualization. This interactive tool offers a graphical representation of nodes and their relationships, making complex data structures understandable at a glance.
                    <br><br>
                    <b>Features & Navigation:</b>
                    <ul class="futuristic-list">
                        <li><b>Zoom & Pan:</b> Navigate across the expansive network with ease. Use the mouse wheel to zoom in or out and click-drag to pan.</li>
                        <li><b>Node Details:</b> Hover over nodes to see detailed insights. Click on them for a deeper dive.</li>
                        <li><b>Color-coded Paths:</b> Different paths, like 'Critical' or 'Outlier', are represented with distinct colors for better clarity.</li>
                        <li><b>Interactive Links:</b> The connections between nodes are as informative as the nodes themselves. Hover or click for more details.</li>
                        <li><b>Dynamic Layout:</b> Add, remove, or modify nodes and watch the network adjust in real-time.</li>
                    </ul>
                </div>
            </div>

            <div id="ganttChartModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('ganttChartModal')">&times;</span>
                    <h2>GANTT Chart: A Timeline of Progress</h2>
                    Track project milestones and task progress with the GANTT Chart. This horizontal bar chart gives you a visual timeline of when each task starts, its duration, and when it concludes.
                    <br><br>
                    <b>Features & Navigation:</b>
                    <ul class="futuristic-list">
                        <li><b>Resizable Bars:</b> Adjust task durations by dragging the edges of the bars.</li>
                        <li><b>Dependencies:</b> See how tasks are interlinked with arrows. A delay in one task impacts dependent tasks.</li>
                        <li><b>Hover Insights:</b> For a quick summary of task details, just hover over its bar.</li>
                        <li><b>Color-coded Status:</b> Tasks are color-coded based on their progress or status, making it easy to identify pending, ongoing, or completed tasks.</li>
                    </ul>
                </div>
            </div>

            <div id="riskMatrixModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('riskMatrixModal')">&times;</span>
                    <h2>Risk Matrix: Evaluating Potential Pitfalls</h2>
                    The Risk Matrix helps assess and prioritize risks based on their potential impact and likelihood. Understand which risks require immediate attention and which can be monitored over time.
                    <br><br>
                    <b>Features & Navigation:</b>
                    <ul class="futuristic-list">
                        <li><b>Quadrant View:</b> Risks are plotted on a 2D matrix, categorizing them into four quadrants based on severity and occurrence probability.</li>
                        <li><b>Interactive Points:</b> Hover over points to see detailed risk descriptions.</li>
                        <li><b>Color Indicators:</b> High-priority risks are marked distinctly for quick identification.</li>
                        <li><b>Adjustable Axes:</b> Customize the matrix's axes to suit your risk evaluation criteria.</li>
                    </ul>
                </div>
            </div>

            <div id="histogramModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('histogramModal')">&times;</span>
                    <h2>Histogram: Data Distribution Insights</h2>
                    The Histogram offers a visual representation of the frequency distribution of your data. It helps you understand where most of your data points lie and identify any outliers.
                    <br><br>
                    <b>Features & Navigation:</b>
                    <ul class="futuristic-list">
                        <li><b>Bins:</b> The x-axis represents data ranges, while the y-axis shows the frequency of data points within those ranges.</li>
                        <li><b>Interactive Bars:</b> Hover over bars for exact counts.</li>
                        <li><b>Customizable Ranges:</b> Adjust the bin width to analyze data distribution at varying levels of granularity.</li>
                    </ul>
                </div>
            </div>

            <div id="pieChartModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('pieChartModal')">&times;</span>
                    <h2>Pie Chart: A Slice of Your Data</h2>
                    The Pie Chart provides a circular statistical graphic divided into slices to illustrate numerical proportions. It's a visual treat that also offers deep data insights.
                    <br><br>
                    <b>Features & Navigation:</b>
                    <ul class="futuristic-list">
                        <li><b>Segmented View:</b> Each segment represents a category, and its size is proportional to its value.</li>
                        <li><b>Hover Insights:</b> For detailed percentages and values, hover over slices.</li>
                        <li><b>Color-coded Categories:</b> Each category gets a unique color for easy differentiation.</li>
                    </ul>
                </div>
            </div>

            <div id="pathsDistributionCurveModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('pathsDistributionCurveModal')">&times;</span>
                    <h2>Paths Distribution Curve: Understanding Path Frequencies</h2>
                    The Paths Distribution Curve visualizes how often different paths are taken within your project. It aids in identifying common routes and anomalies.
                    <br><br>
                    <b>Features & Navigation:</b>
                    <ul class="futuristic-list">
                        <li><b>Area Under Curve:</b> The shaded region helps understand path frequencies at a glance.</li>
                        <li><b>Interactive Points:</b> Hover over specific points on the curve for detailed insights.</li>
                        <li><b>Customizable Axes:</b> Adjust axis scales to focus on specific sections of the distribution.</li>
                    </ul>
                </div>
            </div>

            <div id="radialChartModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('radialChartModal')">&times;</span>
                    <h2>Radial Chart: A 360° View of Your Data</h2>
                    The Radial Chart, or Circular Bar Chart, offers a unique twist to traditional bar charts. Data categories are represented in a circular fashion, providing a comprehensive view of your metrics.
                    <br><br>
                    <b>Features & Navigation:</b>
                    <ul class="futuristic-list">
                        <li><b>Circular Bars:</b> Each bar's length is proportional to its value.</li>
                        <li><b>Hover Details:</b> Hover over bars for specific data insights.</li>
                        <li><b>Segmented Categories:</b> Each category is distinctly color-coded.</li>
                    </ul>
                </div>
            </div>

            <div id="reducedGraphModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('reducedGraphModal')">&times;</span>
                    <h2>Reduced Graph: A Simplified Network View</h2>
                    When networks become overwhelmingly complex, the Reduced Graph comes into play. It offers a simplified view, focusing on key nodes and connections.
                    <br><br>
                    <b>Features & Navigation:</b>
                    <ul class="futuristic-list">
                        <li><b>Key Nodes:</b> Only the most significant nodes are displayed.</li>
                        <li><b>Simplified Connections:</b> Redundant or non-critical links are omitted for clarity.</li>
                        <li><b>Interactive Elements:</b> As with the full Network Visualization, you can zoom, pan, and click for detailed insights.</li>
                    </ul>
                </div>
            </div>


            <div id="SCurveModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('SCurveModal')">&times;</span>
                    <h2>S Curve: Cumulative Distribution</h2>
                    When networks become overwhelmingly complex, the Reduced Graph comes into play. It offers a simplified view, focusing on key nodes and connections.
                    <br><br>
                    <b>Features & Navigation:</b>
                    <ul class="futuristic-list">
                        <li><b>Key Nodes:</b> Only the most significant nodes are displayed.</li>
                        <li><b>Simplified Connections:</b> Redundant or non-critical links are omitted for clarity.</li>
                        <li><b>Interactive Elements:</b> As with the full Network Visualization, you can zoom, pan, and click for detailed insights.</li>
                    </ul>
                </div>
            </div>

            <div id="pathDistributionModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('pathDistributionModal')">&times;</span>
                    <h2>Path Distribution Bar Chart: Visualizing Path Durations</h2>
                    The Path Distribution Bar Chart showcases the number of paths based on their durations. It aids in understanding the most frequent path durations and their respective counts within the network.
                    <br><br>
                    <b>Features & Navigation:</b>
                    <ul class="futuristic-list">
                        <li><b>Duration Bins:</b> The x-axis showcases various path durations, while the y-axis displays the count of paths for each duration.</li>
                        <li><b>Interactive Bars:</b> Hover over bars to get the exact count of paths for specific durations.</li>
                        <li><b>Cumulative Line Overlay:</b> A line overlaying the bars shows the cumulative count of paths, aiding in understanding the growth in path counts as duration increases.</li>
                    </ul>
                </div>
            </div>

            <div id="riskMatrixModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close-btn" onclick="closeModal('riskMatrixModal')">&times;</span>
                    <h2>Risk Matrix: Evaluating Risk Impact vs. Likelihood</h2>
                    The Risk Matrix is a critical tool for risk assessment. By plotting risks based on their impact and likelihood, it helps in prioritizing and strategizing risk management efforts.
                    <br><br>
                    <b>Features & Navigation:</b>
                    <ul class="futuristic-list">
                        <li><b>Risk Importance Scale:</b> Risks are color-coded based on their importance. Shades of red, yellow, and green signify high, medium, and low risks respectively.</li>
                        <li><b>Interactive Cells:</b> Hover over specific cells in the matrix to get detailed insights on the number of risks and their descriptions.</li>
                        <li><b>Grid Layout:</b> The matrix is divided into a grid where the x-axis represents risk likelihood and the y-axis showcases risk impact.</li>
                    </ul>
                </div>
            </div>

            <div id="taskModal" class="futuristic-modal">
                <div class="futuristic-modal-content">
                    <span class="close" onclick="closeModal('riskMatrixModal')">&times;</span>
                    <h2 class="modal-header">Task Details:</h2>
                    <p id="taskDetail"></p>
                </div>
            </div>


            <script>
                // Function to open a modal
                function openModal(modalId) {
                    document.getElementById(modalId).style.display = "block";
                }

                // Function to close a modal
                function closeModal(modalId) {
                    document.getElementById(modalId).style.display = "none";
                }

                // Closing modal if clicked outside the modal content
                window.onclick = function (event) {
                    if (event.target.classList.contains('futuristic-modal')) {
                        event.target.style.display = "none";
                    }
                }
            </script>
            <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
            <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.16.0/umd/popper.min.js"></script>
            <script src="https://maxcdn.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js"></script>

</body>
